// MACHINE GENERATED SOURCE FILE WITH ROSE (Grammar.h)--- DO NOT MODIFY!

#include "sage3basic.h"

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
   #include "AST_FILE_IO.h"
#endif 
// The header file ("rose_config.h") should only be included by source files that require it.
#include "rose_config.h"

#if _MSC_VER
#define USE_CPP_NEW_DELETE_OPERATORS 0
#endif

#define ROSE_ALLOC_TRACE 0
#undef mprintf
#define mprintf Rose::Diagnostics::mfprintf(Rose::ir_node_mlog[Rose::Diagnostics::DEBUG])

#include <Rose/BinaryAnalysis/RegisterDictionary.h>

using namespace std;

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNode*  SgNode::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNode* poolStart = reinterpret_cast<SgNode*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNode::getNodeIdStringInternal(SgNode* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNode* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNode::pool_size * sizeof(SgNode))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNode*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNode::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 59 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSupport*  SgSupport::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSupport* poolStart = reinterpret_cast<SgSupport*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSupport::getNodeIdStringInternal(SgSupport* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSupport* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSupport::pool_size * sizeof(SgSupport))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSupport*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSupport::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 96 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgModifier*  SgModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgModifier* poolStart = reinterpret_cast<SgModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgModifier::getNodeIdStringInternal(SgModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgModifier::pool_size * sizeof(SgModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 133 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgModifierNodes*  SgModifierNodes::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgModifierNodes* poolStart = reinterpret_cast<SgModifierNodes*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgModifierNodes::getNodeIdStringInternal(SgModifierNodes* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgModifierNodes* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgModifierNodes::pool_size * sizeof(SgModifierNodes))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgModifierNodes*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgModifierNodes::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 170 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgConstVolatileModifier*  SgConstVolatileModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgConstVolatileModifier* poolStart = reinterpret_cast<SgConstVolatileModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgConstVolatileModifier::getNodeIdStringInternal(SgConstVolatileModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgConstVolatileModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgConstVolatileModifier::pool_size * sizeof(SgConstVolatileModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgConstVolatileModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgConstVolatileModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 207 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStorageModifier*  SgStorageModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStorageModifier* poolStart = reinterpret_cast<SgStorageModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStorageModifier::getNodeIdStringInternal(SgStorageModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStorageModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStorageModifier::pool_size * sizeof(SgStorageModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStorageModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStorageModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 244 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAccessModifier*  SgAccessModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAccessModifier* poolStart = reinterpret_cast<SgAccessModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAccessModifier::getNodeIdStringInternal(SgAccessModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAccessModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAccessModifier::pool_size * sizeof(SgAccessModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAccessModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAccessModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 281 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionModifier*  SgFunctionModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionModifier* poolStart = reinterpret_cast<SgFunctionModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionModifier::getNodeIdStringInternal(SgFunctionModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionModifier::pool_size * sizeof(SgFunctionModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 318 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUPC_AccessModifier*  SgUPC_AccessModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUPC_AccessModifier* poolStart = reinterpret_cast<SgUPC_AccessModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUPC_AccessModifier::getNodeIdStringInternal(SgUPC_AccessModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUPC_AccessModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUPC_AccessModifier::pool_size * sizeof(SgUPC_AccessModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUPC_AccessModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUPC_AccessModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 355 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSpecialFunctionModifier*  SgSpecialFunctionModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSpecialFunctionModifier* poolStart = reinterpret_cast<SgSpecialFunctionModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSpecialFunctionModifier::getNodeIdStringInternal(SgSpecialFunctionModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSpecialFunctionModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSpecialFunctionModifier::pool_size * sizeof(SgSpecialFunctionModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSpecialFunctionModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSpecialFunctionModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 392 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElaboratedTypeModifier*  SgElaboratedTypeModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElaboratedTypeModifier* poolStart = reinterpret_cast<SgElaboratedTypeModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElaboratedTypeModifier::getNodeIdStringInternal(SgElaboratedTypeModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElaboratedTypeModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElaboratedTypeModifier::pool_size * sizeof(SgElaboratedTypeModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElaboratedTypeModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElaboratedTypeModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 429 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLinkageModifier*  SgLinkageModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLinkageModifier* poolStart = reinterpret_cast<SgLinkageModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLinkageModifier::getNodeIdStringInternal(SgLinkageModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLinkageModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLinkageModifier::pool_size * sizeof(SgLinkageModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLinkageModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLinkageModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 466 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBaseClassModifier*  SgBaseClassModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBaseClassModifier* poolStart = reinterpret_cast<SgBaseClassModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBaseClassModifier::getNodeIdStringInternal(SgBaseClassModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBaseClassModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBaseClassModifier::pool_size * sizeof(SgBaseClassModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBaseClassModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBaseClassModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 503 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStructureModifier*  SgStructureModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStructureModifier* poolStart = reinterpret_cast<SgStructureModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStructureModifier::getNodeIdStringInternal(SgStructureModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStructureModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStructureModifier::pool_size * sizeof(SgStructureModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStructureModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStructureModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 540 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeModifier*  SgTypeModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeModifier* poolStart = reinterpret_cast<SgTypeModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeModifier::getNodeIdStringInternal(SgTypeModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeModifier::pool_size * sizeof(SgTypeModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 577 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDeclarationModifier*  SgDeclarationModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDeclarationModifier* poolStart = reinterpret_cast<SgDeclarationModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDeclarationModifier::getNodeIdStringInternal(SgDeclarationModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDeclarationModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDeclarationModifier::pool_size * sizeof(SgDeclarationModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDeclarationModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDeclarationModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 614 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOpenclAccessModeModifier*  SgOpenclAccessModeModifier::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOpenclAccessModeModifier* poolStart = reinterpret_cast<SgOpenclAccessModeModifier*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOpenclAccessModeModifier::getNodeIdStringInternal(SgOpenclAccessModeModifier* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOpenclAccessModeModifier* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOpenclAccessModeModifier::pool_size * sizeof(SgOpenclAccessModeModifier))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOpenclAccessModeModifier*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOpenclAccessModeModifier::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 651 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgName*  SgName::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgName* poolStart = reinterpret_cast<SgName*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgName::getNodeIdStringInternal(SgName* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgName* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgName::pool_size * sizeof(SgName))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgName*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgName::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 688 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSymbolTable*  SgSymbolTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSymbolTable* poolStart = reinterpret_cast<SgSymbolTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSymbolTable::getNodeIdStringInternal(SgSymbolTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSymbolTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSymbolTable::pool_size * sizeof(SgSymbolTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSymbolTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSymbolTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 725 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAttribute*  SgAttribute::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAttribute* poolStart = reinterpret_cast<SgAttribute*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAttribute::getNodeIdStringInternal(SgAttribute* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAttribute* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAttribute::pool_size * sizeof(SgAttribute))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAttribute*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAttribute::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 762 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPragma*  SgPragma::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPragma* poolStart = reinterpret_cast<SgPragma*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPragma::getNodeIdStringInternal(SgPragma* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPragma* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPragma::pool_size * sizeof(SgPragma))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPragma*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPragma::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 799 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBitAttribute*  SgBitAttribute::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBitAttribute* poolStart = reinterpret_cast<SgBitAttribute*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBitAttribute::getNodeIdStringInternal(SgBitAttribute* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBitAttribute* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBitAttribute::pool_size * sizeof(SgBitAttribute))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBitAttribute*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBitAttribute::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 836 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFuncDecl_attr*  SgFuncDecl_attr::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFuncDecl_attr* poolStart = reinterpret_cast<SgFuncDecl_attr*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFuncDecl_attr::getNodeIdStringInternal(SgFuncDecl_attr* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFuncDecl_attr* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFuncDecl_attr::pool_size * sizeof(SgFuncDecl_attr))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFuncDecl_attr*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFuncDecl_attr::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 873 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClassDecl_attr*  SgClassDecl_attr::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClassDecl_attr* poolStart = reinterpret_cast<SgClassDecl_attr*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClassDecl_attr::getNodeIdStringInternal(SgClassDecl_attr* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClassDecl_attr* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClassDecl_attr::pool_size * sizeof(SgClassDecl_attr))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClassDecl_attr*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClassDecl_attr::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 910 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

Sg_File_Info*  Sg_File_Info::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     Sg_File_Info* poolStart = reinterpret_cast<Sg_File_Info*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string Sg_File_Info::getNodeIdStringInternal(Sg_File_Info* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     Sg_File_Info* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (Sg_File_Info::pool_size * sizeof(Sg_File_Info))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<Sg_File_Info*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + Sg_File_Info::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 947 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFile*  SgFile::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFile* poolStart = reinterpret_cast<SgFile*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFile::getNodeIdStringInternal(SgFile* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFile* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFile::pool_size * sizeof(SgFile))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFile*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFile::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 984 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSourceFile*  SgSourceFile::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSourceFile* poolStart = reinterpret_cast<SgSourceFile*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSourceFile::getNodeIdStringInternal(SgSourceFile* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSourceFile* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSourceFile::pool_size * sizeof(SgSourceFile))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSourceFile*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSourceFile::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1021 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnknownFile*  SgUnknownFile::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnknownFile* poolStart = reinterpret_cast<SgUnknownFile*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnknownFile::getNodeIdStringInternal(SgUnknownFile* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnknownFile* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnknownFile::pool_size * sizeof(SgUnknownFile))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnknownFile*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnknownFile::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1058 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBinaryComposite*  SgBinaryComposite::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBinaryComposite* poolStart = reinterpret_cast<SgBinaryComposite*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBinaryComposite::getNodeIdStringInternal(SgBinaryComposite* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBinaryComposite* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBinaryComposite::pool_size * sizeof(SgBinaryComposite))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBinaryComposite*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBinaryComposite::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1095 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJvmComposite*  SgJvmComposite::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJvmComposite* poolStart = reinterpret_cast<SgJvmComposite*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJvmComposite::getNodeIdStringInternal(SgJvmComposite* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJvmComposite* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJvmComposite::pool_size * sizeof(SgJvmComposite))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJvmComposite*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJvmComposite::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1132 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgProject*  SgProject::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgProject* poolStart = reinterpret_cast<SgProject*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgProject::getNodeIdStringInternal(SgProject* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgProject* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgProject::pool_size * sizeof(SgProject))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgProject*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgProject::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1169 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOptions*  SgOptions::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOptions* poolStart = reinterpret_cast<SgOptions*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOptions::getNodeIdStringInternal(SgOptions* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOptions* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOptions::pool_size * sizeof(SgOptions))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOptions*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOptions::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1206 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnparse_Info*  SgUnparse_Info::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnparse_Info* poolStart = reinterpret_cast<SgUnparse_Info*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnparse_Info::getNodeIdStringInternal(SgUnparse_Info* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnparse_Info* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnparse_Info::pool_size * sizeof(SgUnparse_Info))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnparse_Info*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnparse_Info::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1243 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBaseClass*  SgBaseClass::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBaseClass* poolStart = reinterpret_cast<SgBaseClass*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBaseClass::getNodeIdStringInternal(SgBaseClass* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBaseClass* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBaseClass::pool_size * sizeof(SgBaseClass))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBaseClass*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBaseClass::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1280 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExpBaseClass*  SgExpBaseClass::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExpBaseClass* poolStart = reinterpret_cast<SgExpBaseClass*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExpBaseClass::getNodeIdStringInternal(SgExpBaseClass* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExpBaseClass* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExpBaseClass::pool_size * sizeof(SgExpBaseClass))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExpBaseClass*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExpBaseClass::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1317 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNonrealBaseClass*  SgNonrealBaseClass::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNonrealBaseClass* poolStart = reinterpret_cast<SgNonrealBaseClass*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNonrealBaseClass::getNodeIdStringInternal(SgNonrealBaseClass* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNonrealBaseClass* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNonrealBaseClass::pool_size * sizeof(SgNonrealBaseClass))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNonrealBaseClass*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNonrealBaseClass::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1354 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypedefSeq*  SgTypedefSeq::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypedefSeq* poolStart = reinterpret_cast<SgTypedefSeq*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypedefSeq::getNodeIdStringInternal(SgTypedefSeq* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypedefSeq* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypedefSeq::pool_size * sizeof(SgTypedefSeq))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypedefSeq*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypedefSeq::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1391 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateParameter*  SgTemplateParameter::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateParameter* poolStart = reinterpret_cast<SgTemplateParameter*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateParameter::getNodeIdStringInternal(SgTemplateParameter* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateParameter* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateParameter::pool_size * sizeof(SgTemplateParameter))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateParameter*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateParameter::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1428 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateArgument*  SgTemplateArgument::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateArgument* poolStart = reinterpret_cast<SgTemplateArgument*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateArgument::getNodeIdStringInternal(SgTemplateArgument* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateArgument* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateArgument::pool_size * sizeof(SgTemplateArgument))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateArgument*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateArgument::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1465 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDirectory*  SgDirectory::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDirectory* poolStart = reinterpret_cast<SgDirectory*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDirectory::getNodeIdStringInternal(SgDirectory* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDirectory* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDirectory::pool_size * sizeof(SgDirectory))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDirectory*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDirectory::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1502 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFileList*  SgFileList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFileList* poolStart = reinterpret_cast<SgFileList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFileList::getNodeIdStringInternal(SgFileList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFileList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFileList::pool_size * sizeof(SgFileList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFileList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFileList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1539 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDirectoryList*  SgDirectoryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDirectoryList* poolStart = reinterpret_cast<SgDirectoryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDirectoryList::getNodeIdStringInternal(SgDirectoryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDirectoryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDirectoryList::pool_size * sizeof(SgDirectoryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDirectoryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDirectoryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1576 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionParameterTypeList*  SgFunctionParameterTypeList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionParameterTypeList* poolStart = reinterpret_cast<SgFunctionParameterTypeList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionParameterTypeList::getNodeIdStringInternal(SgFunctionParameterTypeList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionParameterTypeList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionParameterTypeList::pool_size * sizeof(SgFunctionParameterTypeList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionParameterTypeList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionParameterTypeList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1613 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgQualifiedName*  SgQualifiedName::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgQualifiedName* poolStart = reinterpret_cast<SgQualifiedName*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgQualifiedName::getNodeIdStringInternal(SgQualifiedName* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgQualifiedName* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgQualifiedName::pool_size * sizeof(SgQualifiedName))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgQualifiedName*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgQualifiedName::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1650 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateArgumentList*  SgTemplateArgumentList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateArgumentList* poolStart = reinterpret_cast<SgTemplateArgumentList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateArgumentList::getNodeIdStringInternal(SgTemplateArgumentList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateArgumentList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateArgumentList::pool_size * sizeof(SgTemplateArgumentList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateArgumentList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateArgumentList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1687 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateParameterList*  SgTemplateParameterList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateParameterList* poolStart = reinterpret_cast<SgTemplateParameterList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateParameterList::getNodeIdStringInternal(SgTemplateParameterList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateParameterList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateParameterList::pool_size * sizeof(SgTemplateParameterList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateParameterList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateParameterList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1724 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGraph*  SgGraph::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGraph* poolStart = reinterpret_cast<SgGraph*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGraph::getNodeIdStringInternal(SgGraph* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGraph* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGraph::pool_size * sizeof(SgGraph))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGraph*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGraph::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1761 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIncidenceDirectedGraph*  SgIncidenceDirectedGraph::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIncidenceDirectedGraph* poolStart = reinterpret_cast<SgIncidenceDirectedGraph*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIncidenceDirectedGraph::getNodeIdStringInternal(SgIncidenceDirectedGraph* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIncidenceDirectedGraph* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIncidenceDirectedGraph::pool_size * sizeof(SgIncidenceDirectedGraph))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIncidenceDirectedGraph*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIncidenceDirectedGraph::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1798 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBidirectionalGraph*  SgBidirectionalGraph::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBidirectionalGraph* poolStart = reinterpret_cast<SgBidirectionalGraph*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBidirectionalGraph::getNodeIdStringInternal(SgBidirectionalGraph* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBidirectionalGraph* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBidirectionalGraph::pool_size * sizeof(SgBidirectionalGraph))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBidirectionalGraph*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBidirectionalGraph::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1835 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStringKeyedBidirectionalGraph*  SgStringKeyedBidirectionalGraph::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStringKeyedBidirectionalGraph* poolStart = reinterpret_cast<SgStringKeyedBidirectionalGraph*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStringKeyedBidirectionalGraph::getNodeIdStringInternal(SgStringKeyedBidirectionalGraph* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStringKeyedBidirectionalGraph* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStringKeyedBidirectionalGraph::pool_size * sizeof(SgStringKeyedBidirectionalGraph))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStringKeyedBidirectionalGraph*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStringKeyedBidirectionalGraph::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1872 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIntKeyedBidirectionalGraph*  SgIntKeyedBidirectionalGraph::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIntKeyedBidirectionalGraph* poolStart = reinterpret_cast<SgIntKeyedBidirectionalGraph*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIntKeyedBidirectionalGraph::getNodeIdStringInternal(SgIntKeyedBidirectionalGraph* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIntKeyedBidirectionalGraph* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIntKeyedBidirectionalGraph::pool_size * sizeof(SgIntKeyedBidirectionalGraph))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIntKeyedBidirectionalGraph*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIntKeyedBidirectionalGraph::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1909 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIncidenceUndirectedGraph*  SgIncidenceUndirectedGraph::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIncidenceUndirectedGraph* poolStart = reinterpret_cast<SgIncidenceUndirectedGraph*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIncidenceUndirectedGraph::getNodeIdStringInternal(SgIncidenceUndirectedGraph* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIncidenceUndirectedGraph* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIncidenceUndirectedGraph::pool_size * sizeof(SgIncidenceUndirectedGraph))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIncidenceUndirectedGraph*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIncidenceUndirectedGraph::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1946 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGraphNode*  SgGraphNode::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGraphNode* poolStart = reinterpret_cast<SgGraphNode*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGraphNode::getNodeIdStringInternal(SgGraphNode* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGraphNode* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGraphNode::pool_size * sizeof(SgGraphNode))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGraphNode*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGraphNode::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 1983 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGraphEdge*  SgGraphEdge::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGraphEdge* poolStart = reinterpret_cast<SgGraphEdge*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGraphEdge::getNodeIdStringInternal(SgGraphEdge* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGraphEdge* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGraphEdge::pool_size * sizeof(SgGraphEdge))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGraphEdge*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGraphEdge::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2020 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDirectedGraphEdge*  SgDirectedGraphEdge::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDirectedGraphEdge* poolStart = reinterpret_cast<SgDirectedGraphEdge*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDirectedGraphEdge::getNodeIdStringInternal(SgDirectedGraphEdge* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDirectedGraphEdge* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDirectedGraphEdge::pool_size * sizeof(SgDirectedGraphEdge))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDirectedGraphEdge*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDirectedGraphEdge::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2057 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUndirectedGraphEdge*  SgUndirectedGraphEdge::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUndirectedGraphEdge* poolStart = reinterpret_cast<SgUndirectedGraphEdge*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUndirectedGraphEdge::getNodeIdStringInternal(SgUndirectedGraphEdge* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUndirectedGraphEdge* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUndirectedGraphEdge::pool_size * sizeof(SgUndirectedGraphEdge))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUndirectedGraphEdge*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUndirectedGraphEdge::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2094 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGraphNodeList*  SgGraphNodeList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGraphNodeList* poolStart = reinterpret_cast<SgGraphNodeList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGraphNodeList::getNodeIdStringInternal(SgGraphNodeList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGraphNodeList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGraphNodeList::pool_size * sizeof(SgGraphNodeList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGraphNodeList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGraphNodeList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2131 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGraphEdgeList*  SgGraphEdgeList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGraphEdgeList* poolStart = reinterpret_cast<SgGraphEdgeList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGraphEdgeList::getNodeIdStringInternal(SgGraphEdgeList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGraphEdgeList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGraphEdgeList::pool_size * sizeof(SgGraphEdgeList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGraphEdgeList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGraphEdgeList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2168 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeTable*  SgTypeTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeTable* poolStart = reinterpret_cast<SgTypeTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeTable::getNodeIdStringInternal(SgTypeTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeTable::pool_size * sizeof(SgTypeTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2205 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNameGroup*  SgNameGroup::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNameGroup* poolStart = reinterpret_cast<SgNameGroup*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNameGroup::getNodeIdStringInternal(SgNameGroup* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNameGroup* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNameGroup::pool_size * sizeof(SgNameGroup))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNameGroup*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNameGroup::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2242 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDimensionObject*  SgDimensionObject::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDimensionObject* poolStart = reinterpret_cast<SgDimensionObject*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDimensionObject::getNodeIdStringInternal(SgDimensionObject* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDimensionObject* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDimensionObject::pool_size * sizeof(SgDimensionObject))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDimensionObject*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDimensionObject::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2279 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFormatItem*  SgFormatItem::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFormatItem* poolStart = reinterpret_cast<SgFormatItem*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFormatItem::getNodeIdStringInternal(SgFormatItem* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFormatItem* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFormatItem::pool_size * sizeof(SgFormatItem))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFormatItem*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFormatItem::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2316 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFormatItemList*  SgFormatItemList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFormatItemList* poolStart = reinterpret_cast<SgFormatItemList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFormatItemList::getNodeIdStringInternal(SgFormatItemList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFormatItemList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFormatItemList::pool_size * sizeof(SgFormatItemList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFormatItemList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFormatItemList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2353 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDataStatementGroup*  SgDataStatementGroup::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDataStatementGroup* poolStart = reinterpret_cast<SgDataStatementGroup*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDataStatementGroup::getNodeIdStringInternal(SgDataStatementGroup* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDataStatementGroup* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDataStatementGroup::pool_size * sizeof(SgDataStatementGroup))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDataStatementGroup*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDataStatementGroup::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2390 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDataStatementObject*  SgDataStatementObject::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDataStatementObject* poolStart = reinterpret_cast<SgDataStatementObject*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDataStatementObject::getNodeIdStringInternal(SgDataStatementObject* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDataStatementObject* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDataStatementObject::pool_size * sizeof(SgDataStatementObject))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDataStatementObject*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDataStatementObject::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2427 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIncludeFile*  SgIncludeFile::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIncludeFile* poolStart = reinterpret_cast<SgIncludeFile*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIncludeFile::getNodeIdStringInternal(SgIncludeFile* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIncludeFile* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIncludeFile::pool_size * sizeof(SgIncludeFile))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIncludeFile*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIncludeFile::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2464 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDataStatementValue*  SgDataStatementValue::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDataStatementValue* poolStart = reinterpret_cast<SgDataStatementValue*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDataStatementValue::getNodeIdStringInternal(SgDataStatementValue* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDataStatementValue* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDataStatementValue::pool_size * sizeof(SgDataStatementValue))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDataStatementValue*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDataStatementValue::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2501 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaImportStatementList*  SgJavaImportStatementList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaImportStatementList* poolStart = reinterpret_cast<SgJavaImportStatementList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaImportStatementList::getNodeIdStringInternal(SgJavaImportStatementList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaImportStatementList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaImportStatementList::pool_size * sizeof(SgJavaImportStatementList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaImportStatementList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaImportStatementList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2538 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaClassDeclarationList*  SgJavaClassDeclarationList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaClassDeclarationList* poolStart = reinterpret_cast<SgJavaClassDeclarationList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaClassDeclarationList::getNodeIdStringInternal(SgJavaClassDeclarationList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaClassDeclarationList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaClassDeclarationList::pool_size * sizeof(SgJavaClassDeclarationList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaClassDeclarationList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaClassDeclarationList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2575 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgHeaderFileReport*  SgHeaderFileReport::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgHeaderFileReport* poolStart = reinterpret_cast<SgHeaderFileReport*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgHeaderFileReport::getNodeIdStringInternal(SgHeaderFileReport* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgHeaderFileReport* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgHeaderFileReport::pool_size * sizeof(SgHeaderFileReport))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgHeaderFileReport*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgHeaderFileReport::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2612 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgType*  SgType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgType* poolStart = reinterpret_cast<SgType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgType::getNodeIdStringInternal(SgType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgType::pool_size * sizeof(SgType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2649 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeUnknown*  SgTypeUnknown::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeUnknown* poolStart = reinterpret_cast<SgTypeUnknown*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeUnknown::getNodeIdStringInternal(SgTypeUnknown* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeUnknown* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeUnknown::pool_size * sizeof(SgTypeUnknown))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeUnknown*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeUnknown::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2686 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeChar*  SgTypeChar::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeChar* poolStart = reinterpret_cast<SgTypeChar*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeChar::getNodeIdStringInternal(SgTypeChar* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeChar* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeChar::pool_size * sizeof(SgTypeChar))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeChar*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeChar::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2723 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeSignedChar*  SgTypeSignedChar::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeSignedChar* poolStart = reinterpret_cast<SgTypeSignedChar*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeSignedChar::getNodeIdStringInternal(SgTypeSignedChar* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeSignedChar* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeSignedChar::pool_size * sizeof(SgTypeSignedChar))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeSignedChar*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeSignedChar::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2760 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeUnsignedChar*  SgTypeUnsignedChar::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeUnsignedChar* poolStart = reinterpret_cast<SgTypeUnsignedChar*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeUnsignedChar::getNodeIdStringInternal(SgTypeUnsignedChar* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeUnsignedChar* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeUnsignedChar::pool_size * sizeof(SgTypeUnsignedChar))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeUnsignedChar*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeUnsignedChar::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2797 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeShort*  SgTypeShort::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeShort* poolStart = reinterpret_cast<SgTypeShort*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeShort::getNodeIdStringInternal(SgTypeShort* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeShort* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeShort::pool_size * sizeof(SgTypeShort))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeShort*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeShort::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2834 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeSignedShort*  SgTypeSignedShort::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeSignedShort* poolStart = reinterpret_cast<SgTypeSignedShort*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeSignedShort::getNodeIdStringInternal(SgTypeSignedShort* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeSignedShort* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeSignedShort::pool_size * sizeof(SgTypeSignedShort))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeSignedShort*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeSignedShort::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2871 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeUnsignedShort*  SgTypeUnsignedShort::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeUnsignedShort* poolStart = reinterpret_cast<SgTypeUnsignedShort*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeUnsignedShort::getNodeIdStringInternal(SgTypeUnsignedShort* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeUnsignedShort* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeUnsignedShort::pool_size * sizeof(SgTypeUnsignedShort))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeUnsignedShort*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeUnsignedShort::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2908 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeInt*  SgTypeInt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeInt* poolStart = reinterpret_cast<SgTypeInt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeInt::getNodeIdStringInternal(SgTypeInt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeInt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeInt::pool_size * sizeof(SgTypeInt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeInt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeInt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2945 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeSignedInt*  SgTypeSignedInt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeSignedInt* poolStart = reinterpret_cast<SgTypeSignedInt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeSignedInt::getNodeIdStringInternal(SgTypeSignedInt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeSignedInt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeSignedInt::pool_size * sizeof(SgTypeSignedInt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeSignedInt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeSignedInt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 2982 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeUnsignedInt*  SgTypeUnsignedInt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeUnsignedInt* poolStart = reinterpret_cast<SgTypeUnsignedInt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeUnsignedInt::getNodeIdStringInternal(SgTypeUnsignedInt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeUnsignedInt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeUnsignedInt::pool_size * sizeof(SgTypeUnsignedInt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeUnsignedInt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeUnsignedInt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3019 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeLong*  SgTypeLong::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeLong* poolStart = reinterpret_cast<SgTypeLong*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeLong::getNodeIdStringInternal(SgTypeLong* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeLong* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeLong::pool_size * sizeof(SgTypeLong))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeLong*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeLong::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3056 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeSignedLong*  SgTypeSignedLong::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeSignedLong* poolStart = reinterpret_cast<SgTypeSignedLong*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeSignedLong::getNodeIdStringInternal(SgTypeSignedLong* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeSignedLong* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeSignedLong::pool_size * sizeof(SgTypeSignedLong))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeSignedLong*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeSignedLong::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3093 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeUnsignedLong*  SgTypeUnsignedLong::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeUnsignedLong* poolStart = reinterpret_cast<SgTypeUnsignedLong*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeUnsignedLong::getNodeIdStringInternal(SgTypeUnsignedLong* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeUnsignedLong* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeUnsignedLong::pool_size * sizeof(SgTypeUnsignedLong))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeUnsignedLong*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeUnsignedLong::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3130 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeVoid*  SgTypeVoid::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeVoid* poolStart = reinterpret_cast<SgTypeVoid*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeVoid::getNodeIdStringInternal(SgTypeVoid* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeVoid* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeVoid::pool_size * sizeof(SgTypeVoid))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeVoid*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeVoid::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3167 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeGlobalVoid*  SgTypeGlobalVoid::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeGlobalVoid* poolStart = reinterpret_cast<SgTypeGlobalVoid*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeGlobalVoid::getNodeIdStringInternal(SgTypeGlobalVoid* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeGlobalVoid* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeGlobalVoid::pool_size * sizeof(SgTypeGlobalVoid))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeGlobalVoid*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeGlobalVoid::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3204 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeWchar*  SgTypeWchar::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeWchar* poolStart = reinterpret_cast<SgTypeWchar*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeWchar::getNodeIdStringInternal(SgTypeWchar* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeWchar* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeWchar::pool_size * sizeof(SgTypeWchar))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeWchar*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeWchar::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3241 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeFloat*  SgTypeFloat::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeFloat* poolStart = reinterpret_cast<SgTypeFloat*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeFloat::getNodeIdStringInternal(SgTypeFloat* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeFloat* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeFloat::pool_size * sizeof(SgTypeFloat))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeFloat*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeFloat::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3278 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeDouble*  SgTypeDouble::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeDouble* poolStart = reinterpret_cast<SgTypeDouble*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeDouble::getNodeIdStringInternal(SgTypeDouble* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeDouble* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeDouble::pool_size * sizeof(SgTypeDouble))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeDouble*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeDouble::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3315 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeLongLong*  SgTypeLongLong::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeLongLong* poolStart = reinterpret_cast<SgTypeLongLong*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeLongLong::getNodeIdStringInternal(SgTypeLongLong* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeLongLong* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeLongLong::pool_size * sizeof(SgTypeLongLong))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeLongLong*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeLongLong::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3352 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeSignedLongLong*  SgTypeSignedLongLong::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeSignedLongLong* poolStart = reinterpret_cast<SgTypeSignedLongLong*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeSignedLongLong::getNodeIdStringInternal(SgTypeSignedLongLong* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeSignedLongLong* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeSignedLongLong::pool_size * sizeof(SgTypeSignedLongLong))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeSignedLongLong*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeSignedLongLong::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3389 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeUnsignedLongLong*  SgTypeUnsignedLongLong::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeUnsignedLongLong* poolStart = reinterpret_cast<SgTypeUnsignedLongLong*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeUnsignedLongLong::getNodeIdStringInternal(SgTypeUnsignedLongLong* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeUnsignedLongLong* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeUnsignedLongLong::pool_size * sizeof(SgTypeUnsignedLongLong))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeUnsignedLongLong*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeUnsignedLongLong::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3426 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeSigned128bitInteger*  SgTypeSigned128bitInteger::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeSigned128bitInteger* poolStart = reinterpret_cast<SgTypeSigned128bitInteger*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeSigned128bitInteger::getNodeIdStringInternal(SgTypeSigned128bitInteger* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeSigned128bitInteger* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeSigned128bitInteger::pool_size * sizeof(SgTypeSigned128bitInteger))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeSigned128bitInteger*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeSigned128bitInteger::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3463 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeUnsigned128bitInteger*  SgTypeUnsigned128bitInteger::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeUnsigned128bitInteger* poolStart = reinterpret_cast<SgTypeUnsigned128bitInteger*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeUnsigned128bitInteger::getNodeIdStringInternal(SgTypeUnsigned128bitInteger* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeUnsigned128bitInteger* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeUnsigned128bitInteger::pool_size * sizeof(SgTypeUnsigned128bitInteger))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeUnsigned128bitInteger*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeUnsigned128bitInteger::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3500 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeFloat80*  SgTypeFloat80::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeFloat80* poolStart = reinterpret_cast<SgTypeFloat80*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeFloat80::getNodeIdStringInternal(SgTypeFloat80* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeFloat80* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeFloat80::pool_size * sizeof(SgTypeFloat80))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeFloat80*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeFloat80::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3537 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeLongDouble*  SgTypeLongDouble::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeLongDouble* poolStart = reinterpret_cast<SgTypeLongDouble*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeLongDouble::getNodeIdStringInternal(SgTypeLongDouble* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeLongDouble* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeLongDouble::pool_size * sizeof(SgTypeLongDouble))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeLongDouble*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeLongDouble::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3574 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeString*  SgTypeString::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeString* poolStart = reinterpret_cast<SgTypeString*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeString::getNodeIdStringInternal(SgTypeString* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeString* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeString::pool_size * sizeof(SgTypeString))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeString*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeString::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3611 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeBool*  SgTypeBool::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeBool* poolStart = reinterpret_cast<SgTypeBool*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeBool::getNodeIdStringInternal(SgTypeBool* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeBool* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeBool::pool_size * sizeof(SgTypeBool))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeBool*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeBool::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3648 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPointerType*  SgPointerType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPointerType* poolStart = reinterpret_cast<SgPointerType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPointerType::getNodeIdStringInternal(SgPointerType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPointerType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPointerType::pool_size * sizeof(SgPointerType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPointerType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPointerType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3685 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPointerMemberType*  SgPointerMemberType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPointerMemberType* poolStart = reinterpret_cast<SgPointerMemberType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPointerMemberType::getNodeIdStringInternal(SgPointerMemberType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPointerMemberType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPointerMemberType::pool_size * sizeof(SgPointerMemberType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPointerMemberType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPointerMemberType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3722 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgReferenceType*  SgReferenceType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgReferenceType* poolStart = reinterpret_cast<SgReferenceType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgReferenceType::getNodeIdStringInternal(SgReferenceType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgReferenceType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgReferenceType::pool_size * sizeof(SgReferenceType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgReferenceType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgReferenceType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3759 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNamedType*  SgNamedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNamedType* poolStart = reinterpret_cast<SgNamedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNamedType::getNodeIdStringInternal(SgNamedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNamedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNamedType::pool_size * sizeof(SgNamedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNamedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNamedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3796 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClassType*  SgClassType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClassType* poolStart = reinterpret_cast<SgClassType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClassType::getNodeIdStringInternal(SgClassType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClassType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClassType::pool_size * sizeof(SgClassType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClassType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClassType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3833 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaParameterType*  SgJavaParameterType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaParameterType* poolStart = reinterpret_cast<SgJavaParameterType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaParameterType::getNodeIdStringInternal(SgJavaParameterType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaParameterType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaParameterType::pool_size * sizeof(SgJavaParameterType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaParameterType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaParameterType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3870 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialTableType*  SgJovialTableType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialTableType* poolStart = reinterpret_cast<SgJovialTableType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialTableType::getNodeIdStringInternal(SgJovialTableType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialTableType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialTableType::pool_size * sizeof(SgJovialTableType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialTableType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialTableType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3907 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEnumType*  SgEnumType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEnumType* poolStart = reinterpret_cast<SgEnumType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEnumType::getNodeIdStringInternal(SgEnumType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEnumType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEnumType::pool_size * sizeof(SgEnumType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEnumType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEnumType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3944 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypedefType*  SgTypedefType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypedefType* poolStart = reinterpret_cast<SgTypedefType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypedefType::getNodeIdStringInternal(SgTypedefType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypedefType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypedefType::pool_size * sizeof(SgTypedefType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypedefType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypedefType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 3981 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNonrealType*  SgNonrealType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNonrealType* poolStart = reinterpret_cast<SgNonrealType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNonrealType::getNodeIdStringInternal(SgNonrealType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNonrealType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNonrealType::pool_size * sizeof(SgNonrealType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNonrealType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNonrealType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4018 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaParameterizedType*  SgJavaParameterizedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaParameterizedType* poolStart = reinterpret_cast<SgJavaParameterizedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaParameterizedType::getNodeIdStringInternal(SgJavaParameterizedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaParameterizedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaParameterizedType::pool_size * sizeof(SgJavaParameterizedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaParameterizedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaParameterizedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4055 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaQualifiedType*  SgJavaQualifiedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaQualifiedType* poolStart = reinterpret_cast<SgJavaQualifiedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaQualifiedType::getNodeIdStringInternal(SgJavaQualifiedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaQualifiedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaQualifiedType::pool_size * sizeof(SgJavaQualifiedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaQualifiedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaQualifiedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4092 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaWildcardType*  SgJavaWildcardType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaWildcardType* poolStart = reinterpret_cast<SgJavaWildcardType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaWildcardType::getNodeIdStringInternal(SgJavaWildcardType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaWildcardType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaWildcardType::pool_size * sizeof(SgJavaWildcardType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaWildcardType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaWildcardType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4129 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskType*  SgAdaTaskType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskType* poolStart = reinterpret_cast<SgAdaTaskType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskType::getNodeIdStringInternal(SgAdaTaskType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskType::pool_size * sizeof(SgAdaTaskType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4166 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedType*  SgAdaProtectedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedType* poolStart = reinterpret_cast<SgAdaProtectedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedType::getNodeIdStringInternal(SgAdaProtectedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedType::pool_size * sizeof(SgAdaProtectedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4203 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaFormalType*  SgAdaFormalType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaFormalType* poolStart = reinterpret_cast<SgAdaFormalType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaFormalType::getNodeIdStringInternal(SgAdaFormalType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaFormalType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaFormalType::pool_size * sizeof(SgAdaFormalType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaFormalType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaFormalType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4240 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDiscriminatedType*  SgAdaDiscriminatedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDiscriminatedType* poolStart = reinterpret_cast<SgAdaDiscriminatedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDiscriminatedType::getNodeIdStringInternal(SgAdaDiscriminatedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDiscriminatedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDiscriminatedType::pool_size * sizeof(SgAdaDiscriminatedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDiscriminatedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDiscriminatedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4277 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgScopedType*  SgScopedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgScopedType* poolStart = reinterpret_cast<SgScopedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgScopedType::getNodeIdStringInternal(SgScopedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgScopedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgScopedType::pool_size * sizeof(SgScopedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgScopedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgScopedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4314 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgModifierType*  SgModifierType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgModifierType* poolStart = reinterpret_cast<SgModifierType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgModifierType::getNodeIdStringInternal(SgModifierType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgModifierType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgModifierType::pool_size * sizeof(SgModifierType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgModifierType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgModifierType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4351 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionType*  SgFunctionType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionType* poolStart = reinterpret_cast<SgFunctionType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionType::getNodeIdStringInternal(SgFunctionType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionType::pool_size * sizeof(SgFunctionType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4388 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMemberFunctionType*  SgMemberFunctionType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMemberFunctionType* poolStart = reinterpret_cast<SgMemberFunctionType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMemberFunctionType::getNodeIdStringInternal(SgMemberFunctionType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMemberFunctionType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMemberFunctionType::pool_size * sizeof(SgMemberFunctionType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMemberFunctionType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMemberFunctionType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4425 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPartialFunctionType*  SgPartialFunctionType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPartialFunctionType* poolStart = reinterpret_cast<SgPartialFunctionType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPartialFunctionType::getNodeIdStringInternal(SgPartialFunctionType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPartialFunctionType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPartialFunctionType::pool_size * sizeof(SgPartialFunctionType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPartialFunctionType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPartialFunctionType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4462 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPartialFunctionModifierType*  SgPartialFunctionModifierType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPartialFunctionModifierType* poolStart = reinterpret_cast<SgPartialFunctionModifierType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPartialFunctionModifierType::getNodeIdStringInternal(SgPartialFunctionModifierType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPartialFunctionModifierType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPartialFunctionModifierType::pool_size * sizeof(SgPartialFunctionModifierType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPartialFunctionModifierType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPartialFunctionModifierType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4499 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgArrayType*  SgArrayType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgArrayType* poolStart = reinterpret_cast<SgArrayType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgArrayType::getNodeIdStringInternal(SgArrayType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgArrayType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgArrayType::pool_size * sizeof(SgArrayType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgArrayType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgArrayType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4536 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeEllipse*  SgTypeEllipse::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeEllipse* poolStart = reinterpret_cast<SgTypeEllipse*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeEllipse::getNodeIdStringInternal(SgTypeEllipse* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeEllipse* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeEllipse::pool_size * sizeof(SgTypeEllipse))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeEllipse*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeEllipse::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4573 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateType*  SgTemplateType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateType* poolStart = reinterpret_cast<SgTemplateType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateType::getNodeIdStringInternal(SgTemplateType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateType::pool_size * sizeof(SgTemplateType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4610 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgQualifiedNameType*  SgQualifiedNameType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgQualifiedNameType* poolStart = reinterpret_cast<SgQualifiedNameType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgQualifiedNameType::getNodeIdStringInternal(SgQualifiedNameType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgQualifiedNameType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgQualifiedNameType::pool_size * sizeof(SgQualifiedNameType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgQualifiedNameType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgQualifiedNameType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4647 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeComplex*  SgTypeComplex::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeComplex* poolStart = reinterpret_cast<SgTypeComplex*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeComplex::getNodeIdStringInternal(SgTypeComplex* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeComplex* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeComplex::pool_size * sizeof(SgTypeComplex))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeComplex*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeComplex::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4684 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeImaginary*  SgTypeImaginary::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeImaginary* poolStart = reinterpret_cast<SgTypeImaginary*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeImaginary::getNodeIdStringInternal(SgTypeImaginary* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeImaginary* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeImaginary::pool_size * sizeof(SgTypeImaginary))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeImaginary*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeImaginary::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4721 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeDefault*  SgTypeDefault::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeDefault* poolStart = reinterpret_cast<SgTypeDefault*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeDefault::getNodeIdStringInternal(SgTypeDefault* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeDefault* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeDefault::pool_size * sizeof(SgTypeDefault))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeDefault*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeDefault::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4758 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeCAFTeam*  SgTypeCAFTeam::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeCAFTeam* poolStart = reinterpret_cast<SgTypeCAFTeam*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeCAFTeam::getNodeIdStringInternal(SgTypeCAFTeam* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeCAFTeam* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeCAFTeam::pool_size * sizeof(SgTypeCAFTeam))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeCAFTeam*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeCAFTeam::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4795 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeCrayPointer*  SgTypeCrayPointer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeCrayPointer* poolStart = reinterpret_cast<SgTypeCrayPointer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeCrayPointer::getNodeIdStringInternal(SgTypeCrayPointer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeCrayPointer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeCrayPointer::pool_size * sizeof(SgTypeCrayPointer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeCrayPointer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeCrayPointer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4832 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeLabel*  SgTypeLabel::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeLabel* poolStart = reinterpret_cast<SgTypeLabel*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeLabel::getNodeIdStringInternal(SgTypeLabel* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeLabel* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeLabel::pool_size * sizeof(SgTypeLabel))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeLabel*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeLabel::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4869 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaUnionType*  SgJavaUnionType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaUnionType* poolStart = reinterpret_cast<SgJavaUnionType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaUnionType::getNodeIdStringInternal(SgJavaUnionType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaUnionType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaUnionType::pool_size * sizeof(SgJavaUnionType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaUnionType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaUnionType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4906 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRvalueReferenceType*  SgRvalueReferenceType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRvalueReferenceType* poolStart = reinterpret_cast<SgRvalueReferenceType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRvalueReferenceType::getNodeIdStringInternal(SgRvalueReferenceType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRvalueReferenceType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRvalueReferenceType::pool_size * sizeof(SgRvalueReferenceType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRvalueReferenceType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRvalueReferenceType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4943 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeNullptr*  SgTypeNullptr::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeNullptr* poolStart = reinterpret_cast<SgTypeNullptr*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeNullptr::getNodeIdStringInternal(SgTypeNullptr* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeNullptr* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeNullptr::pool_size * sizeof(SgTypeNullptr))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeNullptr*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeNullptr::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 4980 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDeclType*  SgDeclType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDeclType* poolStart = reinterpret_cast<SgDeclType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDeclType::getNodeIdStringInternal(SgDeclType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDeclType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDeclType::pool_size * sizeof(SgDeclType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDeclType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDeclType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5017 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeOfType*  SgTypeOfType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeOfType* poolStart = reinterpret_cast<SgTypeOfType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeOfType::getNodeIdStringInternal(SgTypeOfType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeOfType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeOfType::pool_size * sizeof(SgTypeOfType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeOfType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeOfType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5054 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeMatrix*  SgTypeMatrix::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeMatrix* poolStart = reinterpret_cast<SgTypeMatrix*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeMatrix::getNodeIdStringInternal(SgTypeMatrix* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeMatrix* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeMatrix::pool_size * sizeof(SgTypeMatrix))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeMatrix*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeMatrix::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5091 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeTuple*  SgTypeTuple::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeTuple* poolStart = reinterpret_cast<SgTypeTuple*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeTuple::getNodeIdStringInternal(SgTypeTuple* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeTuple* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeTuple::pool_size * sizeof(SgTypeTuple))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeTuple*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeTuple::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5128 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeChar16*  SgTypeChar16::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeChar16* poolStart = reinterpret_cast<SgTypeChar16*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeChar16::getNodeIdStringInternal(SgTypeChar16* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeChar16* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeChar16::pool_size * sizeof(SgTypeChar16))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeChar16*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeChar16::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5165 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeChar32*  SgTypeChar32::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeChar32* poolStart = reinterpret_cast<SgTypeChar32*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeChar32::getNodeIdStringInternal(SgTypeChar32* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeChar32* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeChar32::pool_size * sizeof(SgTypeChar32))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeChar32*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeChar32::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5202 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeFloat128*  SgTypeFloat128::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeFloat128* poolStart = reinterpret_cast<SgTypeFloat128*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeFloat128::getNodeIdStringInternal(SgTypeFloat128* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeFloat128* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeFloat128::pool_size * sizeof(SgTypeFloat128))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeFloat128*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeFloat128::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5239 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeFixed*  SgTypeFixed::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeFixed* poolStart = reinterpret_cast<SgTypeFixed*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeFixed::getNodeIdStringInternal(SgTypeFixed* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeFixed* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeFixed::pool_size * sizeof(SgTypeFixed))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeFixed*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeFixed::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5276 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAutoType*  SgAutoType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAutoType* poolStart = reinterpret_cast<SgAutoType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAutoType::getNodeIdStringInternal(SgAutoType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAutoType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAutoType::pool_size * sizeof(SgAutoType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAutoType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAutoType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5313 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaAccessType*  SgAdaAccessType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaAccessType* poolStart = reinterpret_cast<SgAdaAccessType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaAccessType::getNodeIdStringInternal(SgAdaAccessType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaAccessType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaAccessType::pool_size * sizeof(SgAdaAccessType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaAccessType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaAccessType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5350 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaSubtype*  SgAdaSubtype::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaSubtype* poolStart = reinterpret_cast<SgAdaSubtype*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaSubtype::getNodeIdStringInternal(SgAdaSubtype* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaSubtype* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaSubtype::pool_size * sizeof(SgAdaSubtype))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaSubtype*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaSubtype::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5387 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDiscreteType*  SgAdaDiscreteType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDiscreteType* poolStart = reinterpret_cast<SgAdaDiscreteType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDiscreteType::getNodeIdStringInternal(SgAdaDiscreteType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDiscreteType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDiscreteType::pool_size * sizeof(SgAdaDiscreteType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDiscreteType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDiscreteType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5424 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaModularType*  SgAdaModularType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaModularType* poolStart = reinterpret_cast<SgAdaModularType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaModularType::getNodeIdStringInternal(SgAdaModularType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaModularType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaModularType::pool_size * sizeof(SgAdaModularType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaModularType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaModularType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5461 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDerivedType*  SgAdaDerivedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDerivedType* poolStart = reinterpret_cast<SgAdaDerivedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDerivedType::getNodeIdStringInternal(SgAdaDerivedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDerivedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDerivedType::pool_size * sizeof(SgAdaDerivedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDerivedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDerivedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5498 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaSubroutineType*  SgAdaSubroutineType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaSubroutineType* poolStart = reinterpret_cast<SgAdaSubroutineType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaSubroutineType::getNodeIdStringInternal(SgAdaSubroutineType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaSubroutineType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaSubroutineType::pool_size * sizeof(SgAdaSubroutineType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaSubroutineType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaSubroutineType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5535 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialBitType*  SgJovialBitType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialBitType* poolStart = reinterpret_cast<SgJovialBitType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialBitType::getNodeIdStringInternal(SgJovialBitType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialBitType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialBitType::pool_size * sizeof(SgJovialBitType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialBitType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialBitType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5572 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRangeType*  SgRangeType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRangeType* poolStart = reinterpret_cast<SgRangeType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRangeType::getNodeIdStringInternal(SgRangeType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRangeType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRangeType::pool_size * sizeof(SgRangeType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRangeType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRangeType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5609 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLocatedNode*  SgLocatedNode::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLocatedNode* poolStart = reinterpret_cast<SgLocatedNode*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLocatedNode::getNodeIdStringInternal(SgLocatedNode* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLocatedNode* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLocatedNode::pool_size * sizeof(SgLocatedNode))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLocatedNode*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLocatedNode::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5646 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgToken*  SgToken::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgToken* poolStart = reinterpret_cast<SgToken*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgToken::getNodeIdStringInternal(SgToken* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgToken* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgToken::pool_size * sizeof(SgToken))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgToken*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgToken::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5683 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLocatedNodeSupport*  SgLocatedNodeSupport::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLocatedNodeSupport* poolStart = reinterpret_cast<SgLocatedNodeSupport*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLocatedNodeSupport::getNodeIdStringInternal(SgLocatedNodeSupport* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLocatedNodeSupport* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLocatedNodeSupport::pool_size * sizeof(SgLocatedNodeSupport))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLocatedNodeSupport*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLocatedNodeSupport::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5720 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCommonBlockObject*  SgCommonBlockObject::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCommonBlockObject* poolStart = reinterpret_cast<SgCommonBlockObject*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCommonBlockObject::getNodeIdStringInternal(SgCommonBlockObject* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCommonBlockObject* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCommonBlockObject::pool_size * sizeof(SgCommonBlockObject))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCommonBlockObject*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCommonBlockObject::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5757 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgInitializedName*  SgInitializedName::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgInitializedName* poolStart = reinterpret_cast<SgInitializedName*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgInitializedName::getNodeIdStringInternal(SgInitializedName* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgInitializedName* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgInitializedName::pool_size * sizeof(SgInitializedName))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgInitializedName*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgInitializedName::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5794 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgInterfaceBody*  SgInterfaceBody::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgInterfaceBody* poolStart = reinterpret_cast<SgInterfaceBody*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgInterfaceBody::getNodeIdStringInternal(SgInterfaceBody* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgInterfaceBody* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgInterfaceBody::pool_size * sizeof(SgInterfaceBody))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgInterfaceBody*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgInterfaceBody::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5831 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgHeaderFileBody*  SgHeaderFileBody::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgHeaderFileBody* poolStart = reinterpret_cast<SgHeaderFileBody*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgHeaderFileBody::getNodeIdStringInternal(SgHeaderFileBody* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgHeaderFileBody* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgHeaderFileBody::pool_size * sizeof(SgHeaderFileBody))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgHeaderFileBody*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgHeaderFileBody::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5868 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRenamePair*  SgRenamePair::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRenamePair* poolStart = reinterpret_cast<SgRenamePair*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRenamePair::getNodeIdStringInternal(SgRenamePair* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRenamePair* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRenamePair::pool_size * sizeof(SgRenamePair))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRenamePair*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRenamePair::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5905 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaMemberValuePair*  SgJavaMemberValuePair::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaMemberValuePair* poolStart = reinterpret_cast<SgJavaMemberValuePair*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaMemberValuePair::getNodeIdStringInternal(SgJavaMemberValuePair* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaMemberValuePair* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaMemberValuePair::pool_size * sizeof(SgJavaMemberValuePair))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaMemberValuePair*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaMemberValuePair::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5942 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpClause*  SgOmpClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpClause* poolStart = reinterpret_cast<SgOmpClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpClause::getNodeIdStringInternal(SgOmpClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpClause::pool_size * sizeof(SgOmpClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 5979 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpNowaitClause*  SgOmpNowaitClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpNowaitClause* poolStart = reinterpret_cast<SgOmpNowaitClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpNowaitClause::getNodeIdStringInternal(SgOmpNowaitClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpNowaitClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpNowaitClause::pool_size * sizeof(SgOmpNowaitClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpNowaitClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpNowaitClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6016 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpBeginClause*  SgOmpBeginClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpBeginClause* poolStart = reinterpret_cast<SgOmpBeginClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpBeginClause::getNodeIdStringInternal(SgOmpBeginClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpBeginClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpBeginClause::pool_size * sizeof(SgOmpBeginClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpBeginClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpBeginClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6053 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpEndClause*  SgOmpEndClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpEndClause* poolStart = reinterpret_cast<SgOmpEndClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpEndClause::getNodeIdStringInternal(SgOmpEndClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpEndClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpEndClause::pool_size * sizeof(SgOmpEndClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpEndClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpEndClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6090 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpUntiedClause*  SgOmpUntiedClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpUntiedClause* poolStart = reinterpret_cast<SgOmpUntiedClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpUntiedClause::getNodeIdStringInternal(SgOmpUntiedClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpUntiedClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpUntiedClause::pool_size * sizeof(SgOmpUntiedClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpUntiedClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpUntiedClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6127 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpDefaultClause*  SgOmpDefaultClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpDefaultClause* poolStart = reinterpret_cast<SgOmpDefaultClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpDefaultClause::getNodeIdStringInternal(SgOmpDefaultClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpDefaultClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpDefaultClause::pool_size * sizeof(SgOmpDefaultClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpDefaultClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpDefaultClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6164 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpAtomicClause*  SgOmpAtomicClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpAtomicClause* poolStart = reinterpret_cast<SgOmpAtomicClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpAtomicClause::getNodeIdStringInternal(SgOmpAtomicClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpAtomicClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpAtomicClause::pool_size * sizeof(SgOmpAtomicClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpAtomicClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpAtomicClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6201 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpProcBindClause*  SgOmpProcBindClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpProcBindClause* poolStart = reinterpret_cast<SgOmpProcBindClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpProcBindClause::getNodeIdStringInternal(SgOmpProcBindClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpProcBindClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpProcBindClause::pool_size * sizeof(SgOmpProcBindClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpProcBindClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpProcBindClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6238 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpExpressionClause*  SgOmpExpressionClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpExpressionClause* poolStart = reinterpret_cast<SgOmpExpressionClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpExpressionClause::getNodeIdStringInternal(SgOmpExpressionClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpExpressionClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpExpressionClause::pool_size * sizeof(SgOmpExpressionClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpExpressionClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpExpressionClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6275 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpOrderedClause*  SgOmpOrderedClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpOrderedClause* poolStart = reinterpret_cast<SgOmpOrderedClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpOrderedClause::getNodeIdStringInternal(SgOmpOrderedClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpOrderedClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpOrderedClause::pool_size * sizeof(SgOmpOrderedClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpOrderedClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpOrderedClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6312 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpCollapseClause*  SgOmpCollapseClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpCollapseClause* poolStart = reinterpret_cast<SgOmpCollapseClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpCollapseClause::getNodeIdStringInternal(SgOmpCollapseClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpCollapseClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpCollapseClause::pool_size * sizeof(SgOmpCollapseClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpCollapseClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpCollapseClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6349 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpIfClause*  SgOmpIfClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpIfClause* poolStart = reinterpret_cast<SgOmpIfClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpIfClause::getNodeIdStringInternal(SgOmpIfClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpIfClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpIfClause::pool_size * sizeof(SgOmpIfClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpIfClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpIfClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6386 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpNumThreadsClause*  SgOmpNumThreadsClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpNumThreadsClause* poolStart = reinterpret_cast<SgOmpNumThreadsClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpNumThreadsClause::getNodeIdStringInternal(SgOmpNumThreadsClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpNumThreadsClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpNumThreadsClause::pool_size * sizeof(SgOmpNumThreadsClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpNumThreadsClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpNumThreadsClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6423 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpDeviceClause*  SgOmpDeviceClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpDeviceClause* poolStart = reinterpret_cast<SgOmpDeviceClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpDeviceClause::getNodeIdStringInternal(SgOmpDeviceClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpDeviceClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpDeviceClause::pool_size * sizeof(SgOmpDeviceClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpDeviceClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpDeviceClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6460 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpSafelenClause*  SgOmpSafelenClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpSafelenClause* poolStart = reinterpret_cast<SgOmpSafelenClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpSafelenClause::getNodeIdStringInternal(SgOmpSafelenClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpSafelenClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpSafelenClause::pool_size * sizeof(SgOmpSafelenClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpSafelenClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpSafelenClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6497 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpSimdlenClause*  SgOmpSimdlenClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpSimdlenClause* poolStart = reinterpret_cast<SgOmpSimdlenClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpSimdlenClause::getNodeIdStringInternal(SgOmpSimdlenClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpSimdlenClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpSimdlenClause::pool_size * sizeof(SgOmpSimdlenClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpSimdlenClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpSimdlenClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6534 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpFinalClause*  SgOmpFinalClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpFinalClause* poolStart = reinterpret_cast<SgOmpFinalClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpFinalClause::getNodeIdStringInternal(SgOmpFinalClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpFinalClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpFinalClause::pool_size * sizeof(SgOmpFinalClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpFinalClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpFinalClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6571 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpPriorityClause*  SgOmpPriorityClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpPriorityClause* poolStart = reinterpret_cast<SgOmpPriorityClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpPriorityClause::getNodeIdStringInternal(SgOmpPriorityClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpPriorityClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpPriorityClause::pool_size * sizeof(SgOmpPriorityClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpPriorityClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpPriorityClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6608 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpInbranchClause*  SgOmpInbranchClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpInbranchClause* poolStart = reinterpret_cast<SgOmpInbranchClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpInbranchClause::getNodeIdStringInternal(SgOmpInbranchClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpInbranchClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpInbranchClause::pool_size * sizeof(SgOmpInbranchClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpInbranchClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpInbranchClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6645 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpNotinbranchClause*  SgOmpNotinbranchClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpNotinbranchClause* poolStart = reinterpret_cast<SgOmpNotinbranchClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpNotinbranchClause::getNodeIdStringInternal(SgOmpNotinbranchClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpNotinbranchClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpNotinbranchClause::pool_size * sizeof(SgOmpNotinbranchClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpNotinbranchClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpNotinbranchClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6682 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpVariablesClause*  SgOmpVariablesClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpVariablesClause* poolStart = reinterpret_cast<SgOmpVariablesClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpVariablesClause::getNodeIdStringInternal(SgOmpVariablesClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpVariablesClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpVariablesClause::pool_size * sizeof(SgOmpVariablesClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpVariablesClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpVariablesClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6719 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpCopyprivateClause*  SgOmpCopyprivateClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpCopyprivateClause* poolStart = reinterpret_cast<SgOmpCopyprivateClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpCopyprivateClause::getNodeIdStringInternal(SgOmpCopyprivateClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpCopyprivateClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpCopyprivateClause::pool_size * sizeof(SgOmpCopyprivateClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpCopyprivateClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpCopyprivateClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6756 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpPrivateClause*  SgOmpPrivateClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpPrivateClause* poolStart = reinterpret_cast<SgOmpPrivateClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpPrivateClause::getNodeIdStringInternal(SgOmpPrivateClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpPrivateClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpPrivateClause::pool_size * sizeof(SgOmpPrivateClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpPrivateClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpPrivateClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6793 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpFirstprivateClause*  SgOmpFirstprivateClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpFirstprivateClause* poolStart = reinterpret_cast<SgOmpFirstprivateClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpFirstprivateClause::getNodeIdStringInternal(SgOmpFirstprivateClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpFirstprivateClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpFirstprivateClause::pool_size * sizeof(SgOmpFirstprivateClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpFirstprivateClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpFirstprivateClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6830 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpSharedClause*  SgOmpSharedClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpSharedClause* poolStart = reinterpret_cast<SgOmpSharedClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpSharedClause::getNodeIdStringInternal(SgOmpSharedClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpSharedClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpSharedClause::pool_size * sizeof(SgOmpSharedClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpSharedClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpSharedClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6867 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpCopyinClause*  SgOmpCopyinClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpCopyinClause* poolStart = reinterpret_cast<SgOmpCopyinClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpCopyinClause::getNodeIdStringInternal(SgOmpCopyinClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpCopyinClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpCopyinClause::pool_size * sizeof(SgOmpCopyinClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpCopyinClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpCopyinClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6904 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpLastprivateClause*  SgOmpLastprivateClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpLastprivateClause* poolStart = reinterpret_cast<SgOmpLastprivateClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpLastprivateClause::getNodeIdStringInternal(SgOmpLastprivateClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpLastprivateClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpLastprivateClause::pool_size * sizeof(SgOmpLastprivateClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpLastprivateClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpLastprivateClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6941 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpReductionClause*  SgOmpReductionClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpReductionClause* poolStart = reinterpret_cast<SgOmpReductionClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpReductionClause::getNodeIdStringInternal(SgOmpReductionClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpReductionClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpReductionClause::pool_size * sizeof(SgOmpReductionClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpReductionClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpReductionClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 6978 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpMapClause*  SgOmpMapClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpMapClause* poolStart = reinterpret_cast<SgOmpMapClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpMapClause::getNodeIdStringInternal(SgOmpMapClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpMapClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpMapClause::pool_size * sizeof(SgOmpMapClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpMapClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpMapClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7015 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpUniformClause*  SgOmpUniformClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpUniformClause* poolStart = reinterpret_cast<SgOmpUniformClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpUniformClause::getNodeIdStringInternal(SgOmpUniformClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpUniformClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpUniformClause::pool_size * sizeof(SgOmpUniformClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpUniformClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpUniformClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7052 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpAlignedClause*  SgOmpAlignedClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpAlignedClause* poolStart = reinterpret_cast<SgOmpAlignedClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpAlignedClause::getNodeIdStringInternal(SgOmpAlignedClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpAlignedClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpAlignedClause::pool_size * sizeof(SgOmpAlignedClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpAlignedClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpAlignedClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7089 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpLinearClause*  SgOmpLinearClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpLinearClause* poolStart = reinterpret_cast<SgOmpLinearClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpLinearClause::getNodeIdStringInternal(SgOmpLinearClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpLinearClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpLinearClause::pool_size * sizeof(SgOmpLinearClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpLinearClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpLinearClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7126 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpDependClause*  SgOmpDependClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpDependClause* poolStart = reinterpret_cast<SgOmpDependClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpDependClause::getNodeIdStringInternal(SgOmpDependClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpDependClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpDependClause::pool_size * sizeof(SgOmpDependClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpDependClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpDependClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7163 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpScheduleClause*  SgOmpScheduleClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpScheduleClause* poolStart = reinterpret_cast<SgOmpScheduleClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpScheduleClause::getNodeIdStringInternal(SgOmpScheduleClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpScheduleClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpScheduleClause::pool_size * sizeof(SgOmpScheduleClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpScheduleClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpScheduleClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7200 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpMergeableClause*  SgOmpMergeableClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpMergeableClause* poolStart = reinterpret_cast<SgOmpMergeableClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpMergeableClause::getNodeIdStringInternal(SgOmpMergeableClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpMergeableClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpMergeableClause::pool_size * sizeof(SgOmpMergeableClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpMergeableClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpMergeableClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7237 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLambdaCapture*  SgLambdaCapture::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLambdaCapture* poolStart = reinterpret_cast<SgLambdaCapture*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLambdaCapture::getNodeIdStringInternal(SgLambdaCapture* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLambdaCapture* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLambdaCapture::pool_size * sizeof(SgLambdaCapture))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLambdaCapture*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLambdaCapture::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7274 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLambdaCaptureList*  SgLambdaCaptureList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLambdaCaptureList* poolStart = reinterpret_cast<SgLambdaCaptureList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLambdaCaptureList::getNodeIdStringInternal(SgLambdaCaptureList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLambdaCaptureList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLambdaCaptureList::pool_size * sizeof(SgLambdaCaptureList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLambdaCaptureList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLambdaCaptureList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7311 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTypeConstraint*  SgAdaTypeConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTypeConstraint* poolStart = reinterpret_cast<SgAdaTypeConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTypeConstraint::getNodeIdStringInternal(SgAdaTypeConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTypeConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTypeConstraint::pool_size * sizeof(SgAdaTypeConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTypeConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTypeConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7348 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaRangeConstraint*  SgAdaRangeConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaRangeConstraint* poolStart = reinterpret_cast<SgAdaRangeConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaRangeConstraint::getNodeIdStringInternal(SgAdaRangeConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaRangeConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaRangeConstraint::pool_size * sizeof(SgAdaRangeConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaRangeConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaRangeConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7385 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaIndexConstraint*  SgAdaIndexConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaIndexConstraint* poolStart = reinterpret_cast<SgAdaIndexConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaIndexConstraint::getNodeIdStringInternal(SgAdaIndexConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaIndexConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaIndexConstraint::pool_size * sizeof(SgAdaIndexConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaIndexConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaIndexConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7422 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDigitsConstraint*  SgAdaDigitsConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDigitsConstraint* poolStart = reinterpret_cast<SgAdaDigitsConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDigitsConstraint::getNodeIdStringInternal(SgAdaDigitsConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDigitsConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDigitsConstraint::pool_size * sizeof(SgAdaDigitsConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDigitsConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDigitsConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7459 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDeltaConstraint*  SgAdaDeltaConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDeltaConstraint* poolStart = reinterpret_cast<SgAdaDeltaConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDeltaConstraint::getNodeIdStringInternal(SgAdaDeltaConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDeltaConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDeltaConstraint::pool_size * sizeof(SgAdaDeltaConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDeltaConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDeltaConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7496 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDiscriminantConstraint*  SgAdaDiscriminantConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDiscriminantConstraint* poolStart = reinterpret_cast<SgAdaDiscriminantConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDiscriminantConstraint::getNodeIdStringInternal(SgAdaDiscriminantConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDiscriminantConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDiscriminantConstraint::pool_size * sizeof(SgAdaDiscriminantConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDiscriminantConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDiscriminantConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7533 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaNullConstraint*  SgAdaNullConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaNullConstraint* poolStart = reinterpret_cast<SgAdaNullConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaNullConstraint::getNodeIdStringInternal(SgAdaNullConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaNullConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaNullConstraint::pool_size * sizeof(SgAdaNullConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaNullConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaNullConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7570 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStatement*  SgStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStatement* poolStart = reinterpret_cast<SgStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStatement::getNodeIdStringInternal(SgStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStatement::pool_size * sizeof(SgStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7607 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgScopeStatement*  SgScopeStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgScopeStatement* poolStart = reinterpret_cast<SgScopeStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgScopeStatement::getNodeIdStringInternal(SgScopeStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgScopeStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgScopeStatement::pool_size * sizeof(SgScopeStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgScopeStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgScopeStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7644 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGlobal*  SgGlobal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGlobal* poolStart = reinterpret_cast<SgGlobal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGlobal::getNodeIdStringInternal(SgGlobal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGlobal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGlobal::pool_size * sizeof(SgGlobal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGlobal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGlobal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7681 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBasicBlock*  SgBasicBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBasicBlock* poolStart = reinterpret_cast<SgBasicBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBasicBlock::getNodeIdStringInternal(SgBasicBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBasicBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBasicBlock::pool_size * sizeof(SgBasicBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBasicBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBasicBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7718 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIfStmt*  SgIfStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIfStmt* poolStart = reinterpret_cast<SgIfStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIfStmt::getNodeIdStringInternal(SgIfStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIfStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIfStmt::pool_size * sizeof(SgIfStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIfStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIfStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7755 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgForStatement*  SgForStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgForStatement* poolStart = reinterpret_cast<SgForStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgForStatement::getNodeIdStringInternal(SgForStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgForStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgForStatement::pool_size * sizeof(SgForStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgForStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgForStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7792 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionDefinition*  SgFunctionDefinition::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionDefinition* poolStart = reinterpret_cast<SgFunctionDefinition*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionDefinition::getNodeIdStringInternal(SgFunctionDefinition* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionDefinition* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionDefinition::pool_size * sizeof(SgFunctionDefinition))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionDefinition*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionDefinition::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7829 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateFunctionDefinition*  SgTemplateFunctionDefinition::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateFunctionDefinition* poolStart = reinterpret_cast<SgTemplateFunctionDefinition*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateFunctionDefinition::getNodeIdStringInternal(SgTemplateFunctionDefinition* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateFunctionDefinition* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateFunctionDefinition::pool_size * sizeof(SgTemplateFunctionDefinition))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateFunctionDefinition*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateFunctionDefinition::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7866 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClassDefinition*  SgClassDefinition::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClassDefinition* poolStart = reinterpret_cast<SgClassDefinition*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClassDefinition::getNodeIdStringInternal(SgClassDefinition* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClassDefinition* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClassDefinition::pool_size * sizeof(SgClassDefinition))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClassDefinition*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClassDefinition::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7903 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateInstantiationDefn*  SgTemplateInstantiationDefn::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateInstantiationDefn* poolStart = reinterpret_cast<SgTemplateInstantiationDefn*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateInstantiationDefn::getNodeIdStringInternal(SgTemplateInstantiationDefn* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateInstantiationDefn* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateInstantiationDefn::pool_size * sizeof(SgTemplateInstantiationDefn))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateInstantiationDefn*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateInstantiationDefn::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7940 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateClassDefinition*  SgTemplateClassDefinition::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateClassDefinition* poolStart = reinterpret_cast<SgTemplateClassDefinition*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateClassDefinition::getNodeIdStringInternal(SgTemplateClassDefinition* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateClassDefinition* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateClassDefinition::pool_size * sizeof(SgTemplateClassDefinition))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateClassDefinition*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateClassDefinition::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 7977 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWhileStmt*  SgWhileStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWhileStmt* poolStart = reinterpret_cast<SgWhileStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWhileStmt::getNodeIdStringInternal(SgWhileStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWhileStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWhileStmt::pool_size * sizeof(SgWhileStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWhileStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWhileStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8014 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDoWhileStmt*  SgDoWhileStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDoWhileStmt* poolStart = reinterpret_cast<SgDoWhileStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDoWhileStmt::getNodeIdStringInternal(SgDoWhileStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDoWhileStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDoWhileStmt::pool_size * sizeof(SgDoWhileStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDoWhileStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDoWhileStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8051 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSwitchStatement*  SgSwitchStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSwitchStatement* poolStart = reinterpret_cast<SgSwitchStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSwitchStatement::getNodeIdStringInternal(SgSwitchStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSwitchStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSwitchStatement::pool_size * sizeof(SgSwitchStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSwitchStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSwitchStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8088 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCatchOptionStmt*  SgCatchOptionStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCatchOptionStmt* poolStart = reinterpret_cast<SgCatchOptionStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCatchOptionStmt::getNodeIdStringInternal(SgCatchOptionStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCatchOptionStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCatchOptionStmt::pool_size * sizeof(SgCatchOptionStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCatchOptionStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCatchOptionStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8125 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNamespaceDefinitionStatement*  SgNamespaceDefinitionStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNamespaceDefinitionStatement* poolStart = reinterpret_cast<SgNamespaceDefinitionStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNamespaceDefinitionStatement::getNodeIdStringInternal(SgNamespaceDefinitionStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNamespaceDefinitionStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNamespaceDefinitionStatement::pool_size * sizeof(SgNamespaceDefinitionStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNamespaceDefinitionStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNamespaceDefinitionStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8162 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBlockDataStatement*  SgBlockDataStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBlockDataStatement* poolStart = reinterpret_cast<SgBlockDataStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBlockDataStatement::getNodeIdStringInternal(SgBlockDataStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBlockDataStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBlockDataStatement::pool_size * sizeof(SgBlockDataStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBlockDataStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBlockDataStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8199 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAssociateStatement*  SgAssociateStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAssociateStatement* poolStart = reinterpret_cast<SgAssociateStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAssociateStatement::getNodeIdStringInternal(SgAssociateStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAssociateStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAssociateStatement::pool_size * sizeof(SgAssociateStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAssociateStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAssociateStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8236 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFortranDo*  SgFortranDo::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFortranDo* poolStart = reinterpret_cast<SgFortranDo*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFortranDo::getNodeIdStringInternal(SgFortranDo* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFortranDo* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFortranDo::pool_size * sizeof(SgFortranDo))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFortranDo*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFortranDo::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8273 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFortranNonblockedDo*  SgFortranNonblockedDo::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFortranNonblockedDo* poolStart = reinterpret_cast<SgFortranNonblockedDo*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFortranNonblockedDo::getNodeIdStringInternal(SgFortranNonblockedDo* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFortranNonblockedDo* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFortranNonblockedDo::pool_size * sizeof(SgFortranNonblockedDo))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFortranNonblockedDo*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFortranNonblockedDo::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8310 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgForAllStatement*  SgForAllStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgForAllStatement* poolStart = reinterpret_cast<SgForAllStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgForAllStatement::getNodeIdStringInternal(SgForAllStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgForAllStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgForAllStatement::pool_size * sizeof(SgForAllStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgForAllStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgForAllStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8347 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcForAllStatement*  SgUpcForAllStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcForAllStatement* poolStart = reinterpret_cast<SgUpcForAllStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcForAllStatement::getNodeIdStringInternal(SgUpcForAllStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcForAllStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcForAllStatement::pool_size * sizeof(SgUpcForAllStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcForAllStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcForAllStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8384 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCAFWithTeamStatement*  SgCAFWithTeamStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCAFWithTeamStatement* poolStart = reinterpret_cast<SgCAFWithTeamStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCAFWithTeamStatement::getNodeIdStringInternal(SgCAFWithTeamStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCAFWithTeamStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCAFWithTeamStatement::pool_size * sizeof(SgCAFWithTeamStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCAFWithTeamStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCAFWithTeamStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8421 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaForEachStatement*  SgJavaForEachStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaForEachStatement* poolStart = reinterpret_cast<SgJavaForEachStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaForEachStatement::getNodeIdStringInternal(SgJavaForEachStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaForEachStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaForEachStatement::pool_size * sizeof(SgJavaForEachStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaForEachStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaForEachStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8458 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaLabelStatement*  SgJavaLabelStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaLabelStatement* poolStart = reinterpret_cast<SgJavaLabelStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaLabelStatement::getNodeIdStringInternal(SgJavaLabelStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaLabelStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaLabelStatement::pool_size * sizeof(SgJavaLabelStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaLabelStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaLabelStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8495 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMatlabForStatement*  SgMatlabForStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMatlabForStatement* poolStart = reinterpret_cast<SgMatlabForStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMatlabForStatement::getNodeIdStringInternal(SgMatlabForStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMatlabForStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMatlabForStatement::pool_size * sizeof(SgMatlabForStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMatlabForStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMatlabForStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8532 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionParameterScope*  SgFunctionParameterScope::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionParameterScope* poolStart = reinterpret_cast<SgFunctionParameterScope*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionParameterScope::getNodeIdStringInternal(SgFunctionParameterScope* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionParameterScope* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionParameterScope::pool_size * sizeof(SgFunctionParameterScope))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionParameterScope*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionParameterScope::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8569 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDeclarationScope*  SgDeclarationScope::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDeclarationScope* poolStart = reinterpret_cast<SgDeclarationScope*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDeclarationScope::getNodeIdStringInternal(SgDeclarationScope* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDeclarationScope* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDeclarationScope::pool_size * sizeof(SgDeclarationScope))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDeclarationScope*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDeclarationScope::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8606 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRangeBasedForStatement*  SgRangeBasedForStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRangeBasedForStatement* poolStart = reinterpret_cast<SgRangeBasedForStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRangeBasedForStatement::getNodeIdStringInternal(SgRangeBasedForStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRangeBasedForStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRangeBasedForStatement::pool_size * sizeof(SgRangeBasedForStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRangeBasedForStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRangeBasedForStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8643 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialForThenStatement*  SgJovialForThenStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialForThenStatement* poolStart = reinterpret_cast<SgJovialForThenStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialForThenStatement::getNodeIdStringInternal(SgJovialForThenStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialForThenStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialForThenStatement::pool_size * sizeof(SgJovialForThenStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialForThenStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialForThenStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8680 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaAcceptStmt*  SgAdaAcceptStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaAcceptStmt* poolStart = reinterpret_cast<SgAdaAcceptStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaAcceptStmt::getNodeIdStringInternal(SgAdaAcceptStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaAcceptStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaAcceptStmt::pool_size * sizeof(SgAdaAcceptStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaAcceptStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaAcceptStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8717 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaPackageSpec*  SgAdaPackageSpec::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaPackageSpec* poolStart = reinterpret_cast<SgAdaPackageSpec*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaPackageSpec::getNodeIdStringInternal(SgAdaPackageSpec* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaPackageSpec* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaPackageSpec::pool_size * sizeof(SgAdaPackageSpec))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaPackageSpec*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaPackageSpec::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8754 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaPackageBody*  SgAdaPackageBody::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaPackageBody* poolStart = reinterpret_cast<SgAdaPackageBody*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaPackageBody::getNodeIdStringInternal(SgAdaPackageBody* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaPackageBody* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaPackageBody::pool_size * sizeof(SgAdaPackageBody))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaPackageBody*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaPackageBody::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8791 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskSpec*  SgAdaTaskSpec::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskSpec* poolStart = reinterpret_cast<SgAdaTaskSpec*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskSpec::getNodeIdStringInternal(SgAdaTaskSpec* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskSpec* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskSpec::pool_size * sizeof(SgAdaTaskSpec))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskSpec*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskSpec::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8828 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskBody*  SgAdaTaskBody::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskBody* poolStart = reinterpret_cast<SgAdaTaskBody*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskBody::getNodeIdStringInternal(SgAdaTaskBody* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskBody* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskBody::pool_size * sizeof(SgAdaTaskBody))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskBody*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskBody::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8865 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedBody*  SgAdaProtectedBody::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedBody* poolStart = reinterpret_cast<SgAdaProtectedBody*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedBody::getNodeIdStringInternal(SgAdaProtectedBody* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedBody* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedBody::pool_size * sizeof(SgAdaProtectedBody))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedBody*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedBody::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8902 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedSpec*  SgAdaProtectedSpec::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedSpec* poolStart = reinterpret_cast<SgAdaProtectedSpec*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedSpec::getNodeIdStringInternal(SgAdaProtectedSpec* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedSpec* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedSpec::pool_size * sizeof(SgAdaProtectedSpec))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedSpec*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedSpec::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8939 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaGenericDefn*  SgAdaGenericDefn::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaGenericDefn* poolStart = reinterpret_cast<SgAdaGenericDefn*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaGenericDefn::getNodeIdStringInternal(SgAdaGenericDefn* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaGenericDefn* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaGenericDefn::pool_size * sizeof(SgAdaGenericDefn))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaGenericDefn*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaGenericDefn::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 8976 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionTypeTable*  SgFunctionTypeTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionTypeTable* poolStart = reinterpret_cast<SgFunctionTypeTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionTypeTable::getNodeIdStringInternal(SgFunctionTypeTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionTypeTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionTypeTable::pool_size * sizeof(SgFunctionTypeTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionTypeTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionTypeTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9013 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDeclarationStatement*  SgDeclarationStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDeclarationStatement* poolStart = reinterpret_cast<SgDeclarationStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDeclarationStatement::getNodeIdStringInternal(SgDeclarationStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDeclarationStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDeclarationStatement::pool_size * sizeof(SgDeclarationStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDeclarationStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDeclarationStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9050 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionParameterList*  SgFunctionParameterList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionParameterList* poolStart = reinterpret_cast<SgFunctionParameterList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionParameterList::getNodeIdStringInternal(SgFunctionParameterList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionParameterList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionParameterList::pool_size * sizeof(SgFunctionParameterList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionParameterList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionParameterList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9087 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVariableDeclaration*  SgVariableDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVariableDeclaration* poolStart = reinterpret_cast<SgVariableDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVariableDeclaration::getNodeIdStringInternal(SgVariableDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVariableDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVariableDeclaration::pool_size * sizeof(SgVariableDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVariableDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVariableDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9124 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateVariableDeclaration*  SgTemplateVariableDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateVariableDeclaration* poolStart = reinterpret_cast<SgTemplateVariableDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateVariableDeclaration::getNodeIdStringInternal(SgTemplateVariableDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateVariableDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateVariableDeclaration::pool_size * sizeof(SgTemplateVariableDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateVariableDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateVariableDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9161 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateVariableInstantiation*  SgTemplateVariableInstantiation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateVariableInstantiation* poolStart = reinterpret_cast<SgTemplateVariableInstantiation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateVariableInstantiation::getNodeIdStringInternal(SgTemplateVariableInstantiation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateVariableInstantiation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateVariableInstantiation::pool_size * sizeof(SgTemplateVariableInstantiation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateVariableInstantiation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateVariableInstantiation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9198 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVariableDefinition*  SgVariableDefinition::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVariableDefinition* poolStart = reinterpret_cast<SgVariableDefinition*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVariableDefinition::getNodeIdStringInternal(SgVariableDefinition* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVariableDefinition* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVariableDefinition::pool_size * sizeof(SgVariableDefinition))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVariableDefinition*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVariableDefinition::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9235 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClinkageDeclarationStatement*  SgClinkageDeclarationStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClinkageDeclarationStatement* poolStart = reinterpret_cast<SgClinkageDeclarationStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClinkageDeclarationStatement::getNodeIdStringInternal(SgClinkageDeclarationStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClinkageDeclarationStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClinkageDeclarationStatement::pool_size * sizeof(SgClinkageDeclarationStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClinkageDeclarationStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClinkageDeclarationStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9272 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClinkageStartStatement*  SgClinkageStartStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClinkageStartStatement* poolStart = reinterpret_cast<SgClinkageStartStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClinkageStartStatement::getNodeIdStringInternal(SgClinkageStartStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClinkageStartStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClinkageStartStatement::pool_size * sizeof(SgClinkageStartStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClinkageStartStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClinkageStartStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9309 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClinkageEndStatement*  SgClinkageEndStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClinkageEndStatement* poolStart = reinterpret_cast<SgClinkageEndStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClinkageEndStatement::getNodeIdStringInternal(SgClinkageEndStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClinkageEndStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClinkageEndStatement::pool_size * sizeof(SgClinkageEndStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClinkageEndStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClinkageEndStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9346 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEnumDeclaration*  SgEnumDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEnumDeclaration* poolStart = reinterpret_cast<SgEnumDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEnumDeclaration::getNodeIdStringInternal(SgEnumDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEnumDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEnumDeclaration::pool_size * sizeof(SgEnumDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEnumDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEnumDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9383 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmStmt*  SgAsmStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmStmt* poolStart = reinterpret_cast<SgAsmStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmStmt::getNodeIdStringInternal(SgAsmStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmStmt::pool_size * sizeof(SgAsmStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9420 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAttributeSpecificationStatement*  SgAttributeSpecificationStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAttributeSpecificationStatement* poolStart = reinterpret_cast<SgAttributeSpecificationStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAttributeSpecificationStatement::getNodeIdStringInternal(SgAttributeSpecificationStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAttributeSpecificationStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAttributeSpecificationStatement::pool_size * sizeof(SgAttributeSpecificationStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAttributeSpecificationStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAttributeSpecificationStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9457 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFormatStatement*  SgFormatStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFormatStatement* poolStart = reinterpret_cast<SgFormatStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFormatStatement::getNodeIdStringInternal(SgFormatStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFormatStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFormatStatement::pool_size * sizeof(SgFormatStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFormatStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFormatStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9494 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateDeclaration*  SgTemplateDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateDeclaration* poolStart = reinterpret_cast<SgTemplateDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateDeclaration::getNodeIdStringInternal(SgTemplateDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateDeclaration::pool_size * sizeof(SgTemplateDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9531 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateInstantiationDirectiveStatement*  SgTemplateInstantiationDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateInstantiationDirectiveStatement* poolStart = reinterpret_cast<SgTemplateInstantiationDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateInstantiationDirectiveStatement::getNodeIdStringInternal(SgTemplateInstantiationDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateInstantiationDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateInstantiationDirectiveStatement::pool_size * sizeof(SgTemplateInstantiationDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateInstantiationDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateInstantiationDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9568 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUseStatement*  SgUseStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUseStatement* poolStart = reinterpret_cast<SgUseStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUseStatement::getNodeIdStringInternal(SgUseStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUseStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUseStatement::pool_size * sizeof(SgUseStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUseStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUseStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9605 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgParameterStatement*  SgParameterStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgParameterStatement* poolStart = reinterpret_cast<SgParameterStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgParameterStatement::getNodeIdStringInternal(SgParameterStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgParameterStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgParameterStatement::pool_size * sizeof(SgParameterStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgParameterStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgParameterStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9642 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNamespaceDeclarationStatement*  SgNamespaceDeclarationStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNamespaceDeclarationStatement* poolStart = reinterpret_cast<SgNamespaceDeclarationStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNamespaceDeclarationStatement::getNodeIdStringInternal(SgNamespaceDeclarationStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNamespaceDeclarationStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNamespaceDeclarationStatement::pool_size * sizeof(SgNamespaceDeclarationStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNamespaceDeclarationStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNamespaceDeclarationStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9679 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEquivalenceStatement*  SgEquivalenceStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEquivalenceStatement* poolStart = reinterpret_cast<SgEquivalenceStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEquivalenceStatement::getNodeIdStringInternal(SgEquivalenceStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEquivalenceStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEquivalenceStatement::pool_size * sizeof(SgEquivalenceStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEquivalenceStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEquivalenceStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9716 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgInterfaceStatement*  SgInterfaceStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgInterfaceStatement* poolStart = reinterpret_cast<SgInterfaceStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgInterfaceStatement::getNodeIdStringInternal(SgInterfaceStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgInterfaceStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgInterfaceStatement::pool_size * sizeof(SgInterfaceStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgInterfaceStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgInterfaceStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9753 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNamespaceAliasDeclarationStatement*  SgNamespaceAliasDeclarationStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNamespaceAliasDeclarationStatement* poolStart = reinterpret_cast<SgNamespaceAliasDeclarationStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNamespaceAliasDeclarationStatement::getNodeIdStringInternal(SgNamespaceAliasDeclarationStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNamespaceAliasDeclarationStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNamespaceAliasDeclarationStatement::pool_size * sizeof(SgNamespaceAliasDeclarationStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNamespaceAliasDeclarationStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNamespaceAliasDeclarationStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9790 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCommonBlock*  SgCommonBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCommonBlock* poolStart = reinterpret_cast<SgCommonBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCommonBlock::getNodeIdStringInternal(SgCommonBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCommonBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCommonBlock::pool_size * sizeof(SgCommonBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCommonBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCommonBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9827 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypedefDeclaration*  SgTypedefDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypedefDeclaration* poolStart = reinterpret_cast<SgTypedefDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypedefDeclaration::getNodeIdStringInternal(SgTypedefDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypedefDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypedefDeclaration::pool_size * sizeof(SgTypedefDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypedefDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypedefDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9864 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateTypedefDeclaration*  SgTemplateTypedefDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateTypedefDeclaration* poolStart = reinterpret_cast<SgTemplateTypedefDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateTypedefDeclaration::getNodeIdStringInternal(SgTemplateTypedefDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateTypedefDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateTypedefDeclaration::pool_size * sizeof(SgTemplateTypedefDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateTypedefDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateTypedefDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9901 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateInstantiationTypedefDeclaration*  SgTemplateInstantiationTypedefDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateInstantiationTypedefDeclaration* poolStart = reinterpret_cast<SgTemplateInstantiationTypedefDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateInstantiationTypedefDeclaration::getNodeIdStringInternal(SgTemplateInstantiationTypedefDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateInstantiationTypedefDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateInstantiationTypedefDeclaration::pool_size * sizeof(SgTemplateInstantiationTypedefDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateInstantiationTypedefDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateInstantiationTypedefDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9938 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStatementFunctionStatement*  SgStatementFunctionStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStatementFunctionStatement* poolStart = reinterpret_cast<SgStatementFunctionStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStatementFunctionStatement::getNodeIdStringInternal(SgStatementFunctionStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStatementFunctionStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStatementFunctionStatement::pool_size * sizeof(SgStatementFunctionStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStatementFunctionStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStatementFunctionStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 9975 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCtorInitializerList*  SgCtorInitializerList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCtorInitializerList* poolStart = reinterpret_cast<SgCtorInitializerList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCtorInitializerList::getNodeIdStringInternal(SgCtorInitializerList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCtorInitializerList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCtorInitializerList::pool_size * sizeof(SgCtorInitializerList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCtorInitializerList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCtorInitializerList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10012 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPragmaDeclaration*  SgPragmaDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPragmaDeclaration* poolStart = reinterpret_cast<SgPragmaDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPragmaDeclaration::getNodeIdStringInternal(SgPragmaDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPragmaDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPragmaDeclaration::pool_size * sizeof(SgPragmaDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPragmaDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPragmaDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10049 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUsingDirectiveStatement*  SgUsingDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUsingDirectiveStatement* poolStart = reinterpret_cast<SgUsingDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUsingDirectiveStatement::getNodeIdStringInternal(SgUsingDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUsingDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUsingDirectiveStatement::pool_size * sizeof(SgUsingDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUsingDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUsingDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10086 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClassDeclaration*  SgClassDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClassDeclaration* poolStart = reinterpret_cast<SgClassDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClassDeclaration::getNodeIdStringInternal(SgClassDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClassDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClassDeclaration::pool_size * sizeof(SgClassDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClassDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClassDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10123 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateClassDeclaration*  SgTemplateClassDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateClassDeclaration* poolStart = reinterpret_cast<SgTemplateClassDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateClassDeclaration::getNodeIdStringInternal(SgTemplateClassDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateClassDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateClassDeclaration::pool_size * sizeof(SgTemplateClassDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateClassDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateClassDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10160 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateInstantiationDecl*  SgTemplateInstantiationDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateInstantiationDecl* poolStart = reinterpret_cast<SgTemplateInstantiationDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateInstantiationDecl::getNodeIdStringInternal(SgTemplateInstantiationDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateInstantiationDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateInstantiationDecl::pool_size * sizeof(SgTemplateInstantiationDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateInstantiationDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateInstantiationDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10197 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDerivedTypeStatement*  SgDerivedTypeStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDerivedTypeStatement* poolStart = reinterpret_cast<SgDerivedTypeStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDerivedTypeStatement::getNodeIdStringInternal(SgDerivedTypeStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDerivedTypeStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDerivedTypeStatement::pool_size * sizeof(SgDerivedTypeStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDerivedTypeStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDerivedTypeStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10234 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgModuleStatement*  SgModuleStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgModuleStatement* poolStart = reinterpret_cast<SgModuleStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgModuleStatement::getNodeIdStringInternal(SgModuleStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgModuleStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgModuleStatement::pool_size * sizeof(SgModuleStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgModuleStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgModuleStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10271 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaPackageDeclaration*  SgJavaPackageDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaPackageDeclaration* poolStart = reinterpret_cast<SgJavaPackageDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaPackageDeclaration::getNodeIdStringInternal(SgJavaPackageDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaPackageDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaPackageDeclaration::pool_size * sizeof(SgJavaPackageDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaPackageDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaPackageDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10308 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialTableStatement*  SgJovialTableStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialTableStatement* poolStart = reinterpret_cast<SgJovialTableStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialTableStatement::getNodeIdStringInternal(SgJovialTableStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialTableStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialTableStatement::pool_size * sizeof(SgJovialTableStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialTableStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialTableStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10345 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgImplicitStatement*  SgImplicitStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgImplicitStatement* poolStart = reinterpret_cast<SgImplicitStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgImplicitStatement::getNodeIdStringInternal(SgImplicitStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgImplicitStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgImplicitStatement::pool_size * sizeof(SgImplicitStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgImplicitStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgImplicitStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10382 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUsingDeclarationStatement*  SgUsingDeclarationStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUsingDeclarationStatement* poolStart = reinterpret_cast<SgUsingDeclarationStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUsingDeclarationStatement::getNodeIdStringInternal(SgUsingDeclarationStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUsingDeclarationStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUsingDeclarationStatement::pool_size * sizeof(SgUsingDeclarationStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUsingDeclarationStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUsingDeclarationStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10419 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNamelistStatement*  SgNamelistStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNamelistStatement* poolStart = reinterpret_cast<SgNamelistStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNamelistStatement::getNodeIdStringInternal(SgNamelistStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNamelistStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNamelistStatement::pool_size * sizeof(SgNamelistStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNamelistStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNamelistStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10456 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgImportStatement*  SgImportStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgImportStatement* poolStart = reinterpret_cast<SgImportStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgImportStatement::getNodeIdStringInternal(SgImportStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgImportStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgImportStatement::pool_size * sizeof(SgImportStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgImportStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgImportStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10493 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionDeclaration*  SgFunctionDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionDeclaration* poolStart = reinterpret_cast<SgFunctionDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionDeclaration::getNodeIdStringInternal(SgFunctionDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionDeclaration::pool_size * sizeof(SgFunctionDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10530 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateFunctionDeclaration*  SgTemplateFunctionDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateFunctionDeclaration* poolStart = reinterpret_cast<SgTemplateFunctionDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateFunctionDeclaration::getNodeIdStringInternal(SgTemplateFunctionDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateFunctionDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateFunctionDeclaration::pool_size * sizeof(SgTemplateFunctionDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateFunctionDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateFunctionDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10567 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMemberFunctionDeclaration*  SgMemberFunctionDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMemberFunctionDeclaration* poolStart = reinterpret_cast<SgMemberFunctionDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMemberFunctionDeclaration::getNodeIdStringInternal(SgMemberFunctionDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMemberFunctionDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMemberFunctionDeclaration::pool_size * sizeof(SgMemberFunctionDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMemberFunctionDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMemberFunctionDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10604 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateMemberFunctionDeclaration*  SgTemplateMemberFunctionDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateMemberFunctionDeclaration* poolStart = reinterpret_cast<SgTemplateMemberFunctionDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateMemberFunctionDeclaration::getNodeIdStringInternal(SgTemplateMemberFunctionDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateMemberFunctionDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateMemberFunctionDeclaration::pool_size * sizeof(SgTemplateMemberFunctionDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateMemberFunctionDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateMemberFunctionDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10641 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateInstantiationMemberFunctionDecl*  SgTemplateInstantiationMemberFunctionDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateInstantiationMemberFunctionDecl* poolStart = reinterpret_cast<SgTemplateInstantiationMemberFunctionDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateInstantiationMemberFunctionDecl::getNodeIdStringInternal(SgTemplateInstantiationMemberFunctionDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateInstantiationMemberFunctionDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateInstantiationMemberFunctionDecl::pool_size * sizeof(SgTemplateInstantiationMemberFunctionDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateInstantiationMemberFunctionDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateInstantiationMemberFunctionDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10678 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateInstantiationFunctionDecl*  SgTemplateInstantiationFunctionDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateInstantiationFunctionDecl* poolStart = reinterpret_cast<SgTemplateInstantiationFunctionDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateInstantiationFunctionDecl::getNodeIdStringInternal(SgTemplateInstantiationFunctionDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateInstantiationFunctionDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateInstantiationFunctionDecl::pool_size * sizeof(SgTemplateInstantiationFunctionDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateInstantiationFunctionDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateInstantiationFunctionDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10715 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgProgramHeaderStatement*  SgProgramHeaderStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgProgramHeaderStatement* poolStart = reinterpret_cast<SgProgramHeaderStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgProgramHeaderStatement::getNodeIdStringInternal(SgProgramHeaderStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgProgramHeaderStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgProgramHeaderStatement::pool_size * sizeof(SgProgramHeaderStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgProgramHeaderStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgProgramHeaderStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10752 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgProcedureHeaderStatement*  SgProcedureHeaderStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgProcedureHeaderStatement* poolStart = reinterpret_cast<SgProcedureHeaderStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgProcedureHeaderStatement::getNodeIdStringInternal(SgProcedureHeaderStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgProcedureHeaderStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgProcedureHeaderStatement::pool_size * sizeof(SgProcedureHeaderStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgProcedureHeaderStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgProcedureHeaderStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10789 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEntryStatement*  SgEntryStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEntryStatement* poolStart = reinterpret_cast<SgEntryStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEntryStatement::getNodeIdStringInternal(SgEntryStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEntryStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEntryStatement::pool_size * sizeof(SgEntryStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEntryStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEntryStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10826 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaEntryDecl*  SgAdaEntryDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaEntryDecl* poolStart = reinterpret_cast<SgAdaEntryDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaEntryDecl::getNodeIdStringInternal(SgAdaEntryDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaEntryDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaEntryDecl::pool_size * sizeof(SgAdaEntryDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaEntryDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaEntryDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10863 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaFunctionRenamingDecl*  SgAdaFunctionRenamingDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaFunctionRenamingDecl* poolStart = reinterpret_cast<SgAdaFunctionRenamingDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaFunctionRenamingDecl::getNodeIdStringInternal(SgAdaFunctionRenamingDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaFunctionRenamingDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaFunctionRenamingDecl::pool_size * sizeof(SgAdaFunctionRenamingDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaFunctionRenamingDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaFunctionRenamingDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10900 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgContainsStatement*  SgContainsStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgContainsStatement* poolStart = reinterpret_cast<SgContainsStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgContainsStatement::getNodeIdStringInternal(SgContainsStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgContainsStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgContainsStatement::pool_size * sizeof(SgContainsStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgContainsStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgContainsStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10937 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgC_PreprocessorDirectiveStatement*  SgC_PreprocessorDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgC_PreprocessorDirectiveStatement* poolStart = reinterpret_cast<SgC_PreprocessorDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgC_PreprocessorDirectiveStatement::getNodeIdStringInternal(SgC_PreprocessorDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgC_PreprocessorDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgC_PreprocessorDirectiveStatement::pool_size * sizeof(SgC_PreprocessorDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgC_PreprocessorDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgC_PreprocessorDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 10974 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIncludeDirectiveStatement*  SgIncludeDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIncludeDirectiveStatement* poolStart = reinterpret_cast<SgIncludeDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIncludeDirectiveStatement::getNodeIdStringInternal(SgIncludeDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIncludeDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIncludeDirectiveStatement::pool_size * sizeof(SgIncludeDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIncludeDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIncludeDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11011 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDefineDirectiveStatement*  SgDefineDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDefineDirectiveStatement* poolStart = reinterpret_cast<SgDefineDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDefineDirectiveStatement::getNodeIdStringInternal(SgDefineDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDefineDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDefineDirectiveStatement::pool_size * sizeof(SgDefineDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDefineDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDefineDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11048 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUndefDirectiveStatement*  SgUndefDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUndefDirectiveStatement* poolStart = reinterpret_cast<SgUndefDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUndefDirectiveStatement::getNodeIdStringInternal(SgUndefDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUndefDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUndefDirectiveStatement::pool_size * sizeof(SgUndefDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUndefDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUndefDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11085 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIfdefDirectiveStatement*  SgIfdefDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIfdefDirectiveStatement* poolStart = reinterpret_cast<SgIfdefDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIfdefDirectiveStatement::getNodeIdStringInternal(SgIfdefDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIfdefDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIfdefDirectiveStatement::pool_size * sizeof(SgIfdefDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIfdefDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIfdefDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11122 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIfndefDirectiveStatement*  SgIfndefDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIfndefDirectiveStatement* poolStart = reinterpret_cast<SgIfndefDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIfndefDirectiveStatement::getNodeIdStringInternal(SgIfndefDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIfndefDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIfndefDirectiveStatement::pool_size * sizeof(SgIfndefDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIfndefDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIfndefDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11159 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIfDirectiveStatement*  SgIfDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIfDirectiveStatement* poolStart = reinterpret_cast<SgIfDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIfDirectiveStatement::getNodeIdStringInternal(SgIfDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIfDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIfDirectiveStatement::pool_size * sizeof(SgIfDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIfDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIfDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11196 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDeadIfDirectiveStatement*  SgDeadIfDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDeadIfDirectiveStatement* poolStart = reinterpret_cast<SgDeadIfDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDeadIfDirectiveStatement::getNodeIdStringInternal(SgDeadIfDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDeadIfDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDeadIfDirectiveStatement::pool_size * sizeof(SgDeadIfDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDeadIfDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDeadIfDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11233 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElseDirectiveStatement*  SgElseDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElseDirectiveStatement* poolStart = reinterpret_cast<SgElseDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElseDirectiveStatement::getNodeIdStringInternal(SgElseDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElseDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElseDirectiveStatement::pool_size * sizeof(SgElseDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElseDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElseDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11270 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElseifDirectiveStatement*  SgElseifDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElseifDirectiveStatement* poolStart = reinterpret_cast<SgElseifDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElseifDirectiveStatement::getNodeIdStringInternal(SgElseifDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElseifDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElseifDirectiveStatement::pool_size * sizeof(SgElseifDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElseifDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElseifDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11307 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEndifDirectiveStatement*  SgEndifDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEndifDirectiveStatement* poolStart = reinterpret_cast<SgEndifDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEndifDirectiveStatement::getNodeIdStringInternal(SgEndifDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEndifDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEndifDirectiveStatement::pool_size * sizeof(SgEndifDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEndifDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEndifDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11344 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLineDirectiveStatement*  SgLineDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLineDirectiveStatement* poolStart = reinterpret_cast<SgLineDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLineDirectiveStatement::getNodeIdStringInternal(SgLineDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLineDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLineDirectiveStatement::pool_size * sizeof(SgLineDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLineDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLineDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11381 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWarningDirectiveStatement*  SgWarningDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWarningDirectiveStatement* poolStart = reinterpret_cast<SgWarningDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWarningDirectiveStatement::getNodeIdStringInternal(SgWarningDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWarningDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWarningDirectiveStatement::pool_size * sizeof(SgWarningDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWarningDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWarningDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11418 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgErrorDirectiveStatement*  SgErrorDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgErrorDirectiveStatement* poolStart = reinterpret_cast<SgErrorDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgErrorDirectiveStatement::getNodeIdStringInternal(SgErrorDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgErrorDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgErrorDirectiveStatement::pool_size * sizeof(SgErrorDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgErrorDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgErrorDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11455 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEmptyDirectiveStatement*  SgEmptyDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEmptyDirectiveStatement* poolStart = reinterpret_cast<SgEmptyDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEmptyDirectiveStatement::getNodeIdStringInternal(SgEmptyDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEmptyDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEmptyDirectiveStatement::pool_size * sizeof(SgEmptyDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEmptyDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEmptyDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11492 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIncludeNextDirectiveStatement*  SgIncludeNextDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIncludeNextDirectiveStatement* poolStart = reinterpret_cast<SgIncludeNextDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIncludeNextDirectiveStatement::getNodeIdStringInternal(SgIncludeNextDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIncludeNextDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIncludeNextDirectiveStatement::pool_size * sizeof(SgIncludeNextDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIncludeNextDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIncludeNextDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11529 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIdentDirectiveStatement*  SgIdentDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIdentDirectiveStatement* poolStart = reinterpret_cast<SgIdentDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIdentDirectiveStatement::getNodeIdStringInternal(SgIdentDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIdentDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIdentDirectiveStatement::pool_size * sizeof(SgIdentDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIdentDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIdentDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11566 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLinemarkerDirectiveStatement*  SgLinemarkerDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLinemarkerDirectiveStatement* poolStart = reinterpret_cast<SgLinemarkerDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLinemarkerDirectiveStatement::getNodeIdStringInternal(SgLinemarkerDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLinemarkerDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLinemarkerDirectiveStatement::pool_size * sizeof(SgLinemarkerDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLinemarkerDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLinemarkerDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11603 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpThreadprivateStatement*  SgOmpThreadprivateStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpThreadprivateStatement* poolStart = reinterpret_cast<SgOmpThreadprivateStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpThreadprivateStatement::getNodeIdStringInternal(SgOmpThreadprivateStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpThreadprivateStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpThreadprivateStatement::pool_size * sizeof(SgOmpThreadprivateStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpThreadprivateStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpThreadprivateStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11640 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFortranIncludeLine*  SgFortranIncludeLine::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFortranIncludeLine* poolStart = reinterpret_cast<SgFortranIncludeLine*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFortranIncludeLine::getNodeIdStringInternal(SgFortranIncludeLine* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFortranIncludeLine* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFortranIncludeLine::pool_size * sizeof(SgFortranIncludeLine))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFortranIncludeLine*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFortranIncludeLine::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11677 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaImportStatement*  SgJavaImportStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaImportStatement* poolStart = reinterpret_cast<SgJavaImportStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaImportStatement::getNodeIdStringInternal(SgJavaImportStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaImportStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaImportStatement::pool_size * sizeof(SgJavaImportStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaImportStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaImportStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11714 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaPackageStatement*  SgJavaPackageStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaPackageStatement* poolStart = reinterpret_cast<SgJavaPackageStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaPackageStatement::getNodeIdStringInternal(SgJavaPackageStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaPackageStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaPackageStatement::pool_size * sizeof(SgJavaPackageStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaPackageStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaPackageStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11751 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStmtDeclarationStatement*  SgStmtDeclarationStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStmtDeclarationStatement* poolStart = reinterpret_cast<SgStmtDeclarationStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStmtDeclarationStatement::getNodeIdStringInternal(SgStmtDeclarationStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStmtDeclarationStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStmtDeclarationStatement::pool_size * sizeof(SgStmtDeclarationStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStmtDeclarationStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStmtDeclarationStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11788 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStaticAssertionDeclaration*  SgStaticAssertionDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStaticAssertionDeclaration* poolStart = reinterpret_cast<SgStaticAssertionDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStaticAssertionDeclaration::getNodeIdStringInternal(SgStaticAssertionDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStaticAssertionDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStaticAssertionDeclaration::pool_size * sizeof(SgStaticAssertionDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStaticAssertionDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStaticAssertionDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11825 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpDeclareSimdStatement*  SgOmpDeclareSimdStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpDeclareSimdStatement* poolStart = reinterpret_cast<SgOmpDeclareSimdStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpDeclareSimdStatement::getNodeIdStringInternal(SgOmpDeclareSimdStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpDeclareSimdStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpDeclareSimdStatement::pool_size * sizeof(SgOmpDeclareSimdStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpDeclareSimdStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpDeclareSimdStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11862 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMicrosoftAttributeDeclaration*  SgMicrosoftAttributeDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMicrosoftAttributeDeclaration* poolStart = reinterpret_cast<SgMicrosoftAttributeDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMicrosoftAttributeDeclaration::getNodeIdStringInternal(SgMicrosoftAttributeDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMicrosoftAttributeDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMicrosoftAttributeDeclaration::pool_size * sizeof(SgMicrosoftAttributeDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMicrosoftAttributeDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMicrosoftAttributeDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11899 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialCompoolStatement*  SgJovialCompoolStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialCompoolStatement* poolStart = reinterpret_cast<SgJovialCompoolStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialCompoolStatement::getNodeIdStringInternal(SgJovialCompoolStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialCompoolStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialCompoolStatement::pool_size * sizeof(SgJovialCompoolStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialCompoolStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialCompoolStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11936 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialDirectiveStatement*  SgJovialDirectiveStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialDirectiveStatement* poolStart = reinterpret_cast<SgJovialDirectiveStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialDirectiveStatement::getNodeIdStringInternal(SgJovialDirectiveStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialDirectiveStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialDirectiveStatement::pool_size * sizeof(SgJovialDirectiveStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialDirectiveStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialDirectiveStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 11973 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialDefineDeclaration*  SgJovialDefineDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialDefineDeclaration* poolStart = reinterpret_cast<SgJovialDefineDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialDefineDeclaration::getNodeIdStringInternal(SgJovialDefineDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialDefineDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialDefineDeclaration::pool_size * sizeof(SgJovialDefineDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialDefineDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialDefineDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12010 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialLabelDeclaration*  SgJovialLabelDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialLabelDeclaration* poolStart = reinterpret_cast<SgJovialLabelDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialLabelDeclaration::getNodeIdStringInternal(SgJovialLabelDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialLabelDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialLabelDeclaration::pool_size * sizeof(SgJovialLabelDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialLabelDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialLabelDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12047 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialOverlayDeclaration*  SgJovialOverlayDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialOverlayDeclaration* poolStart = reinterpret_cast<SgJovialOverlayDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialOverlayDeclaration::getNodeIdStringInternal(SgJovialOverlayDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialOverlayDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialOverlayDeclaration::pool_size * sizeof(SgJovialOverlayDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialOverlayDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialOverlayDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12084 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNonrealDecl*  SgNonrealDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNonrealDecl* poolStart = reinterpret_cast<SgNonrealDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNonrealDecl::getNodeIdStringInternal(SgNonrealDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNonrealDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNonrealDecl::pool_size * sizeof(SgNonrealDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNonrealDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNonrealDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12121 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEmptyDeclaration*  SgEmptyDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEmptyDeclaration* poolStart = reinterpret_cast<SgEmptyDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEmptyDeclaration::getNodeIdStringInternal(SgEmptyDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEmptyDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEmptyDeclaration::pool_size * sizeof(SgEmptyDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEmptyDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEmptyDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12158 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaPackageBodyDecl*  SgAdaPackageBodyDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaPackageBodyDecl* poolStart = reinterpret_cast<SgAdaPackageBodyDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaPackageBodyDecl::getNodeIdStringInternal(SgAdaPackageBodyDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaPackageBodyDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaPackageBodyDecl::pool_size * sizeof(SgAdaPackageBodyDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaPackageBodyDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaPackageBodyDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12195 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaPackageSpecDecl*  SgAdaPackageSpecDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaPackageSpecDecl* poolStart = reinterpret_cast<SgAdaPackageSpecDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaPackageSpecDecl::getNodeIdStringInternal(SgAdaPackageSpecDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaPackageSpecDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaPackageSpecDecl::pool_size * sizeof(SgAdaPackageSpecDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaPackageSpecDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaPackageSpecDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12232 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaRenamingDecl*  SgAdaRenamingDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaRenamingDecl* poolStart = reinterpret_cast<SgAdaRenamingDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaRenamingDecl::getNodeIdStringInternal(SgAdaRenamingDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaRenamingDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaRenamingDecl::pool_size * sizeof(SgAdaRenamingDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaRenamingDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaRenamingDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12269 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskSpecDecl*  SgAdaTaskSpecDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskSpecDecl* poolStart = reinterpret_cast<SgAdaTaskSpecDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskSpecDecl::getNodeIdStringInternal(SgAdaTaskSpecDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskSpecDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskSpecDecl::pool_size * sizeof(SgAdaTaskSpecDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskSpecDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskSpecDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12306 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskBodyDecl*  SgAdaTaskBodyDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskBodyDecl* poolStart = reinterpret_cast<SgAdaTaskBodyDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskBodyDecl::getNodeIdStringInternal(SgAdaTaskBodyDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskBodyDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskBodyDecl::pool_size * sizeof(SgAdaTaskBodyDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskBodyDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskBodyDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12343 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskTypeDecl*  SgAdaTaskTypeDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskTypeDecl* poolStart = reinterpret_cast<SgAdaTaskTypeDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskTypeDecl::getNodeIdStringInternal(SgAdaTaskTypeDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskTypeDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskTypeDecl::pool_size * sizeof(SgAdaTaskTypeDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskTypeDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskTypeDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12380 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedSpecDecl*  SgAdaProtectedSpecDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedSpecDecl* poolStart = reinterpret_cast<SgAdaProtectedSpecDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedSpecDecl::getNodeIdStringInternal(SgAdaProtectedSpecDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedSpecDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedSpecDecl::pool_size * sizeof(SgAdaProtectedSpecDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedSpecDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedSpecDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12417 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedBodyDecl*  SgAdaProtectedBodyDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedBodyDecl* poolStart = reinterpret_cast<SgAdaProtectedBodyDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedBodyDecl::getNodeIdStringInternal(SgAdaProtectedBodyDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedBodyDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedBodyDecl::pool_size * sizeof(SgAdaProtectedBodyDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedBodyDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedBodyDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12454 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedTypeDecl*  SgAdaProtectedTypeDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedTypeDecl* poolStart = reinterpret_cast<SgAdaProtectedTypeDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedTypeDecl::getNodeIdStringInternal(SgAdaProtectedTypeDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedTypeDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedTypeDecl::pool_size * sizeof(SgAdaProtectedTypeDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedTypeDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedTypeDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12491 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaRepresentationClause*  SgAdaRepresentationClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaRepresentationClause* poolStart = reinterpret_cast<SgAdaRepresentationClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaRepresentationClause::getNodeIdStringInternal(SgAdaRepresentationClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaRepresentationClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaRepresentationClause::pool_size * sizeof(SgAdaRepresentationClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaRepresentationClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaRepresentationClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12528 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaComponentClause*  SgAdaComponentClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaComponentClause* poolStart = reinterpret_cast<SgAdaComponentClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaComponentClause::getNodeIdStringInternal(SgAdaComponentClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaComponentClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaComponentClause::pool_size * sizeof(SgAdaComponentClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaComponentClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaComponentClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12565 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaAttributeClause*  SgAdaAttributeClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaAttributeClause* poolStart = reinterpret_cast<SgAdaAttributeClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaAttributeClause::getNodeIdStringInternal(SgAdaAttributeClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaAttributeClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaAttributeClause::pool_size * sizeof(SgAdaAttributeClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaAttributeClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaAttributeClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12602 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaEnumRepresentationClause*  SgAdaEnumRepresentationClause::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaEnumRepresentationClause* poolStart = reinterpret_cast<SgAdaEnumRepresentationClause*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaEnumRepresentationClause::getNodeIdStringInternal(SgAdaEnumRepresentationClause* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaEnumRepresentationClause* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaEnumRepresentationClause::pool_size * sizeof(SgAdaEnumRepresentationClause))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaEnumRepresentationClause*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaEnumRepresentationClause::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12639 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaGenericDecl*  SgAdaGenericDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaGenericDecl* poolStart = reinterpret_cast<SgAdaGenericDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaGenericDecl::getNodeIdStringInternal(SgAdaGenericDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaGenericDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaGenericDecl::pool_size * sizeof(SgAdaGenericDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaGenericDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaGenericDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12676 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaFormalTypeDecl*  SgAdaFormalTypeDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaFormalTypeDecl* poolStart = reinterpret_cast<SgAdaFormalTypeDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaFormalTypeDecl::getNodeIdStringInternal(SgAdaFormalTypeDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaFormalTypeDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaFormalTypeDecl::pool_size * sizeof(SgAdaFormalTypeDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaFormalTypeDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaFormalTypeDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12713 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDiscriminatedTypeDecl*  SgAdaDiscriminatedTypeDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDiscriminatedTypeDecl* poolStart = reinterpret_cast<SgAdaDiscriminatedTypeDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDiscriminatedTypeDecl::getNodeIdStringInternal(SgAdaDiscriminatedTypeDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDiscriminatedTypeDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDiscriminatedTypeDecl::pool_size * sizeof(SgAdaDiscriminatedTypeDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDiscriminatedTypeDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDiscriminatedTypeDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12750 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaGenericInstanceDecl*  SgAdaGenericInstanceDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaGenericInstanceDecl* poolStart = reinterpret_cast<SgAdaGenericInstanceDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaGenericInstanceDecl::getNodeIdStringInternal(SgAdaGenericInstanceDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaGenericInstanceDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaGenericInstanceDecl::pool_size * sizeof(SgAdaGenericInstanceDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaGenericInstanceDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaGenericInstanceDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12787 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaFormalPackageDecl*  SgAdaFormalPackageDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaFormalPackageDecl* poolStart = reinterpret_cast<SgAdaFormalPackageDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaFormalPackageDecl::getNodeIdStringInternal(SgAdaFormalPackageDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaFormalPackageDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaFormalPackageDecl::pool_size * sizeof(SgAdaFormalPackageDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaFormalPackageDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaFormalPackageDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12824 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaParameterList*  SgAdaParameterList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaParameterList* poolStart = reinterpret_cast<SgAdaParameterList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaParameterList::getNodeIdStringInternal(SgAdaParameterList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaParameterList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaParameterList::pool_size * sizeof(SgAdaParameterList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaParameterList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaParameterList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12861 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaVariantDecl*  SgAdaVariantDecl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaVariantDecl* poolStart = reinterpret_cast<SgAdaVariantDecl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaVariantDecl::getNodeIdStringInternal(SgAdaVariantDecl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaVariantDecl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaVariantDecl::pool_size * sizeof(SgAdaVariantDecl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaVariantDecl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaVariantDecl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12898 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExprStatement*  SgExprStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExprStatement* poolStart = reinterpret_cast<SgExprStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExprStatement::getNodeIdStringInternal(SgExprStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExprStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExprStatement::pool_size * sizeof(SgExprStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExprStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExprStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12935 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLabelStatement*  SgLabelStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLabelStatement* poolStart = reinterpret_cast<SgLabelStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLabelStatement::getNodeIdStringInternal(SgLabelStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLabelStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLabelStatement::pool_size * sizeof(SgLabelStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLabelStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLabelStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 12972 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCaseOptionStmt*  SgCaseOptionStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCaseOptionStmt* poolStart = reinterpret_cast<SgCaseOptionStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCaseOptionStmt::getNodeIdStringInternal(SgCaseOptionStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCaseOptionStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCaseOptionStmt::pool_size * sizeof(SgCaseOptionStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCaseOptionStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCaseOptionStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13009 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTryStmt*  SgTryStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTryStmt* poolStart = reinterpret_cast<SgTryStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTryStmt::getNodeIdStringInternal(SgTryStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTryStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTryStmt::pool_size * sizeof(SgTryStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTryStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTryStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13046 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDefaultOptionStmt*  SgDefaultOptionStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDefaultOptionStmt* poolStart = reinterpret_cast<SgDefaultOptionStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDefaultOptionStmt::getNodeIdStringInternal(SgDefaultOptionStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDefaultOptionStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDefaultOptionStmt::pool_size * sizeof(SgDefaultOptionStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDefaultOptionStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDefaultOptionStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13083 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBreakStmt*  SgBreakStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBreakStmt* poolStart = reinterpret_cast<SgBreakStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBreakStmt::getNodeIdStringInternal(SgBreakStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBreakStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBreakStmt::pool_size * sizeof(SgBreakStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBreakStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBreakStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13120 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgContinueStmt*  SgContinueStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgContinueStmt* poolStart = reinterpret_cast<SgContinueStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgContinueStmt::getNodeIdStringInternal(SgContinueStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgContinueStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgContinueStmt::pool_size * sizeof(SgContinueStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgContinueStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgContinueStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13157 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgReturnStmt*  SgReturnStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgReturnStmt* poolStart = reinterpret_cast<SgReturnStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgReturnStmt::getNodeIdStringInternal(SgReturnStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgReturnStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgReturnStmt::pool_size * sizeof(SgReturnStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgReturnStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgReturnStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13194 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGotoStatement*  SgGotoStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGotoStatement* poolStart = reinterpret_cast<SgGotoStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGotoStatement::getNodeIdStringInternal(SgGotoStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGotoStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGotoStatement::pool_size * sizeof(SgGotoStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGotoStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGotoStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13231 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSpawnStmt*  SgSpawnStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSpawnStmt* poolStart = reinterpret_cast<SgSpawnStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSpawnStmt::getNodeIdStringInternal(SgSpawnStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSpawnStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSpawnStmt::pool_size * sizeof(SgSpawnStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSpawnStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSpawnStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13268 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNullStatement*  SgNullStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNullStatement* poolStart = reinterpret_cast<SgNullStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNullStatement::getNodeIdStringInternal(SgNullStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNullStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNullStatement::pool_size * sizeof(SgNullStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNullStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNullStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13305 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVariantStatement*  SgVariantStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVariantStatement* poolStart = reinterpret_cast<SgVariantStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVariantStatement::getNodeIdStringInternal(SgVariantStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVariantStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVariantStatement::pool_size * sizeof(SgVariantStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVariantStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVariantStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13342 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgForInitStatement*  SgForInitStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgForInitStatement* poolStart = reinterpret_cast<SgForInitStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgForInitStatement::getNodeIdStringInternal(SgForInitStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgForInitStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgForInitStatement::pool_size * sizeof(SgForInitStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgForInitStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgForInitStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13379 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCatchStatementSeq*  SgCatchStatementSeq::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCatchStatementSeq* poolStart = reinterpret_cast<SgCatchStatementSeq*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCatchStatementSeq::getNodeIdStringInternal(SgCatchStatementSeq* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCatchStatementSeq* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCatchStatementSeq::pool_size * sizeof(SgCatchStatementSeq))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCatchStatementSeq*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCatchStatementSeq::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13416 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgProcessControlStatement*  SgProcessControlStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgProcessControlStatement* poolStart = reinterpret_cast<SgProcessControlStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgProcessControlStatement::getNodeIdStringInternal(SgProcessControlStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgProcessControlStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgProcessControlStatement::pool_size * sizeof(SgProcessControlStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgProcessControlStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgProcessControlStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13453 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIOStatement*  SgIOStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIOStatement* poolStart = reinterpret_cast<SgIOStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIOStatement::getNodeIdStringInternal(SgIOStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIOStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIOStatement::pool_size * sizeof(SgIOStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIOStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIOStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13490 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPrintStatement*  SgPrintStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPrintStatement* poolStart = reinterpret_cast<SgPrintStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPrintStatement::getNodeIdStringInternal(SgPrintStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPrintStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPrintStatement::pool_size * sizeof(SgPrintStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPrintStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPrintStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13527 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgReadStatement*  SgReadStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgReadStatement* poolStart = reinterpret_cast<SgReadStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgReadStatement::getNodeIdStringInternal(SgReadStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgReadStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgReadStatement::pool_size * sizeof(SgReadStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgReadStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgReadStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13564 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWriteStatement*  SgWriteStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWriteStatement* poolStart = reinterpret_cast<SgWriteStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWriteStatement::getNodeIdStringInternal(SgWriteStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWriteStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWriteStatement::pool_size * sizeof(SgWriteStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWriteStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWriteStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13601 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOpenStatement*  SgOpenStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOpenStatement* poolStart = reinterpret_cast<SgOpenStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOpenStatement::getNodeIdStringInternal(SgOpenStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOpenStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOpenStatement::pool_size * sizeof(SgOpenStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOpenStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOpenStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13638 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCloseStatement*  SgCloseStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCloseStatement* poolStart = reinterpret_cast<SgCloseStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCloseStatement::getNodeIdStringInternal(SgCloseStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCloseStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCloseStatement::pool_size * sizeof(SgCloseStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCloseStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCloseStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13675 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgInquireStatement*  SgInquireStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgInquireStatement* poolStart = reinterpret_cast<SgInquireStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgInquireStatement::getNodeIdStringInternal(SgInquireStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgInquireStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgInquireStatement::pool_size * sizeof(SgInquireStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgInquireStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgInquireStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13712 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFlushStatement*  SgFlushStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFlushStatement* poolStart = reinterpret_cast<SgFlushStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFlushStatement::getNodeIdStringInternal(SgFlushStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFlushStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFlushStatement::pool_size * sizeof(SgFlushStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFlushStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFlushStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13749 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBackspaceStatement*  SgBackspaceStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBackspaceStatement* poolStart = reinterpret_cast<SgBackspaceStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBackspaceStatement::getNodeIdStringInternal(SgBackspaceStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBackspaceStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBackspaceStatement::pool_size * sizeof(SgBackspaceStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBackspaceStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBackspaceStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13786 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRewindStatement*  SgRewindStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRewindStatement* poolStart = reinterpret_cast<SgRewindStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRewindStatement::getNodeIdStringInternal(SgRewindStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRewindStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRewindStatement::pool_size * sizeof(SgRewindStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRewindStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRewindStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13823 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEndfileStatement*  SgEndfileStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEndfileStatement* poolStart = reinterpret_cast<SgEndfileStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEndfileStatement::getNodeIdStringInternal(SgEndfileStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEndfileStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEndfileStatement::pool_size * sizeof(SgEndfileStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEndfileStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEndfileStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13860 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWaitStatement*  SgWaitStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWaitStatement* poolStart = reinterpret_cast<SgWaitStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWaitStatement::getNodeIdStringInternal(SgWaitStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWaitStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWaitStatement::pool_size * sizeof(SgWaitStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWaitStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWaitStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13897 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFortranContinueStmt*  SgFortranContinueStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFortranContinueStmt* poolStart = reinterpret_cast<SgFortranContinueStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFortranContinueStmt::getNodeIdStringInternal(SgFortranContinueStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFortranContinueStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFortranContinueStmt::pool_size * sizeof(SgFortranContinueStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFortranContinueStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFortranContinueStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13934 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWhereStatement*  SgWhereStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWhereStatement* poolStart = reinterpret_cast<SgWhereStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWhereStatement::getNodeIdStringInternal(SgWhereStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWhereStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWhereStatement::pool_size * sizeof(SgWhereStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWhereStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWhereStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 13971 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElseWhereStatement*  SgElseWhereStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElseWhereStatement* poolStart = reinterpret_cast<SgElseWhereStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElseWhereStatement::getNodeIdStringInternal(SgElseWhereStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElseWhereStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElseWhereStatement::pool_size * sizeof(SgElseWhereStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElseWhereStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElseWhereStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14008 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNullifyStatement*  SgNullifyStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNullifyStatement* poolStart = reinterpret_cast<SgNullifyStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNullifyStatement::getNodeIdStringInternal(SgNullifyStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNullifyStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNullifyStatement::pool_size * sizeof(SgNullifyStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNullifyStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNullifyStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14045 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgArithmeticIfStatement*  SgArithmeticIfStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgArithmeticIfStatement* poolStart = reinterpret_cast<SgArithmeticIfStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgArithmeticIfStatement::getNodeIdStringInternal(SgArithmeticIfStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgArithmeticIfStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgArithmeticIfStatement::pool_size * sizeof(SgArithmeticIfStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgArithmeticIfStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgArithmeticIfStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14082 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAssignStatement*  SgAssignStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAssignStatement* poolStart = reinterpret_cast<SgAssignStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAssignStatement::getNodeIdStringInternal(SgAssignStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAssignStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAssignStatement::pool_size * sizeof(SgAssignStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAssignStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAssignStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14119 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgComputedGotoStatement*  SgComputedGotoStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgComputedGotoStatement* poolStart = reinterpret_cast<SgComputedGotoStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgComputedGotoStatement::getNodeIdStringInternal(SgComputedGotoStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgComputedGotoStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgComputedGotoStatement::pool_size * sizeof(SgComputedGotoStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgComputedGotoStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgComputedGotoStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14156 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAssignedGotoStatement*  SgAssignedGotoStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAssignedGotoStatement* poolStart = reinterpret_cast<SgAssignedGotoStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAssignedGotoStatement::getNodeIdStringInternal(SgAssignedGotoStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAssignedGotoStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAssignedGotoStatement::pool_size * sizeof(SgAssignedGotoStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAssignedGotoStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAssignedGotoStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14193 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAllocateStatement*  SgAllocateStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAllocateStatement* poolStart = reinterpret_cast<SgAllocateStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAllocateStatement::getNodeIdStringInternal(SgAllocateStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAllocateStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAllocateStatement::pool_size * sizeof(SgAllocateStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAllocateStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAllocateStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14230 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDeallocateStatement*  SgDeallocateStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDeallocateStatement* poolStart = reinterpret_cast<SgDeallocateStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDeallocateStatement::getNodeIdStringInternal(SgDeallocateStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDeallocateStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDeallocateStatement::pool_size * sizeof(SgDeallocateStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDeallocateStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDeallocateStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14267 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcNotifyStatement*  SgUpcNotifyStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcNotifyStatement* poolStart = reinterpret_cast<SgUpcNotifyStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcNotifyStatement::getNodeIdStringInternal(SgUpcNotifyStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcNotifyStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcNotifyStatement::pool_size * sizeof(SgUpcNotifyStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcNotifyStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcNotifyStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14304 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcWaitStatement*  SgUpcWaitStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcWaitStatement* poolStart = reinterpret_cast<SgUpcWaitStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcWaitStatement::getNodeIdStringInternal(SgUpcWaitStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcWaitStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcWaitStatement::pool_size * sizeof(SgUpcWaitStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcWaitStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcWaitStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14341 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcBarrierStatement*  SgUpcBarrierStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcBarrierStatement* poolStart = reinterpret_cast<SgUpcBarrierStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcBarrierStatement::getNodeIdStringInternal(SgUpcBarrierStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcBarrierStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcBarrierStatement::pool_size * sizeof(SgUpcBarrierStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcBarrierStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcBarrierStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14378 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcFenceStatement*  SgUpcFenceStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcFenceStatement* poolStart = reinterpret_cast<SgUpcFenceStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcFenceStatement::getNodeIdStringInternal(SgUpcFenceStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcFenceStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcFenceStatement::pool_size * sizeof(SgUpcFenceStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcFenceStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcFenceStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14415 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpBarrierStatement*  SgOmpBarrierStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpBarrierStatement* poolStart = reinterpret_cast<SgOmpBarrierStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpBarrierStatement::getNodeIdStringInternal(SgOmpBarrierStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpBarrierStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpBarrierStatement::pool_size * sizeof(SgOmpBarrierStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpBarrierStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpBarrierStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14452 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpTaskwaitStatement*  SgOmpTaskwaitStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpTaskwaitStatement* poolStart = reinterpret_cast<SgOmpTaskwaitStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpTaskwaitStatement::getNodeIdStringInternal(SgOmpTaskwaitStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpTaskwaitStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpTaskwaitStatement::pool_size * sizeof(SgOmpTaskwaitStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpTaskwaitStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpTaskwaitStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14489 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpFlushStatement*  SgOmpFlushStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpFlushStatement* poolStart = reinterpret_cast<SgOmpFlushStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpFlushStatement::getNodeIdStringInternal(SgOmpFlushStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpFlushStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpFlushStatement::pool_size * sizeof(SgOmpFlushStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpFlushStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpFlushStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14526 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpBodyStatement*  SgOmpBodyStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpBodyStatement* poolStart = reinterpret_cast<SgOmpBodyStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpBodyStatement::getNodeIdStringInternal(SgOmpBodyStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpBodyStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpBodyStatement::pool_size * sizeof(SgOmpBodyStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpBodyStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpBodyStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14563 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpMasterStatement*  SgOmpMasterStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpMasterStatement* poolStart = reinterpret_cast<SgOmpMasterStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpMasterStatement::getNodeIdStringInternal(SgOmpMasterStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpMasterStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpMasterStatement::pool_size * sizeof(SgOmpMasterStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpMasterStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpMasterStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14600 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpOrderedStatement*  SgOmpOrderedStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpOrderedStatement* poolStart = reinterpret_cast<SgOmpOrderedStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpOrderedStatement::getNodeIdStringInternal(SgOmpOrderedStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpOrderedStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpOrderedStatement::pool_size * sizeof(SgOmpOrderedStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpOrderedStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpOrderedStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14637 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpCriticalStatement*  SgOmpCriticalStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpCriticalStatement* poolStart = reinterpret_cast<SgOmpCriticalStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpCriticalStatement::getNodeIdStringInternal(SgOmpCriticalStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpCriticalStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpCriticalStatement::pool_size * sizeof(SgOmpCriticalStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpCriticalStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpCriticalStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14674 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpSectionStatement*  SgOmpSectionStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpSectionStatement* poolStart = reinterpret_cast<SgOmpSectionStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpSectionStatement::getNodeIdStringInternal(SgOmpSectionStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpSectionStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpSectionStatement::pool_size * sizeof(SgOmpSectionStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpSectionStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpSectionStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14711 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpWorkshareStatement*  SgOmpWorkshareStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpWorkshareStatement* poolStart = reinterpret_cast<SgOmpWorkshareStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpWorkshareStatement::getNodeIdStringInternal(SgOmpWorkshareStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpWorkshareStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpWorkshareStatement::pool_size * sizeof(SgOmpWorkshareStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpWorkshareStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpWorkshareStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14748 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpClauseBodyStatement*  SgOmpClauseBodyStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpClauseBodyStatement* poolStart = reinterpret_cast<SgOmpClauseBodyStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpClauseBodyStatement::getNodeIdStringInternal(SgOmpClauseBodyStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpClauseBodyStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpClauseBodyStatement::pool_size * sizeof(SgOmpClauseBodyStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpClauseBodyStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpClauseBodyStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14785 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpParallelStatement*  SgOmpParallelStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpParallelStatement* poolStart = reinterpret_cast<SgOmpParallelStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpParallelStatement::getNodeIdStringInternal(SgOmpParallelStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpParallelStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpParallelStatement::pool_size * sizeof(SgOmpParallelStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpParallelStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpParallelStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14822 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpSingleStatement*  SgOmpSingleStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpSingleStatement* poolStart = reinterpret_cast<SgOmpSingleStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpSingleStatement::getNodeIdStringInternal(SgOmpSingleStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpSingleStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpSingleStatement::pool_size * sizeof(SgOmpSingleStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpSingleStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpSingleStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14859 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpAtomicStatement*  SgOmpAtomicStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpAtomicStatement* poolStart = reinterpret_cast<SgOmpAtomicStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpAtomicStatement::getNodeIdStringInternal(SgOmpAtomicStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpAtomicStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpAtomicStatement::pool_size * sizeof(SgOmpAtomicStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpAtomicStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpAtomicStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14896 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpTaskStatement*  SgOmpTaskStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpTaskStatement* poolStart = reinterpret_cast<SgOmpTaskStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpTaskStatement::getNodeIdStringInternal(SgOmpTaskStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpTaskStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpTaskStatement::pool_size * sizeof(SgOmpTaskStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpTaskStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpTaskStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14933 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpForStatement*  SgOmpForStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpForStatement* poolStart = reinterpret_cast<SgOmpForStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpForStatement::getNodeIdStringInternal(SgOmpForStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpForStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpForStatement::pool_size * sizeof(SgOmpForStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpForStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpForStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 14970 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpDoStatement*  SgOmpDoStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpDoStatement* poolStart = reinterpret_cast<SgOmpDoStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpDoStatement::getNodeIdStringInternal(SgOmpDoStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpDoStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpDoStatement::pool_size * sizeof(SgOmpDoStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpDoStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpDoStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15007 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpSectionsStatement*  SgOmpSectionsStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpSectionsStatement* poolStart = reinterpret_cast<SgOmpSectionsStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpSectionsStatement::getNodeIdStringInternal(SgOmpSectionsStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpSectionsStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpSectionsStatement::pool_size * sizeof(SgOmpSectionsStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpSectionsStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpSectionsStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15044 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpTargetStatement*  SgOmpTargetStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpTargetStatement* poolStart = reinterpret_cast<SgOmpTargetStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpTargetStatement::getNodeIdStringInternal(SgOmpTargetStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpTargetStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpTargetStatement::pool_size * sizeof(SgOmpTargetStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpTargetStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpTargetStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15081 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpTargetDataStatement*  SgOmpTargetDataStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpTargetDataStatement* poolStart = reinterpret_cast<SgOmpTargetDataStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpTargetDataStatement::getNodeIdStringInternal(SgOmpTargetDataStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpTargetDataStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpTargetDataStatement::pool_size * sizeof(SgOmpTargetDataStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpTargetDataStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpTargetDataStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15118 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpSimdStatement*  SgOmpSimdStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpSimdStatement* poolStart = reinterpret_cast<SgOmpSimdStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpSimdStatement::getNodeIdStringInternal(SgOmpSimdStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpSimdStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpSimdStatement::pool_size * sizeof(SgOmpSimdStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpSimdStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpSimdStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15155 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOmpForSimdStatement*  SgOmpForSimdStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOmpForSimdStatement* poolStart = reinterpret_cast<SgOmpForSimdStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOmpForSimdStatement::getNodeIdStringInternal(SgOmpForSimdStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOmpForSimdStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOmpForSimdStatement::pool_size * sizeof(SgOmpForSimdStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOmpForSimdStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOmpForSimdStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15192 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSequenceStatement*  SgSequenceStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSequenceStatement* poolStart = reinterpret_cast<SgSequenceStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSequenceStatement::getNodeIdStringInternal(SgSequenceStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSequenceStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSequenceStatement::pool_size * sizeof(SgSequenceStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSequenceStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSequenceStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15229 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWithStatement*  SgWithStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWithStatement* poolStart = reinterpret_cast<SgWithStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWithStatement::getNodeIdStringInternal(SgWithStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWithStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWithStatement::pool_size * sizeof(SgWithStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWithStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWithStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15266 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPythonPrintStmt*  SgPythonPrintStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPythonPrintStmt* poolStart = reinterpret_cast<SgPythonPrintStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPythonPrintStmt::getNodeIdStringInternal(SgPythonPrintStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPythonPrintStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPythonPrintStmt::pool_size * sizeof(SgPythonPrintStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPythonPrintStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPythonPrintStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15303 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPassStatement*  SgPassStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPassStatement* poolStart = reinterpret_cast<SgPassStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPassStatement::getNodeIdStringInternal(SgPassStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPassStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPassStatement::pool_size * sizeof(SgPassStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPassStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPassStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15340 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAssertStmt*  SgAssertStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAssertStmt* poolStart = reinterpret_cast<SgAssertStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAssertStmt::getNodeIdStringInternal(SgAssertStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAssertStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAssertStmt::pool_size * sizeof(SgAssertStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAssertStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAssertStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15377 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExecStatement*  SgExecStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExecStatement* poolStart = reinterpret_cast<SgExecStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExecStatement::getNodeIdStringInternal(SgExecStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExecStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExecStatement::pool_size * sizeof(SgExecStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExecStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExecStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15414 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPythonGlobalStmt*  SgPythonGlobalStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPythonGlobalStmt* poolStart = reinterpret_cast<SgPythonGlobalStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPythonGlobalStmt::getNodeIdStringInternal(SgPythonGlobalStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPythonGlobalStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPythonGlobalStmt::pool_size * sizeof(SgPythonGlobalStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPythonGlobalStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPythonGlobalStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15451 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaThrowStatement*  SgJavaThrowStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaThrowStatement* poolStart = reinterpret_cast<SgJavaThrowStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaThrowStatement::getNodeIdStringInternal(SgJavaThrowStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaThrowStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaThrowStatement::pool_size * sizeof(SgJavaThrowStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaThrowStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaThrowStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15488 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaSynchronizedStatement*  SgJavaSynchronizedStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaSynchronizedStatement* poolStart = reinterpret_cast<SgJavaSynchronizedStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaSynchronizedStatement::getNodeIdStringInternal(SgJavaSynchronizedStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaSynchronizedStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaSynchronizedStatement::pool_size * sizeof(SgJavaSynchronizedStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaSynchronizedStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaSynchronizedStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15525 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsyncStmt*  SgAsyncStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsyncStmt* poolStart = reinterpret_cast<SgAsyncStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsyncStmt::getNodeIdStringInternal(SgAsyncStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsyncStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsyncStmt::pool_size * sizeof(SgAsyncStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsyncStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsyncStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15562 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFinishStmt*  SgFinishStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFinishStmt* poolStart = reinterpret_cast<SgFinishStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFinishStmt::getNodeIdStringInternal(SgFinishStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFinishStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFinishStmt::pool_size * sizeof(SgFinishStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFinishStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFinishStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15599 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAtStmt*  SgAtStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAtStmt* poolStart = reinterpret_cast<SgAtStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAtStmt::getNodeIdStringInternal(SgAtStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAtStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAtStmt::pool_size * sizeof(SgAtStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAtStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAtStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15636 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAtomicStmt*  SgAtomicStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAtomicStmt* poolStart = reinterpret_cast<SgAtomicStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAtomicStmt::getNodeIdStringInternal(SgAtomicStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAtomicStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAtomicStmt::pool_size * sizeof(SgAtomicStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAtomicStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAtomicStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15673 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWhenStmt*  SgWhenStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWhenStmt* poolStart = reinterpret_cast<SgWhenStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWhenStmt::getNodeIdStringInternal(SgWhenStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWhenStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWhenStmt::pool_size * sizeof(SgWhenStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWhenStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWhenStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15710 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgImageControlStatement*  SgImageControlStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgImageControlStatement* poolStart = reinterpret_cast<SgImageControlStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgImageControlStatement::getNodeIdStringInternal(SgImageControlStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgImageControlStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgImageControlStatement::pool_size * sizeof(SgImageControlStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgImageControlStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgImageControlStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15747 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSyncAllStatement*  SgSyncAllStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSyncAllStatement* poolStart = reinterpret_cast<SgSyncAllStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSyncAllStatement::getNodeIdStringInternal(SgSyncAllStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSyncAllStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSyncAllStatement::pool_size * sizeof(SgSyncAllStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSyncAllStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSyncAllStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15784 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSyncImagesStatement*  SgSyncImagesStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSyncImagesStatement* poolStart = reinterpret_cast<SgSyncImagesStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSyncImagesStatement::getNodeIdStringInternal(SgSyncImagesStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSyncImagesStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSyncImagesStatement::pool_size * sizeof(SgSyncImagesStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSyncImagesStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSyncImagesStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15821 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSyncMemoryStatement*  SgSyncMemoryStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSyncMemoryStatement* poolStart = reinterpret_cast<SgSyncMemoryStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSyncMemoryStatement::getNodeIdStringInternal(SgSyncMemoryStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSyncMemoryStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSyncMemoryStatement::pool_size * sizeof(SgSyncMemoryStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSyncMemoryStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSyncMemoryStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15858 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSyncTeamStatement*  SgSyncTeamStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSyncTeamStatement* poolStart = reinterpret_cast<SgSyncTeamStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSyncTeamStatement::getNodeIdStringInternal(SgSyncTeamStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSyncTeamStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSyncTeamStatement::pool_size * sizeof(SgSyncTeamStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSyncTeamStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSyncTeamStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15895 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLockStatement*  SgLockStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLockStatement* poolStart = reinterpret_cast<SgLockStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLockStatement::getNodeIdStringInternal(SgLockStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLockStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLockStatement::pool_size * sizeof(SgLockStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLockStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLockStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15932 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnlockStatement*  SgUnlockStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnlockStatement* poolStart = reinterpret_cast<SgUnlockStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnlockStatement::getNodeIdStringInternal(SgUnlockStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnlockStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnlockStatement::pool_size * sizeof(SgUnlockStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnlockStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnlockStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 15969 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaExitStmt*  SgAdaExitStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaExitStmt* poolStart = reinterpret_cast<SgAdaExitStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaExitStmt::getNodeIdStringInternal(SgAdaExitStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaExitStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaExitStmt::pool_size * sizeof(SgAdaExitStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaExitStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaExitStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16006 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaDelayStmt*  SgAdaDelayStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaDelayStmt* poolStart = reinterpret_cast<SgAdaDelayStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaDelayStmt::getNodeIdStringInternal(SgAdaDelayStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaDelayStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaDelayStmt::pool_size * sizeof(SgAdaDelayStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaDelayStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaDelayStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16043 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaLoopStmt*  SgAdaLoopStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaLoopStmt* poolStart = reinterpret_cast<SgAdaLoopStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaLoopStmt::getNodeIdStringInternal(SgAdaLoopStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaLoopStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaLoopStmt::pool_size * sizeof(SgAdaLoopStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaLoopStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaLoopStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16080 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaSelectStmt*  SgAdaSelectStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaSelectStmt* poolStart = reinterpret_cast<SgAdaSelectStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaSelectStmt::getNodeIdStringInternal(SgAdaSelectStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaSelectStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaSelectStmt::pool_size * sizeof(SgAdaSelectStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaSelectStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaSelectStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16117 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaSelectAlternativeStmt*  SgAdaSelectAlternativeStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaSelectAlternativeStmt* poolStart = reinterpret_cast<SgAdaSelectAlternativeStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaSelectAlternativeStmt::getNodeIdStringInternal(SgAdaSelectAlternativeStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaSelectAlternativeStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaSelectAlternativeStmt::pool_size * sizeof(SgAdaSelectAlternativeStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaSelectAlternativeStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaSelectAlternativeStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16154 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTerminateStmt*  SgAdaTerminateStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTerminateStmt* poolStart = reinterpret_cast<SgAdaTerminateStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTerminateStmt::getNodeIdStringInternal(SgAdaTerminateStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTerminateStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTerminateStmt::pool_size * sizeof(SgAdaTerminateStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTerminateStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTerminateStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16191 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaUnscopedBlock*  SgAdaUnscopedBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaUnscopedBlock* poolStart = reinterpret_cast<SgAdaUnscopedBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaUnscopedBlock::getNodeIdStringInternal(SgAdaUnscopedBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaUnscopedBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaUnscopedBlock::pool_size * sizeof(SgAdaUnscopedBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaUnscopedBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaUnscopedBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16228 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaVariantWhenStmt*  SgAdaVariantWhenStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaVariantWhenStmt* poolStart = reinterpret_cast<SgAdaVariantWhenStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaVariantWhenStmt::getNodeIdStringInternal(SgAdaVariantWhenStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaVariantWhenStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaVariantWhenStmt::pool_size * sizeof(SgAdaVariantWhenStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaVariantWhenStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaVariantWhenStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16265 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExpression*  SgExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExpression* poolStart = reinterpret_cast<SgExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExpression::getNodeIdStringInternal(SgExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExpression::pool_size * sizeof(SgExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16302 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnaryOp*  SgUnaryOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnaryOp* poolStart = reinterpret_cast<SgUnaryOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnaryOp::getNodeIdStringInternal(SgUnaryOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnaryOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnaryOp::pool_size * sizeof(SgUnaryOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnaryOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnaryOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16339 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExpressionRoot*  SgExpressionRoot::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExpressionRoot* poolStart = reinterpret_cast<SgExpressionRoot*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExpressionRoot::getNodeIdStringInternal(SgExpressionRoot* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExpressionRoot* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExpressionRoot::pool_size * sizeof(SgExpressionRoot))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExpressionRoot*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExpressionRoot::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16376 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMinusOp*  SgMinusOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMinusOp* poolStart = reinterpret_cast<SgMinusOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMinusOp::getNodeIdStringInternal(SgMinusOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMinusOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMinusOp::pool_size * sizeof(SgMinusOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMinusOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMinusOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16413 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnaryAddOp*  SgUnaryAddOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnaryAddOp* poolStart = reinterpret_cast<SgUnaryAddOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnaryAddOp::getNodeIdStringInternal(SgUnaryAddOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnaryAddOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnaryAddOp::pool_size * sizeof(SgUnaryAddOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnaryAddOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnaryAddOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16450 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNotOp*  SgNotOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNotOp* poolStart = reinterpret_cast<SgNotOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNotOp::getNodeIdStringInternal(SgNotOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNotOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNotOp::pool_size * sizeof(SgNotOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNotOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNotOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16487 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPointerDerefExp*  SgPointerDerefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPointerDerefExp* poolStart = reinterpret_cast<SgPointerDerefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPointerDerefExp::getNodeIdStringInternal(SgPointerDerefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPointerDerefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPointerDerefExp::pool_size * sizeof(SgPointerDerefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPointerDerefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPointerDerefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16524 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAddressOfOp*  SgAddressOfOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAddressOfOp* poolStart = reinterpret_cast<SgAddressOfOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAddressOfOp::getNodeIdStringInternal(SgAddressOfOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAddressOfOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAddressOfOp::pool_size * sizeof(SgAddressOfOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAddressOfOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAddressOfOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16561 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMinusMinusOp*  SgMinusMinusOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMinusMinusOp* poolStart = reinterpret_cast<SgMinusMinusOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMinusMinusOp::getNodeIdStringInternal(SgMinusMinusOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMinusMinusOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMinusMinusOp::pool_size * sizeof(SgMinusMinusOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMinusMinusOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMinusMinusOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16598 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPlusPlusOp*  SgPlusPlusOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPlusPlusOp* poolStart = reinterpret_cast<SgPlusPlusOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPlusPlusOp::getNodeIdStringInternal(SgPlusPlusOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPlusPlusOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPlusPlusOp::pool_size * sizeof(SgPlusPlusOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPlusPlusOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPlusPlusOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16635 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBitComplementOp*  SgBitComplementOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBitComplementOp* poolStart = reinterpret_cast<SgBitComplementOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBitComplementOp::getNodeIdStringInternal(SgBitComplementOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBitComplementOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBitComplementOp::pool_size * sizeof(SgBitComplementOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBitComplementOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBitComplementOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16672 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCastExp*  SgCastExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCastExp* poolStart = reinterpret_cast<SgCastExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCastExp::getNodeIdStringInternal(SgCastExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCastExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCastExp::pool_size * sizeof(SgCastExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCastExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCastExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16709 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgThrowOp*  SgThrowOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgThrowOp* poolStart = reinterpret_cast<SgThrowOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgThrowOp::getNodeIdStringInternal(SgThrowOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgThrowOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgThrowOp::pool_size * sizeof(SgThrowOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgThrowOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgThrowOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16746 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRealPartOp*  SgRealPartOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRealPartOp* poolStart = reinterpret_cast<SgRealPartOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRealPartOp::getNodeIdStringInternal(SgRealPartOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRealPartOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRealPartOp::pool_size * sizeof(SgRealPartOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRealPartOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRealPartOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16783 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgImagPartOp*  SgImagPartOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgImagPartOp* poolStart = reinterpret_cast<SgImagPartOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgImagPartOp::getNodeIdStringInternal(SgImagPartOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgImagPartOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgImagPartOp::pool_size * sizeof(SgImagPartOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgImagPartOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgImagPartOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16820 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgConjugateOp*  SgConjugateOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgConjugateOp* poolStart = reinterpret_cast<SgConjugateOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgConjugateOp::getNodeIdStringInternal(SgConjugateOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgConjugateOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgConjugateOp::pool_size * sizeof(SgConjugateOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgConjugateOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgConjugateOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16857 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUserDefinedUnaryOp*  SgUserDefinedUnaryOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUserDefinedUnaryOp* poolStart = reinterpret_cast<SgUserDefinedUnaryOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUserDefinedUnaryOp::getNodeIdStringInternal(SgUserDefinedUnaryOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUserDefinedUnaryOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUserDefinedUnaryOp::pool_size * sizeof(SgUserDefinedUnaryOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUserDefinedUnaryOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUserDefinedUnaryOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16894 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMatrixTransposeOp*  SgMatrixTransposeOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMatrixTransposeOp* poolStart = reinterpret_cast<SgMatrixTransposeOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMatrixTransposeOp::getNodeIdStringInternal(SgMatrixTransposeOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMatrixTransposeOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMatrixTransposeOp::pool_size * sizeof(SgMatrixTransposeOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMatrixTransposeOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMatrixTransposeOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16931 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAbsOp*  SgAbsOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAbsOp* poolStart = reinterpret_cast<SgAbsOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAbsOp::getNodeIdStringInternal(SgAbsOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAbsOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAbsOp::pool_size * sizeof(SgAbsOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAbsOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAbsOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 16968 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBinaryOp*  SgBinaryOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBinaryOp* poolStart = reinterpret_cast<SgBinaryOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBinaryOp::getNodeIdStringInternal(SgBinaryOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBinaryOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBinaryOp::pool_size * sizeof(SgBinaryOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBinaryOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBinaryOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17005 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgArrowExp*  SgArrowExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgArrowExp* poolStart = reinterpret_cast<SgArrowExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgArrowExp::getNodeIdStringInternal(SgArrowExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgArrowExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgArrowExp::pool_size * sizeof(SgArrowExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgArrowExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgArrowExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17042 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDotExp*  SgDotExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDotExp* poolStart = reinterpret_cast<SgDotExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDotExp::getNodeIdStringInternal(SgDotExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDotExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDotExp::pool_size * sizeof(SgDotExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDotExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDotExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17079 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDotStarOp*  SgDotStarOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDotStarOp* poolStart = reinterpret_cast<SgDotStarOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDotStarOp::getNodeIdStringInternal(SgDotStarOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDotStarOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDotStarOp::pool_size * sizeof(SgDotStarOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDotStarOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDotStarOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17116 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgArrowStarOp*  SgArrowStarOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgArrowStarOp* poolStart = reinterpret_cast<SgArrowStarOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgArrowStarOp::getNodeIdStringInternal(SgArrowStarOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgArrowStarOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgArrowStarOp::pool_size * sizeof(SgArrowStarOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgArrowStarOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgArrowStarOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17153 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEqualityOp*  SgEqualityOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEqualityOp* poolStart = reinterpret_cast<SgEqualityOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEqualityOp::getNodeIdStringInternal(SgEqualityOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEqualityOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEqualityOp::pool_size * sizeof(SgEqualityOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEqualityOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEqualityOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17190 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLessThanOp*  SgLessThanOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLessThanOp* poolStart = reinterpret_cast<SgLessThanOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLessThanOp::getNodeIdStringInternal(SgLessThanOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLessThanOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLessThanOp::pool_size * sizeof(SgLessThanOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLessThanOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLessThanOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17227 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGreaterThanOp*  SgGreaterThanOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGreaterThanOp* poolStart = reinterpret_cast<SgGreaterThanOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGreaterThanOp::getNodeIdStringInternal(SgGreaterThanOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGreaterThanOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGreaterThanOp::pool_size * sizeof(SgGreaterThanOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGreaterThanOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGreaterThanOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17264 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNotEqualOp*  SgNotEqualOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNotEqualOp* poolStart = reinterpret_cast<SgNotEqualOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNotEqualOp::getNodeIdStringInternal(SgNotEqualOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNotEqualOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNotEqualOp::pool_size * sizeof(SgNotEqualOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNotEqualOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNotEqualOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17301 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLessOrEqualOp*  SgLessOrEqualOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLessOrEqualOp* poolStart = reinterpret_cast<SgLessOrEqualOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLessOrEqualOp::getNodeIdStringInternal(SgLessOrEqualOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLessOrEqualOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLessOrEqualOp::pool_size * sizeof(SgLessOrEqualOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLessOrEqualOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLessOrEqualOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17338 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgGreaterOrEqualOp*  SgGreaterOrEqualOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgGreaterOrEqualOp* poolStart = reinterpret_cast<SgGreaterOrEqualOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgGreaterOrEqualOp::getNodeIdStringInternal(SgGreaterOrEqualOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgGreaterOrEqualOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgGreaterOrEqualOp::pool_size * sizeof(SgGreaterOrEqualOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgGreaterOrEqualOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgGreaterOrEqualOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17375 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAddOp*  SgAddOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAddOp* poolStart = reinterpret_cast<SgAddOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAddOp::getNodeIdStringInternal(SgAddOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAddOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAddOp::pool_size * sizeof(SgAddOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAddOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAddOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17412 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSubtractOp*  SgSubtractOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSubtractOp* poolStart = reinterpret_cast<SgSubtractOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSubtractOp::getNodeIdStringInternal(SgSubtractOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSubtractOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSubtractOp::pool_size * sizeof(SgSubtractOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSubtractOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSubtractOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17449 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMultiplyOp*  SgMultiplyOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMultiplyOp* poolStart = reinterpret_cast<SgMultiplyOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMultiplyOp::getNodeIdStringInternal(SgMultiplyOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMultiplyOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMultiplyOp::pool_size * sizeof(SgMultiplyOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMultiplyOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMultiplyOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17486 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDivideOp*  SgDivideOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDivideOp* poolStart = reinterpret_cast<SgDivideOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDivideOp::getNodeIdStringInternal(SgDivideOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDivideOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDivideOp::pool_size * sizeof(SgDivideOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDivideOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDivideOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17523 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIntegerDivideOp*  SgIntegerDivideOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIntegerDivideOp* poolStart = reinterpret_cast<SgIntegerDivideOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIntegerDivideOp::getNodeIdStringInternal(SgIntegerDivideOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIntegerDivideOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIntegerDivideOp::pool_size * sizeof(SgIntegerDivideOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIntegerDivideOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIntegerDivideOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17560 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgModOp*  SgModOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgModOp* poolStart = reinterpret_cast<SgModOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgModOp::getNodeIdStringInternal(SgModOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgModOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgModOp::pool_size * sizeof(SgModOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgModOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgModOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17597 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAndOp*  SgAndOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAndOp* poolStart = reinterpret_cast<SgAndOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAndOp::getNodeIdStringInternal(SgAndOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAndOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAndOp::pool_size * sizeof(SgAndOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAndOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAndOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17634 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgOrOp*  SgOrOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgOrOp* poolStart = reinterpret_cast<SgOrOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgOrOp::getNodeIdStringInternal(SgOrOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgOrOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgOrOp::pool_size * sizeof(SgOrOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgOrOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgOrOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17671 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBitXorOp*  SgBitXorOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBitXorOp* poolStart = reinterpret_cast<SgBitXorOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBitXorOp::getNodeIdStringInternal(SgBitXorOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBitXorOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBitXorOp::pool_size * sizeof(SgBitXorOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBitXorOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBitXorOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17708 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBitAndOp*  SgBitAndOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBitAndOp* poolStart = reinterpret_cast<SgBitAndOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBitAndOp::getNodeIdStringInternal(SgBitAndOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBitAndOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBitAndOp::pool_size * sizeof(SgBitAndOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBitAndOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBitAndOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17745 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBitOrOp*  SgBitOrOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBitOrOp* poolStart = reinterpret_cast<SgBitOrOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBitOrOp::getNodeIdStringInternal(SgBitOrOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBitOrOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBitOrOp::pool_size * sizeof(SgBitOrOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBitOrOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBitOrOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17782 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBitEqvOp*  SgBitEqvOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBitEqvOp* poolStart = reinterpret_cast<SgBitEqvOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBitEqvOp::getNodeIdStringInternal(SgBitEqvOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBitEqvOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBitEqvOp::pool_size * sizeof(SgBitEqvOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBitEqvOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBitEqvOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17819 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCommaOpExp*  SgCommaOpExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCommaOpExp* poolStart = reinterpret_cast<SgCommaOpExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCommaOpExp::getNodeIdStringInternal(SgCommaOpExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCommaOpExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCommaOpExp::pool_size * sizeof(SgCommaOpExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCommaOpExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCommaOpExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17856 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLshiftOp*  SgLshiftOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLshiftOp* poolStart = reinterpret_cast<SgLshiftOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLshiftOp::getNodeIdStringInternal(SgLshiftOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLshiftOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLshiftOp::pool_size * sizeof(SgLshiftOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLshiftOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLshiftOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17893 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRshiftOp*  SgRshiftOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRshiftOp* poolStart = reinterpret_cast<SgRshiftOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRshiftOp::getNodeIdStringInternal(SgRshiftOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRshiftOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRshiftOp::pool_size * sizeof(SgRshiftOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRshiftOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRshiftOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17930 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPntrArrRefExp*  SgPntrArrRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPntrArrRefExp* poolStart = reinterpret_cast<SgPntrArrRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPntrArrRefExp::getNodeIdStringInternal(SgPntrArrRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPntrArrRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPntrArrRefExp::pool_size * sizeof(SgPntrArrRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPntrArrRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPntrArrRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 17967 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgScopeOp*  SgScopeOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgScopeOp* poolStart = reinterpret_cast<SgScopeOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgScopeOp::getNodeIdStringInternal(SgScopeOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgScopeOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgScopeOp::pool_size * sizeof(SgScopeOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgScopeOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgScopeOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18004 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAssignOp*  SgAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAssignOp* poolStart = reinterpret_cast<SgAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAssignOp::getNodeIdStringInternal(SgAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAssignOp::pool_size * sizeof(SgAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18041 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExponentiationOp*  SgExponentiationOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExponentiationOp* poolStart = reinterpret_cast<SgExponentiationOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExponentiationOp::getNodeIdStringInternal(SgExponentiationOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExponentiationOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExponentiationOp::pool_size * sizeof(SgExponentiationOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExponentiationOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExponentiationOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18078 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaUnsignedRshiftOp*  SgJavaUnsignedRshiftOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaUnsignedRshiftOp* poolStart = reinterpret_cast<SgJavaUnsignedRshiftOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaUnsignedRshiftOp::getNodeIdStringInternal(SgJavaUnsignedRshiftOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaUnsignedRshiftOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaUnsignedRshiftOp::pool_size * sizeof(SgJavaUnsignedRshiftOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaUnsignedRshiftOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaUnsignedRshiftOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18115 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgConcatenationOp*  SgConcatenationOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgConcatenationOp* poolStart = reinterpret_cast<SgConcatenationOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgConcatenationOp::getNodeIdStringInternal(SgConcatenationOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgConcatenationOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgConcatenationOp::pool_size * sizeof(SgConcatenationOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgConcatenationOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgConcatenationOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18152 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPointerAssignOp*  SgPointerAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPointerAssignOp* poolStart = reinterpret_cast<SgPointerAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPointerAssignOp::getNodeIdStringInternal(SgPointerAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPointerAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPointerAssignOp::pool_size * sizeof(SgPointerAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPointerAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPointerAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18189 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUserDefinedBinaryOp*  SgUserDefinedBinaryOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUserDefinedBinaryOp* poolStart = reinterpret_cast<SgUserDefinedBinaryOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUserDefinedBinaryOp::getNodeIdStringInternal(SgUserDefinedBinaryOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUserDefinedBinaryOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUserDefinedBinaryOp::pool_size * sizeof(SgUserDefinedBinaryOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUserDefinedBinaryOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUserDefinedBinaryOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18226 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCompoundAssignOp*  SgCompoundAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCompoundAssignOp* poolStart = reinterpret_cast<SgCompoundAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCompoundAssignOp::getNodeIdStringInternal(SgCompoundAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCompoundAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCompoundAssignOp::pool_size * sizeof(SgCompoundAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCompoundAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCompoundAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18263 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPlusAssignOp*  SgPlusAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPlusAssignOp* poolStart = reinterpret_cast<SgPlusAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPlusAssignOp::getNodeIdStringInternal(SgPlusAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPlusAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPlusAssignOp::pool_size * sizeof(SgPlusAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPlusAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPlusAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18300 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMinusAssignOp*  SgMinusAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMinusAssignOp* poolStart = reinterpret_cast<SgMinusAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMinusAssignOp::getNodeIdStringInternal(SgMinusAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMinusAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMinusAssignOp::pool_size * sizeof(SgMinusAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMinusAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMinusAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18337 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAndAssignOp*  SgAndAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAndAssignOp* poolStart = reinterpret_cast<SgAndAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAndAssignOp::getNodeIdStringInternal(SgAndAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAndAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAndAssignOp::pool_size * sizeof(SgAndAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAndAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAndAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18374 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIorAssignOp*  SgIorAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIorAssignOp* poolStart = reinterpret_cast<SgIorAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIorAssignOp::getNodeIdStringInternal(SgIorAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIorAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIorAssignOp::pool_size * sizeof(SgIorAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIorAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIorAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18411 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMultAssignOp*  SgMultAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMultAssignOp* poolStart = reinterpret_cast<SgMultAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMultAssignOp::getNodeIdStringInternal(SgMultAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMultAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMultAssignOp::pool_size * sizeof(SgMultAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMultAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMultAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18448 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDivAssignOp*  SgDivAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDivAssignOp* poolStart = reinterpret_cast<SgDivAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDivAssignOp::getNodeIdStringInternal(SgDivAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDivAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDivAssignOp::pool_size * sizeof(SgDivAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDivAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDivAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18485 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgModAssignOp*  SgModAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgModAssignOp* poolStart = reinterpret_cast<SgModAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgModAssignOp::getNodeIdStringInternal(SgModAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgModAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgModAssignOp::pool_size * sizeof(SgModAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgModAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgModAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18522 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgXorAssignOp*  SgXorAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgXorAssignOp* poolStart = reinterpret_cast<SgXorAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgXorAssignOp::getNodeIdStringInternal(SgXorAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgXorAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgXorAssignOp::pool_size * sizeof(SgXorAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgXorAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgXorAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18559 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLshiftAssignOp*  SgLshiftAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLshiftAssignOp* poolStart = reinterpret_cast<SgLshiftAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLshiftAssignOp::getNodeIdStringInternal(SgLshiftAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLshiftAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLshiftAssignOp::pool_size * sizeof(SgLshiftAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLshiftAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLshiftAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18596 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRshiftAssignOp*  SgRshiftAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRshiftAssignOp* poolStart = reinterpret_cast<SgRshiftAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRshiftAssignOp::getNodeIdStringInternal(SgRshiftAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRshiftAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRshiftAssignOp::pool_size * sizeof(SgRshiftAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRshiftAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRshiftAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18633 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaUnsignedRshiftAssignOp*  SgJavaUnsignedRshiftAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaUnsignedRshiftAssignOp* poolStart = reinterpret_cast<SgJavaUnsignedRshiftAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaUnsignedRshiftAssignOp::getNodeIdStringInternal(SgJavaUnsignedRshiftAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaUnsignedRshiftAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaUnsignedRshiftAssignOp::pool_size * sizeof(SgJavaUnsignedRshiftAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaUnsignedRshiftAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaUnsignedRshiftAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18670 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIntegerDivideAssignOp*  SgIntegerDivideAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIntegerDivideAssignOp* poolStart = reinterpret_cast<SgIntegerDivideAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIntegerDivideAssignOp::getNodeIdStringInternal(SgIntegerDivideAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIntegerDivideAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIntegerDivideAssignOp::pool_size * sizeof(SgIntegerDivideAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIntegerDivideAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIntegerDivideAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18707 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExponentiationAssignOp*  SgExponentiationAssignOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExponentiationAssignOp* poolStart = reinterpret_cast<SgExponentiationAssignOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExponentiationAssignOp::getNodeIdStringInternal(SgExponentiationAssignOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExponentiationAssignOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExponentiationAssignOp::pool_size * sizeof(SgExponentiationAssignOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExponentiationAssignOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExponentiationAssignOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18744 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMembershipOp*  SgMembershipOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMembershipOp* poolStart = reinterpret_cast<SgMembershipOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMembershipOp::getNodeIdStringInternal(SgMembershipOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMembershipOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMembershipOp::pool_size * sizeof(SgMembershipOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMembershipOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMembershipOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18781 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSpaceshipOp*  SgSpaceshipOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSpaceshipOp* poolStart = reinterpret_cast<SgSpaceshipOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSpaceshipOp::getNodeIdStringInternal(SgSpaceshipOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSpaceshipOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSpaceshipOp::pool_size * sizeof(SgSpaceshipOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSpaceshipOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSpaceshipOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18818 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNonMembershipOp*  SgNonMembershipOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNonMembershipOp* poolStart = reinterpret_cast<SgNonMembershipOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNonMembershipOp::getNodeIdStringInternal(SgNonMembershipOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNonMembershipOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNonMembershipOp::pool_size * sizeof(SgNonMembershipOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNonMembershipOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNonMembershipOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18855 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIsOp*  SgIsOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIsOp* poolStart = reinterpret_cast<SgIsOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIsOp::getNodeIdStringInternal(SgIsOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIsOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIsOp::pool_size * sizeof(SgIsOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIsOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIsOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18892 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIsNotOp*  SgIsNotOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIsNotOp* poolStart = reinterpret_cast<SgIsNotOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIsNotOp::getNodeIdStringInternal(SgIsNotOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIsNotOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIsNotOp::pool_size * sizeof(SgIsNotOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIsNotOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIsNotOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18929 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDotDotExp*  SgDotDotExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDotDotExp* poolStart = reinterpret_cast<SgDotDotExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDotDotExp::getNodeIdStringInternal(SgDotDotExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDotDotExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDotDotExp::pool_size * sizeof(SgDotDotExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDotDotExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDotDotExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 18966 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElementwiseOp*  SgElementwiseOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElementwiseOp* poolStart = reinterpret_cast<SgElementwiseOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElementwiseOp::getNodeIdStringInternal(SgElementwiseOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElementwiseOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElementwiseOp::pool_size * sizeof(SgElementwiseOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElementwiseOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElementwiseOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19003 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElementwiseMultiplyOp*  SgElementwiseMultiplyOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElementwiseMultiplyOp* poolStart = reinterpret_cast<SgElementwiseMultiplyOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElementwiseMultiplyOp::getNodeIdStringInternal(SgElementwiseMultiplyOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElementwiseMultiplyOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElementwiseMultiplyOp::pool_size * sizeof(SgElementwiseMultiplyOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElementwiseMultiplyOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElementwiseMultiplyOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19040 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElementwisePowerOp*  SgElementwisePowerOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElementwisePowerOp* poolStart = reinterpret_cast<SgElementwisePowerOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElementwisePowerOp::getNodeIdStringInternal(SgElementwisePowerOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElementwisePowerOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElementwisePowerOp::pool_size * sizeof(SgElementwisePowerOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElementwisePowerOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElementwisePowerOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19077 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElementwiseLeftDivideOp*  SgElementwiseLeftDivideOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElementwiseLeftDivideOp* poolStart = reinterpret_cast<SgElementwiseLeftDivideOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElementwiseLeftDivideOp::getNodeIdStringInternal(SgElementwiseLeftDivideOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElementwiseLeftDivideOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElementwiseLeftDivideOp::pool_size * sizeof(SgElementwiseLeftDivideOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElementwiseLeftDivideOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElementwiseLeftDivideOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19114 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElementwiseDivideOp*  SgElementwiseDivideOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElementwiseDivideOp* poolStart = reinterpret_cast<SgElementwiseDivideOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElementwiseDivideOp::getNodeIdStringInternal(SgElementwiseDivideOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElementwiseDivideOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElementwiseDivideOp::pool_size * sizeof(SgElementwiseDivideOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElementwiseDivideOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElementwiseDivideOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19151 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElementwiseAddOp*  SgElementwiseAddOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElementwiseAddOp* poolStart = reinterpret_cast<SgElementwiseAddOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElementwiseAddOp::getNodeIdStringInternal(SgElementwiseAddOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElementwiseAddOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElementwiseAddOp::pool_size * sizeof(SgElementwiseAddOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElementwiseAddOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElementwiseAddOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19188 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgElementwiseSubtractOp*  SgElementwiseSubtractOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgElementwiseSubtractOp* poolStart = reinterpret_cast<SgElementwiseSubtractOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgElementwiseSubtractOp::getNodeIdStringInternal(SgElementwiseSubtractOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgElementwiseSubtractOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgElementwiseSubtractOp::pool_size * sizeof(SgElementwiseSubtractOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgElementwiseSubtractOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgElementwiseSubtractOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19225 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPowerOp*  SgPowerOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPowerOp* poolStart = reinterpret_cast<SgPowerOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPowerOp::getNodeIdStringInternal(SgPowerOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPowerOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPowerOp::pool_size * sizeof(SgPowerOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPowerOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPowerOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19262 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLeftDivideOp*  SgLeftDivideOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLeftDivideOp* poolStart = reinterpret_cast<SgLeftDivideOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLeftDivideOp::getNodeIdStringInternal(SgLeftDivideOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLeftDivideOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLeftDivideOp::pool_size * sizeof(SgLeftDivideOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLeftDivideOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLeftDivideOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19299 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRemOp*  SgRemOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRemOp* poolStart = reinterpret_cast<SgRemOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRemOp::getNodeIdStringInternal(SgRemOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRemOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRemOp::pool_size * sizeof(SgRemOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRemOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRemOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19336 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgReplicationOp*  SgReplicationOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgReplicationOp* poolStart = reinterpret_cast<SgReplicationOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgReplicationOp::getNodeIdStringInternal(SgReplicationOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgReplicationOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgReplicationOp::pool_size * sizeof(SgReplicationOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgReplicationOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgReplicationOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19373 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAtOp*  SgAtOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAtOp* poolStart = reinterpret_cast<SgAtOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAtOp::getNodeIdStringInternal(SgAtOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAtOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAtOp::pool_size * sizeof(SgAtOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAtOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAtOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19410 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgExprListExp*  SgExprListExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgExprListExp* poolStart = reinterpret_cast<SgExprListExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgExprListExp::getNodeIdStringInternal(SgExprListExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgExprListExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgExprListExp::pool_size * sizeof(SgExprListExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgExprListExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgExprListExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19447 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgListExp*  SgListExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgListExp* poolStart = reinterpret_cast<SgListExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgListExp::getNodeIdStringInternal(SgListExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgListExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgListExp::pool_size * sizeof(SgListExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgListExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgListExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19484 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTupleExp*  SgTupleExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTupleExp* poolStart = reinterpret_cast<SgTupleExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTupleExp::getNodeIdStringInternal(SgTupleExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTupleExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTupleExp::pool_size * sizeof(SgTupleExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTupleExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTupleExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19521 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMatrixExp*  SgMatrixExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMatrixExp* poolStart = reinterpret_cast<SgMatrixExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMatrixExp::getNodeIdStringInternal(SgMatrixExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMatrixExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMatrixExp::pool_size * sizeof(SgMatrixExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMatrixExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMatrixExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19558 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgValueExp*  SgValueExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgValueExp* poolStart = reinterpret_cast<SgValueExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgValueExp::getNodeIdStringInternal(SgValueExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgValueExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgValueExp::pool_size * sizeof(SgValueExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgValueExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgValueExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19595 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBoolValExp*  SgBoolValExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBoolValExp* poolStart = reinterpret_cast<SgBoolValExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBoolValExp::getNodeIdStringInternal(SgBoolValExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBoolValExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBoolValExp::pool_size * sizeof(SgBoolValExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBoolValExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBoolValExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19632 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStringVal*  SgStringVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStringVal* poolStart = reinterpret_cast<SgStringVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStringVal::getNodeIdStringInternal(SgStringVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStringVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStringVal::pool_size * sizeof(SgStringVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStringVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStringVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19669 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgShortVal*  SgShortVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgShortVal* poolStart = reinterpret_cast<SgShortVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgShortVal::getNodeIdStringInternal(SgShortVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgShortVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgShortVal::pool_size * sizeof(SgShortVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgShortVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgShortVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19706 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCharVal*  SgCharVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCharVal* poolStart = reinterpret_cast<SgCharVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCharVal::getNodeIdStringInternal(SgCharVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCharVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCharVal::pool_size * sizeof(SgCharVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCharVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCharVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19743 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnsignedCharVal*  SgUnsignedCharVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnsignedCharVal* poolStart = reinterpret_cast<SgUnsignedCharVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnsignedCharVal::getNodeIdStringInternal(SgUnsignedCharVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnsignedCharVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnsignedCharVal::pool_size * sizeof(SgUnsignedCharVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnsignedCharVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnsignedCharVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19780 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgWcharVal*  SgWcharVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgWcharVal* poolStart = reinterpret_cast<SgWcharVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgWcharVal::getNodeIdStringInternal(SgWcharVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgWcharVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgWcharVal::pool_size * sizeof(SgWcharVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgWcharVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgWcharVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19817 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnsignedShortVal*  SgUnsignedShortVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnsignedShortVal* poolStart = reinterpret_cast<SgUnsignedShortVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnsignedShortVal::getNodeIdStringInternal(SgUnsignedShortVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnsignedShortVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnsignedShortVal::pool_size * sizeof(SgUnsignedShortVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnsignedShortVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnsignedShortVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19854 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIntVal*  SgIntVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIntVal* poolStart = reinterpret_cast<SgIntVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIntVal::getNodeIdStringInternal(SgIntVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIntVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIntVal::pool_size * sizeof(SgIntVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIntVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIntVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19891 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEnumVal*  SgEnumVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEnumVal* poolStart = reinterpret_cast<SgEnumVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEnumVal::getNodeIdStringInternal(SgEnumVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEnumVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEnumVal::pool_size * sizeof(SgEnumVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEnumVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEnumVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19928 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnsignedIntVal*  SgUnsignedIntVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnsignedIntVal* poolStart = reinterpret_cast<SgUnsignedIntVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnsignedIntVal::getNodeIdStringInternal(SgUnsignedIntVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnsignedIntVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnsignedIntVal::pool_size * sizeof(SgUnsignedIntVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnsignedIntVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnsignedIntVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 19965 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLongIntVal*  SgLongIntVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLongIntVal* poolStart = reinterpret_cast<SgLongIntVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLongIntVal::getNodeIdStringInternal(SgLongIntVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLongIntVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLongIntVal::pool_size * sizeof(SgLongIntVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLongIntVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLongIntVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20002 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLongLongIntVal*  SgLongLongIntVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLongLongIntVal* poolStart = reinterpret_cast<SgLongLongIntVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLongLongIntVal::getNodeIdStringInternal(SgLongLongIntVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLongLongIntVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLongLongIntVal::pool_size * sizeof(SgLongLongIntVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLongLongIntVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLongLongIntVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20039 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnsignedLongLongIntVal*  SgUnsignedLongLongIntVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnsignedLongLongIntVal* poolStart = reinterpret_cast<SgUnsignedLongLongIntVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnsignedLongLongIntVal::getNodeIdStringInternal(SgUnsignedLongLongIntVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnsignedLongLongIntVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnsignedLongLongIntVal::pool_size * sizeof(SgUnsignedLongLongIntVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnsignedLongLongIntVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnsignedLongLongIntVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20076 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnsignedLongVal*  SgUnsignedLongVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnsignedLongVal* poolStart = reinterpret_cast<SgUnsignedLongVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnsignedLongVal::getNodeIdStringInternal(SgUnsignedLongVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnsignedLongVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnsignedLongVal::pool_size * sizeof(SgUnsignedLongVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnsignedLongVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnsignedLongVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20113 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFloatVal*  SgFloatVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFloatVal* poolStart = reinterpret_cast<SgFloatVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFloatVal::getNodeIdStringInternal(SgFloatVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFloatVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFloatVal::pool_size * sizeof(SgFloatVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFloatVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFloatVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20150 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDoubleVal*  SgDoubleVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDoubleVal* poolStart = reinterpret_cast<SgDoubleVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDoubleVal::getNodeIdStringInternal(SgDoubleVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDoubleVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDoubleVal::pool_size * sizeof(SgDoubleVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDoubleVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDoubleVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20187 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLongDoubleVal*  SgLongDoubleVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLongDoubleVal* poolStart = reinterpret_cast<SgLongDoubleVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLongDoubleVal::getNodeIdStringInternal(SgLongDoubleVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLongDoubleVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLongDoubleVal::pool_size * sizeof(SgLongDoubleVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLongDoubleVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLongDoubleVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20224 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgComplexVal*  SgComplexVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgComplexVal* poolStart = reinterpret_cast<SgComplexVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgComplexVal::getNodeIdStringInternal(SgComplexVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgComplexVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgComplexVal::pool_size * sizeof(SgComplexVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgComplexVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgComplexVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20261 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcThreads*  SgUpcThreads::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcThreads* poolStart = reinterpret_cast<SgUpcThreads*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcThreads::getNodeIdStringInternal(SgUpcThreads* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcThreads* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcThreads::pool_size * sizeof(SgUpcThreads))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcThreads*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcThreads::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20298 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcMythread*  SgUpcMythread::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcMythread* poolStart = reinterpret_cast<SgUpcMythread*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcMythread::getNodeIdStringInternal(SgUpcMythread* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcMythread* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcMythread::pool_size * sizeof(SgUpcMythread))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcMythread*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcMythread::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20335 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateParameterVal*  SgTemplateParameterVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateParameterVal* poolStart = reinterpret_cast<SgTemplateParameterVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateParameterVal::getNodeIdStringInternal(SgTemplateParameterVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateParameterVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateParameterVal::pool_size * sizeof(SgTemplateParameterVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateParameterVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateParameterVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20372 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNullptrValExp*  SgNullptrValExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNullptrValExp* poolStart = reinterpret_cast<SgNullptrValExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNullptrValExp::getNodeIdStringInternal(SgNullptrValExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNullptrValExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNullptrValExp::pool_size * sizeof(SgNullptrValExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNullptrValExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNullptrValExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20409 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgChar16Val*  SgChar16Val::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgChar16Val* poolStart = reinterpret_cast<SgChar16Val*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgChar16Val::getNodeIdStringInternal(SgChar16Val* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgChar16Val* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgChar16Val::pool_size * sizeof(SgChar16Val))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgChar16Val*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgChar16Val::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20446 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgChar32Val*  SgChar32Val::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgChar32Val* poolStart = reinterpret_cast<SgChar32Val*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgChar32Val::getNodeIdStringInternal(SgChar32Val* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgChar32Val* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgChar32Val::pool_size * sizeof(SgChar32Val))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgChar32Val*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgChar32Val::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20483 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFloat80Val*  SgFloat80Val::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFloat80Val* poolStart = reinterpret_cast<SgFloat80Val*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFloat80Val::getNodeIdStringInternal(SgFloat80Val* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFloat80Val* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFloat80Val::pool_size * sizeof(SgFloat80Val))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFloat80Val*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFloat80Val::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20520 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFloat128Val*  SgFloat128Val::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFloat128Val* poolStart = reinterpret_cast<SgFloat128Val*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFloat128Val::getNodeIdStringInternal(SgFloat128Val* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFloat128Val* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFloat128Val::pool_size * sizeof(SgFloat128Val))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFloat128Val*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFloat128Val::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20557 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVoidVal*  SgVoidVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVoidVal* poolStart = reinterpret_cast<SgVoidVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVoidVal::getNodeIdStringInternal(SgVoidVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVoidVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVoidVal::pool_size * sizeof(SgVoidVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVoidVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVoidVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20594 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaFloatVal*  SgAdaFloatVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaFloatVal* poolStart = reinterpret_cast<SgAdaFloatVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaFloatVal::getNodeIdStringInternal(SgAdaFloatVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaFloatVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaFloatVal::pool_size * sizeof(SgAdaFloatVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaFloatVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaFloatVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20631 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSignedCharVal*  SgSignedCharVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSignedCharVal* poolStart = reinterpret_cast<SgSignedCharVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSignedCharVal::getNodeIdStringInternal(SgSignedCharVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSignedCharVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSignedCharVal::pool_size * sizeof(SgSignedCharVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSignedCharVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSignedCharVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20668 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialBitVal*  SgJovialBitVal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialBitVal* poolStart = reinterpret_cast<SgJovialBitVal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialBitVal::getNodeIdStringInternal(SgJovialBitVal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialBitVal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialBitVal::pool_size * sizeof(SgJovialBitVal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialBitVal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialBitVal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20705 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCallExpression*  SgCallExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCallExpression* poolStart = reinterpret_cast<SgCallExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCallExpression::getNodeIdStringInternal(SgCallExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCallExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCallExpression::pool_size * sizeof(SgCallExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCallExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCallExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20742 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionCallExp*  SgFunctionCallExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionCallExp* poolStart = reinterpret_cast<SgFunctionCallExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionCallExp::getNodeIdStringInternal(SgFunctionCallExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionCallExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionCallExp::pool_size * sizeof(SgFunctionCallExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionCallExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionCallExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20779 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCudaKernelCallExp*  SgCudaKernelCallExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCudaKernelCallExp* poolStart = reinterpret_cast<SgCudaKernelCallExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCudaKernelCallExp::getNodeIdStringInternal(SgCudaKernelCallExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCudaKernelCallExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCudaKernelCallExp::pool_size * sizeof(SgCudaKernelCallExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCudaKernelCallExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCudaKernelCallExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20816 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcLocalsizeofExpression*  SgUpcLocalsizeofExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcLocalsizeofExpression* poolStart = reinterpret_cast<SgUpcLocalsizeofExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcLocalsizeofExpression::getNodeIdStringInternal(SgUpcLocalsizeofExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcLocalsizeofExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcLocalsizeofExpression::pool_size * sizeof(SgUpcLocalsizeofExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcLocalsizeofExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcLocalsizeofExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20853 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcBlocksizeofExpression*  SgUpcBlocksizeofExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcBlocksizeofExpression* poolStart = reinterpret_cast<SgUpcBlocksizeofExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcBlocksizeofExpression::getNodeIdStringInternal(SgUpcBlocksizeofExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcBlocksizeofExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcBlocksizeofExpression::pool_size * sizeof(SgUpcBlocksizeofExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcBlocksizeofExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcBlocksizeofExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20890 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUpcElemsizeofExpression*  SgUpcElemsizeofExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUpcElemsizeofExpression* poolStart = reinterpret_cast<SgUpcElemsizeofExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUpcElemsizeofExpression::getNodeIdStringInternal(SgUpcElemsizeofExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUpcElemsizeofExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUpcElemsizeofExpression::pool_size * sizeof(SgUpcElemsizeofExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUpcElemsizeofExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUpcElemsizeofExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20927 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaInstanceOfOp*  SgJavaInstanceOfOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaInstanceOfOp* poolStart = reinterpret_cast<SgJavaInstanceOfOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaInstanceOfOp::getNodeIdStringInternal(SgJavaInstanceOfOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaInstanceOfOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaInstanceOfOp::pool_size * sizeof(SgJavaInstanceOfOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaInstanceOfOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaInstanceOfOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 20964 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSuperExp*  SgSuperExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSuperExp* poolStart = reinterpret_cast<SgSuperExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSuperExp::getNodeIdStringInternal(SgSuperExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSuperExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSuperExp::pool_size * sizeof(SgSuperExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSuperExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSuperExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21001 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeIdOp*  SgTypeIdOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeIdOp* poolStart = reinterpret_cast<SgTypeIdOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeIdOp::getNodeIdStringInternal(SgTypeIdOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeIdOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeIdOp::pool_size * sizeof(SgTypeIdOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeIdOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeIdOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21038 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgConditionalExp*  SgConditionalExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgConditionalExp* poolStart = reinterpret_cast<SgConditionalExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgConditionalExp::getNodeIdStringInternal(SgConditionalExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgConditionalExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgConditionalExp::pool_size * sizeof(SgConditionalExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgConditionalExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgConditionalExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21075 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNewExp*  SgNewExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNewExp* poolStart = reinterpret_cast<SgNewExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNewExp::getNodeIdStringInternal(SgNewExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNewExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNewExp::pool_size * sizeof(SgNewExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNewExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNewExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21112 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDeleteExp*  SgDeleteExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDeleteExp* poolStart = reinterpret_cast<SgDeleteExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDeleteExp::getNodeIdStringInternal(SgDeleteExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDeleteExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDeleteExp::pool_size * sizeof(SgDeleteExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDeleteExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDeleteExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21149 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgThisExp*  SgThisExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgThisExp* poolStart = reinterpret_cast<SgThisExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgThisExp::getNodeIdStringInternal(SgThisExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgThisExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgThisExp::pool_size * sizeof(SgThisExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgThisExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgThisExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21186 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRefExp*  SgRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRefExp* poolStart = reinterpret_cast<SgRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRefExp::getNodeIdStringInternal(SgRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRefExp::pool_size * sizeof(SgRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21223 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgInitializer*  SgInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgInitializer* poolStart = reinterpret_cast<SgInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgInitializer::getNodeIdStringInternal(SgInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgInitializer::pool_size * sizeof(SgInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21260 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAggregateInitializer*  SgAggregateInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAggregateInitializer* poolStart = reinterpret_cast<SgAggregateInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAggregateInitializer::getNodeIdStringInternal(SgAggregateInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAggregateInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAggregateInitializer::pool_size * sizeof(SgAggregateInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAggregateInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAggregateInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21297 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCompoundInitializer*  SgCompoundInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCompoundInitializer* poolStart = reinterpret_cast<SgCompoundInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCompoundInitializer::getNodeIdStringInternal(SgCompoundInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCompoundInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCompoundInitializer::pool_size * sizeof(SgCompoundInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCompoundInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCompoundInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21334 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgConstructorInitializer*  SgConstructorInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgConstructorInitializer* poolStart = reinterpret_cast<SgConstructorInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgConstructorInitializer::getNodeIdStringInternal(SgConstructorInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgConstructorInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgConstructorInitializer::pool_size * sizeof(SgConstructorInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgConstructorInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgConstructorInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21371 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAssignInitializer*  SgAssignInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAssignInitializer* poolStart = reinterpret_cast<SgAssignInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAssignInitializer::getNodeIdStringInternal(SgAssignInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAssignInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAssignInitializer::pool_size * sizeof(SgAssignInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAssignInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAssignInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21408 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDesignatedInitializer*  SgDesignatedInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDesignatedInitializer* poolStart = reinterpret_cast<SgDesignatedInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDesignatedInitializer::getNodeIdStringInternal(SgDesignatedInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDesignatedInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDesignatedInitializer::pool_size * sizeof(SgDesignatedInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDesignatedInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDesignatedInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21445 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgBracedInitializer*  SgBracedInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgBracedInitializer* poolStart = reinterpret_cast<SgBracedInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgBracedInitializer::getNodeIdStringInternal(SgBracedInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgBracedInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgBracedInitializer::pool_size * sizeof(SgBracedInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgBracedInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgBracedInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21482 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaAncestorInitializer*  SgAdaAncestorInitializer::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaAncestorInitializer* poolStart = reinterpret_cast<SgAdaAncestorInitializer*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaAncestorInitializer::getNodeIdStringInternal(SgAdaAncestorInitializer* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaAncestorInitializer* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaAncestorInitializer::pool_size * sizeof(SgAdaAncestorInitializer))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaAncestorInitializer*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaAncestorInitializer::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21519 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVarArgStartOp*  SgVarArgStartOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVarArgStartOp* poolStart = reinterpret_cast<SgVarArgStartOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVarArgStartOp::getNodeIdStringInternal(SgVarArgStartOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVarArgStartOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVarArgStartOp::pool_size * sizeof(SgVarArgStartOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVarArgStartOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVarArgStartOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21556 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVarArgOp*  SgVarArgOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVarArgOp* poolStart = reinterpret_cast<SgVarArgOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVarArgOp::getNodeIdStringInternal(SgVarArgOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVarArgOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVarArgOp::pool_size * sizeof(SgVarArgOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVarArgOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVarArgOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21593 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVarArgEndOp*  SgVarArgEndOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVarArgEndOp* poolStart = reinterpret_cast<SgVarArgEndOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVarArgEndOp::getNodeIdStringInternal(SgVarArgEndOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVarArgEndOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVarArgEndOp::pool_size * sizeof(SgVarArgEndOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVarArgEndOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVarArgEndOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21630 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVarArgCopyOp*  SgVarArgCopyOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVarArgCopyOp* poolStart = reinterpret_cast<SgVarArgCopyOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVarArgCopyOp::getNodeIdStringInternal(SgVarArgCopyOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVarArgCopyOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVarArgCopyOp::pool_size * sizeof(SgVarArgCopyOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVarArgCopyOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVarArgCopyOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21667 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVarArgStartOneOperandOp*  SgVarArgStartOneOperandOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVarArgStartOneOperandOp* poolStart = reinterpret_cast<SgVarArgStartOneOperandOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVarArgStartOneOperandOp::getNodeIdStringInternal(SgVarArgStartOneOperandOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVarArgStartOneOperandOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVarArgStartOneOperandOp::pool_size * sizeof(SgVarArgStartOneOperandOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVarArgStartOneOperandOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVarArgStartOneOperandOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21704 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNullExpression*  SgNullExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNullExpression* poolStart = reinterpret_cast<SgNullExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNullExpression::getNodeIdStringInternal(SgNullExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNullExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNullExpression::pool_size * sizeof(SgNullExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNullExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNullExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21741 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVariantExpression*  SgVariantExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVariantExpression* poolStart = reinterpret_cast<SgVariantExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVariantExpression::getNodeIdStringInternal(SgVariantExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVariantExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVariantExpression::pool_size * sizeof(SgVariantExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVariantExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVariantExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21778 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSubscriptExpression*  SgSubscriptExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSubscriptExpression* poolStart = reinterpret_cast<SgSubscriptExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSubscriptExpression::getNodeIdStringInternal(SgSubscriptExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSubscriptExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSubscriptExpression::pool_size * sizeof(SgSubscriptExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSubscriptExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSubscriptExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21815 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgColonShapeExp*  SgColonShapeExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgColonShapeExp* poolStart = reinterpret_cast<SgColonShapeExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgColonShapeExp::getNodeIdStringInternal(SgColonShapeExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgColonShapeExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgColonShapeExp::pool_size * sizeof(SgColonShapeExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgColonShapeExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgColonShapeExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21852 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsteriskShapeExp*  SgAsteriskShapeExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsteriskShapeExp* poolStart = reinterpret_cast<SgAsteriskShapeExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsteriskShapeExp::getNodeIdStringInternal(SgAsteriskShapeExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsteriskShapeExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsteriskShapeExp::pool_size * sizeof(SgAsteriskShapeExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsteriskShapeExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsteriskShapeExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21889 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgImpliedDo*  SgImpliedDo::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgImpliedDo* poolStart = reinterpret_cast<SgImpliedDo*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgImpliedDo::getNodeIdStringInternal(SgImpliedDo* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgImpliedDo* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgImpliedDo::pool_size * sizeof(SgImpliedDo))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgImpliedDo*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgImpliedDo::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21926 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIOItemExpression*  SgIOItemExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIOItemExpression* poolStart = reinterpret_cast<SgIOItemExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIOItemExpression::getNodeIdStringInternal(SgIOItemExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIOItemExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIOItemExpression::pool_size * sizeof(SgIOItemExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIOItemExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIOItemExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 21963 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgActualArgumentExpression*  SgActualArgumentExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgActualArgumentExpression* poolStart = reinterpret_cast<SgActualArgumentExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgActualArgumentExpression::getNodeIdStringInternal(SgActualArgumentExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgActualArgumentExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgActualArgumentExpression::pool_size * sizeof(SgActualArgumentExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgActualArgumentExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgActualArgumentExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22000 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStatementExpression*  SgStatementExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStatementExpression* poolStart = reinterpret_cast<SgStatementExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStatementExpression::getNodeIdStringInternal(SgStatementExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStatementExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStatementExpression::pool_size * sizeof(SgStatementExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStatementExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStatementExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22037 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmOp*  SgAsmOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmOp* poolStart = reinterpret_cast<SgAsmOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmOp::getNodeIdStringInternal(SgAsmOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmOp::pool_size * sizeof(SgAsmOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22074 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCudaKernelExecConfig*  SgCudaKernelExecConfig::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCudaKernelExecConfig* poolStart = reinterpret_cast<SgCudaKernelExecConfig*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCudaKernelExecConfig::getNodeIdStringInternal(SgCudaKernelExecConfig* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCudaKernelExecConfig* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCudaKernelExecConfig::pool_size * sizeof(SgCudaKernelExecConfig))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCudaKernelExecConfig*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCudaKernelExecConfig::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22111 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgUnknownArrayOrFunctionReference*  SgUnknownArrayOrFunctionReference::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgUnknownArrayOrFunctionReference* poolStart = reinterpret_cast<SgUnknownArrayOrFunctionReference*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgUnknownArrayOrFunctionReference::getNodeIdStringInternal(SgUnknownArrayOrFunctionReference* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgUnknownArrayOrFunctionReference* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgUnknownArrayOrFunctionReference::pool_size * sizeof(SgUnknownArrayOrFunctionReference))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgUnknownArrayOrFunctionReference*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgUnknownArrayOrFunctionReference::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22148 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgPseudoDestructorRefExp*  SgPseudoDestructorRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgPseudoDestructorRefExp* poolStart = reinterpret_cast<SgPseudoDestructorRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgPseudoDestructorRefExp::getNodeIdStringInternal(SgPseudoDestructorRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgPseudoDestructorRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgPseudoDestructorRefExp::pool_size * sizeof(SgPseudoDestructorRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgPseudoDestructorRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgPseudoDestructorRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22185 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCAFCoExpression*  SgCAFCoExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCAFCoExpression* poolStart = reinterpret_cast<SgCAFCoExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCAFCoExpression::getNodeIdStringInternal(SgCAFCoExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCAFCoExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCAFCoExpression::pool_size * sizeof(SgCAFCoExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCAFCoExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCAFCoExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22222 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSizeOfOp*  SgSizeOfOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSizeOfOp* poolStart = reinterpret_cast<SgSizeOfOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSizeOfOp::getNodeIdStringInternal(SgSizeOfOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSizeOfOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSizeOfOp::pool_size * sizeof(SgSizeOfOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSizeOfOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSizeOfOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22259 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLambdaRefExp*  SgLambdaRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLambdaRefExp* poolStart = reinterpret_cast<SgLambdaRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLambdaRefExp::getNodeIdStringInternal(SgLambdaRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLambdaRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLambdaRefExp::pool_size * sizeof(SgLambdaRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLambdaRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLambdaRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22296 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDictionaryExp*  SgDictionaryExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDictionaryExp* poolStart = reinterpret_cast<SgDictionaryExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDictionaryExp::getNodeIdStringInternal(SgDictionaryExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDictionaryExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDictionaryExp::pool_size * sizeof(SgDictionaryExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDictionaryExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDictionaryExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22333 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgKeyDatumPair*  SgKeyDatumPair::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgKeyDatumPair* poolStart = reinterpret_cast<SgKeyDatumPair*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgKeyDatumPair::getNodeIdStringInternal(SgKeyDatumPair* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgKeyDatumPair* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgKeyDatumPair::pool_size * sizeof(SgKeyDatumPair))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgKeyDatumPair*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgKeyDatumPair::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22370 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgReferenceExp*  SgReferenceExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgReferenceExp* poolStart = reinterpret_cast<SgReferenceExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgReferenceExp::getNodeIdStringInternal(SgReferenceExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgReferenceExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgReferenceExp::pool_size * sizeof(SgReferenceExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgReferenceExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgReferenceExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22407 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVarRefExp*  SgVarRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVarRefExp* poolStart = reinterpret_cast<SgVarRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVarRefExp::getNodeIdStringInternal(SgVarRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVarRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVarRefExp::pool_size * sizeof(SgVarRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVarRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVarRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22444 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLabelRefExp*  SgLabelRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLabelRefExp* poolStart = reinterpret_cast<SgLabelRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLabelRefExp::getNodeIdStringInternal(SgLabelRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLabelRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLabelRefExp::pool_size * sizeof(SgLabelRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLabelRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLabelRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22481 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClassNameRefExp*  SgClassNameRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClassNameRefExp* poolStart = reinterpret_cast<SgClassNameRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClassNameRefExp::getNodeIdStringInternal(SgClassNameRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClassNameRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClassNameRefExp::pool_size * sizeof(SgClassNameRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClassNameRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClassNameRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22518 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNonrealRefExp*  SgNonrealRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNonrealRefExp* poolStart = reinterpret_cast<SgNonrealRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNonrealRefExp::getNodeIdStringInternal(SgNonrealRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNonrealRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNonrealRefExp::pool_size * sizeof(SgNonrealRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNonrealRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNonrealRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22555 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgScopedRefExp*  SgScopedRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgScopedRefExp* poolStart = reinterpret_cast<SgScopedRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgScopedRefExp::getNodeIdStringInternal(SgScopedRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgScopedRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgScopedRefExp::pool_size * sizeof(SgScopedRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgScopedRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgScopedRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22592 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeRefExp*  SgTypeRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeRefExp* poolStart = reinterpret_cast<SgTypeRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeRefExp::getNodeIdStringInternal(SgTypeRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeRefExp::pool_size * sizeof(SgTypeRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22629 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionRefExp*  SgFunctionRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionRefExp* poolStart = reinterpret_cast<SgFunctionRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionRefExp::getNodeIdStringInternal(SgFunctionRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionRefExp::pool_size * sizeof(SgFunctionRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22666 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMemberFunctionRefExp*  SgMemberFunctionRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMemberFunctionRefExp* poolStart = reinterpret_cast<SgMemberFunctionRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMemberFunctionRefExp::getNodeIdStringInternal(SgMemberFunctionRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMemberFunctionRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMemberFunctionRefExp::pool_size * sizeof(SgMemberFunctionRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMemberFunctionRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMemberFunctionRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22703 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateFunctionRefExp*  SgTemplateFunctionRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateFunctionRefExp* poolStart = reinterpret_cast<SgTemplateFunctionRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateFunctionRefExp::getNodeIdStringInternal(SgTemplateFunctionRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateFunctionRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateFunctionRefExp::pool_size * sizeof(SgTemplateFunctionRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateFunctionRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateFunctionRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22740 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateMemberFunctionRefExp*  SgTemplateMemberFunctionRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateMemberFunctionRefExp* poolStart = reinterpret_cast<SgTemplateMemberFunctionRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateMemberFunctionRefExp::getNodeIdStringInternal(SgTemplateMemberFunctionRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateMemberFunctionRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateMemberFunctionRefExp::pool_size * sizeof(SgTemplateMemberFunctionRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateMemberFunctionRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateMemberFunctionRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22777 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgComprehension*  SgComprehension::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgComprehension* poolStart = reinterpret_cast<SgComprehension*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgComprehension::getNodeIdStringInternal(SgComprehension* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgComprehension* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgComprehension::pool_size * sizeof(SgComprehension))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgComprehension*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgComprehension::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22814 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgListComprehension*  SgListComprehension::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgListComprehension* poolStart = reinterpret_cast<SgListComprehension*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgListComprehension::getNodeIdStringInternal(SgListComprehension* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgListComprehension* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgListComprehension::pool_size * sizeof(SgListComprehension))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgListComprehension*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgListComprehension::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22851 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSetComprehension*  SgSetComprehension::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSetComprehension* poolStart = reinterpret_cast<SgSetComprehension*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSetComprehension::getNodeIdStringInternal(SgSetComprehension* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSetComprehension* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSetComprehension::pool_size * sizeof(SgSetComprehension))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSetComprehension*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSetComprehension::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22888 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDictionaryComprehension*  SgDictionaryComprehension::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDictionaryComprehension* poolStart = reinterpret_cast<SgDictionaryComprehension*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDictionaryComprehension::getNodeIdStringInternal(SgDictionaryComprehension* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDictionaryComprehension* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDictionaryComprehension::pool_size * sizeof(SgDictionaryComprehension))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDictionaryComprehension*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDictionaryComprehension::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22925 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNaryOp*  SgNaryOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNaryOp* poolStart = reinterpret_cast<SgNaryOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNaryOp::getNodeIdStringInternal(SgNaryOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNaryOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNaryOp::pool_size * sizeof(SgNaryOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNaryOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNaryOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22962 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNaryBooleanOp*  SgNaryBooleanOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNaryBooleanOp* poolStart = reinterpret_cast<SgNaryBooleanOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNaryBooleanOp::getNodeIdStringInternal(SgNaryBooleanOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNaryBooleanOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNaryBooleanOp::pool_size * sizeof(SgNaryBooleanOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNaryBooleanOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNaryBooleanOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 22999 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNaryComparisonOp*  SgNaryComparisonOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNaryComparisonOp* poolStart = reinterpret_cast<SgNaryComparisonOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNaryComparisonOp::getNodeIdStringInternal(SgNaryComparisonOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNaryComparisonOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNaryComparisonOp::pool_size * sizeof(SgNaryComparisonOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNaryComparisonOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNaryComparisonOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23036 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgStringConversion*  SgStringConversion::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgStringConversion* poolStart = reinterpret_cast<SgStringConversion*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgStringConversion::getNodeIdStringInternal(SgStringConversion* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgStringConversion* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgStringConversion::pool_size * sizeof(SgStringConversion))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgStringConversion*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgStringConversion::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23073 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgYieldExpression*  SgYieldExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgYieldExpression* poolStart = reinterpret_cast<SgYieldExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgYieldExpression::getNodeIdStringInternal(SgYieldExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgYieldExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgYieldExpression::pool_size * sizeof(SgYieldExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgYieldExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgYieldExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23110 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAlignOfOp*  SgAlignOfOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAlignOfOp* poolStart = reinterpret_cast<SgAlignOfOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAlignOfOp::getNodeIdStringInternal(SgAlignOfOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAlignOfOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAlignOfOp::pool_size * sizeof(SgAlignOfOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAlignOfOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAlignOfOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23147 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRangeExp*  SgRangeExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRangeExp* poolStart = reinterpret_cast<SgRangeExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRangeExp::getNodeIdStringInternal(SgRangeExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRangeExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRangeExp::pool_size * sizeof(SgRangeExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRangeExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRangeExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23184 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMagicColonExp*  SgMagicColonExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMagicColonExp* poolStart = reinterpret_cast<SgMagicColonExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMagicColonExp::getNodeIdStringInternal(SgMagicColonExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMagicColonExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMagicColonExp::pool_size * sizeof(SgMagicColonExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMagicColonExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMagicColonExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23221 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeTraitBuiltinOperator*  SgTypeTraitBuiltinOperator::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeTraitBuiltinOperator* poolStart = reinterpret_cast<SgTypeTraitBuiltinOperator*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeTraitBuiltinOperator::getNodeIdStringInternal(SgTypeTraitBuiltinOperator* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeTraitBuiltinOperator* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeTraitBuiltinOperator::pool_size * sizeof(SgTypeTraitBuiltinOperator))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeTraitBuiltinOperator*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeTraitBuiltinOperator::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23258 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCompoundLiteralExp*  SgCompoundLiteralExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCompoundLiteralExp* poolStart = reinterpret_cast<SgCompoundLiteralExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCompoundLiteralExp::getNodeIdStringInternal(SgCompoundLiteralExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCompoundLiteralExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCompoundLiteralExp::pool_size * sizeof(SgCompoundLiteralExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCompoundLiteralExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCompoundLiteralExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23295 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaAnnotation*  SgJavaAnnotation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaAnnotation* poolStart = reinterpret_cast<SgJavaAnnotation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaAnnotation::getNodeIdStringInternal(SgJavaAnnotation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaAnnotation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaAnnotation::pool_size * sizeof(SgJavaAnnotation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaAnnotation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaAnnotation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23332 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaMarkerAnnotation*  SgJavaMarkerAnnotation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaMarkerAnnotation* poolStart = reinterpret_cast<SgJavaMarkerAnnotation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaMarkerAnnotation::getNodeIdStringInternal(SgJavaMarkerAnnotation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaMarkerAnnotation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaMarkerAnnotation::pool_size * sizeof(SgJavaMarkerAnnotation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaMarkerAnnotation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaMarkerAnnotation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23369 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaSingleMemberAnnotation*  SgJavaSingleMemberAnnotation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaSingleMemberAnnotation* poolStart = reinterpret_cast<SgJavaSingleMemberAnnotation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaSingleMemberAnnotation::getNodeIdStringInternal(SgJavaSingleMemberAnnotation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaSingleMemberAnnotation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaSingleMemberAnnotation::pool_size * sizeof(SgJavaSingleMemberAnnotation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaSingleMemberAnnotation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaSingleMemberAnnotation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23406 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaNormalAnnotation*  SgJavaNormalAnnotation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaNormalAnnotation* poolStart = reinterpret_cast<SgJavaNormalAnnotation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaNormalAnnotation::getNodeIdStringInternal(SgJavaNormalAnnotation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaNormalAnnotation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaNormalAnnotation::pool_size * sizeof(SgJavaNormalAnnotation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaNormalAnnotation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaNormalAnnotation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23443 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaTypeExpression*  SgJavaTypeExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaTypeExpression* poolStart = reinterpret_cast<SgJavaTypeExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaTypeExpression::getNodeIdStringInternal(SgJavaTypeExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaTypeExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaTypeExpression::pool_size * sizeof(SgJavaTypeExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaTypeExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaTypeExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23480 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeExpression*  SgTypeExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeExpression* poolStart = reinterpret_cast<SgTypeExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeExpression::getNodeIdStringInternal(SgTypeExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeExpression::pool_size * sizeof(SgTypeExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23517 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClassExp*  SgClassExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClassExp* poolStart = reinterpret_cast<SgClassExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClassExp::getNodeIdStringInternal(SgClassExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClassExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClassExp::pool_size * sizeof(SgClassExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClassExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClassExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23554 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionParameterRefExp*  SgFunctionParameterRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionParameterRefExp* poolStart = reinterpret_cast<SgFunctionParameterRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionParameterRefExp::getNodeIdStringInternal(SgFunctionParameterRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionParameterRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionParameterRefExp::pool_size * sizeof(SgFunctionParameterRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionParameterRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionParameterRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23591 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLambdaExp*  SgLambdaExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLambdaExp* poolStart = reinterpret_cast<SgLambdaExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLambdaExp::getNodeIdStringInternal(SgLambdaExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLambdaExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLambdaExp::pool_size * sizeof(SgLambdaExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLambdaExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLambdaExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23628 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgHereExp*  SgHereExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgHereExp* poolStart = reinterpret_cast<SgHereExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgHereExp::getNodeIdStringInternal(SgHereExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgHereExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgHereExp::pool_size * sizeof(SgHereExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgHereExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgHereExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23665 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAtExp*  SgAtExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAtExp* poolStart = reinterpret_cast<SgAtExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAtExp::getNodeIdStringInternal(SgAtExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAtExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAtExp::pool_size * sizeof(SgAtExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAtExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAtExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23702 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFinishExp*  SgFinishExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFinishExp* poolStart = reinterpret_cast<SgFinishExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFinishExp::getNodeIdStringInternal(SgFinishExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFinishExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFinishExp::pool_size * sizeof(SgFinishExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFinishExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFinishExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23739 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNoexceptOp*  SgNoexceptOp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNoexceptOp* poolStart = reinterpret_cast<SgNoexceptOp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNoexceptOp::getNodeIdStringInternal(SgNoexceptOp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNoexceptOp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNoexceptOp::pool_size * sizeof(SgNoexceptOp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNoexceptOp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNoexceptOp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23776 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskRefExp*  SgAdaTaskRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskRefExp* poolStart = reinterpret_cast<SgAdaTaskRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskRefExp::getNodeIdStringInternal(SgAdaTaskRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskRefExp::pool_size * sizeof(SgAdaTaskRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23813 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedRefExp*  SgAdaProtectedRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedRefExp* poolStart = reinterpret_cast<SgAdaProtectedRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedRefExp::getNodeIdStringInternal(SgAdaProtectedRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedRefExp::pool_size * sizeof(SgAdaProtectedRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23850 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFoldExpression*  SgFoldExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFoldExpression* poolStart = reinterpret_cast<SgFoldExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFoldExpression::getNodeIdStringInternal(SgFoldExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFoldExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFoldExpression::pool_size * sizeof(SgFoldExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFoldExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFoldExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23887 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAwaitExpression*  SgAwaitExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAwaitExpression* poolStart = reinterpret_cast<SgAwaitExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAwaitExpression::getNodeIdStringInternal(SgAwaitExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAwaitExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAwaitExpression::pool_size * sizeof(SgAwaitExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAwaitExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAwaitExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23924 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgChooseExpression*  SgChooseExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgChooseExpression* poolStart = reinterpret_cast<SgChooseExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgChooseExpression::getNodeIdStringInternal(SgChooseExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgChooseExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgChooseExpression::pool_size * sizeof(SgChooseExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgChooseExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgChooseExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23961 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaAttributeExp*  SgAdaAttributeExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaAttributeExp* poolStart = reinterpret_cast<SgAdaAttributeExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaAttributeExp::getNodeIdStringInternal(SgAdaAttributeExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaAttributeExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaAttributeExp::pool_size * sizeof(SgAdaAttributeExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaAttributeExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaAttributeExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 23998 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialTablePresetExp*  SgJovialTablePresetExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialTablePresetExp* poolStart = reinterpret_cast<SgJovialTablePresetExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialTablePresetExp::getNodeIdStringInternal(SgJovialTablePresetExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialTablePresetExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialTablePresetExp::pool_size * sizeof(SgJovialTablePresetExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialTablePresetExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialTablePresetExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24035 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJovialPresetPositionExp*  SgJovialPresetPositionExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJovialPresetPositionExp* poolStart = reinterpret_cast<SgJovialPresetPositionExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJovialPresetPositionExp::getNodeIdStringInternal(SgJovialPresetPositionExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJovialPresetPositionExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJovialPresetPositionExp::pool_size * sizeof(SgJovialPresetPositionExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJovialPresetPositionExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJovialPresetPositionExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24072 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaOthersExp*  SgAdaOthersExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaOthersExp* poolStart = reinterpret_cast<SgAdaOthersExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaOthersExp::getNodeIdStringInternal(SgAdaOthersExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaOthersExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaOthersExp::pool_size * sizeof(SgAdaOthersExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaOthersExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaOthersExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24109 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaRenamingRefExp*  SgAdaRenamingRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaRenamingRefExp* poolStart = reinterpret_cast<SgAdaRenamingRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaRenamingRefExp::getNodeIdStringInternal(SgAdaRenamingRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaRenamingRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaRenamingRefExp::pool_size * sizeof(SgAdaRenamingRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaRenamingRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaRenamingRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24146 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaUnitRefExp*  SgAdaUnitRefExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaUnitRefExp* poolStart = reinterpret_cast<SgAdaUnitRefExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaUnitRefExp::getNodeIdStringInternal(SgAdaUnitRefExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaUnitRefExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaUnitRefExp::pool_size * sizeof(SgAdaUnitRefExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaUnitRefExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaUnitRefExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24183 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgSymbol*  SgSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgSymbol* poolStart = reinterpret_cast<SgSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgSymbol::getNodeIdStringInternal(SgSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgSymbol::pool_size * sizeof(SgSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24220 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgVariableSymbol*  SgVariableSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgVariableSymbol* poolStart = reinterpret_cast<SgVariableSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgVariableSymbol::getNodeIdStringInternal(SgVariableSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgVariableSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgVariableSymbol::pool_size * sizeof(SgVariableSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgVariableSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgVariableSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24257 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateVariableSymbol*  SgTemplateVariableSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateVariableSymbol* poolStart = reinterpret_cast<SgTemplateVariableSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateVariableSymbol::getNodeIdStringInternal(SgTemplateVariableSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateVariableSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateVariableSymbol::pool_size * sizeof(SgTemplateVariableSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateVariableSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateVariableSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24294 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNonrealSymbol*  SgNonrealSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNonrealSymbol* poolStart = reinterpret_cast<SgNonrealSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNonrealSymbol::getNodeIdStringInternal(SgNonrealSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNonrealSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNonrealSymbol::pool_size * sizeof(SgNonrealSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNonrealSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNonrealSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24331 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionSymbol*  SgFunctionSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionSymbol* poolStart = reinterpret_cast<SgFunctionSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionSymbol::getNodeIdStringInternal(SgFunctionSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionSymbol::pool_size * sizeof(SgFunctionSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24368 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgMemberFunctionSymbol*  SgMemberFunctionSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgMemberFunctionSymbol* poolStart = reinterpret_cast<SgMemberFunctionSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgMemberFunctionSymbol::getNodeIdStringInternal(SgMemberFunctionSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgMemberFunctionSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgMemberFunctionSymbol::pool_size * sizeof(SgMemberFunctionSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgMemberFunctionSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgMemberFunctionSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24405 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateMemberFunctionSymbol*  SgTemplateMemberFunctionSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateMemberFunctionSymbol* poolStart = reinterpret_cast<SgTemplateMemberFunctionSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateMemberFunctionSymbol::getNodeIdStringInternal(SgTemplateMemberFunctionSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateMemberFunctionSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateMemberFunctionSymbol::pool_size * sizeof(SgTemplateMemberFunctionSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateMemberFunctionSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateMemberFunctionSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24442 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateFunctionSymbol*  SgTemplateFunctionSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateFunctionSymbol* poolStart = reinterpret_cast<SgTemplateFunctionSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateFunctionSymbol::getNodeIdStringInternal(SgTemplateFunctionSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateFunctionSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateFunctionSymbol::pool_size * sizeof(SgTemplateFunctionSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateFunctionSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateFunctionSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24479 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgRenameSymbol*  SgRenameSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgRenameSymbol* poolStart = reinterpret_cast<SgRenameSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgRenameSymbol::getNodeIdStringInternal(SgRenameSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgRenameSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgRenameSymbol::pool_size * sizeof(SgRenameSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgRenameSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgRenameSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24516 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaInheritedFunctionSymbol*  SgAdaInheritedFunctionSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaInheritedFunctionSymbol* poolStart = reinterpret_cast<SgAdaInheritedFunctionSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaInheritedFunctionSymbol::getNodeIdStringInternal(SgAdaInheritedFunctionSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaInheritedFunctionSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaInheritedFunctionSymbol::pool_size * sizeof(SgAdaInheritedFunctionSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaInheritedFunctionSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaInheritedFunctionSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24553 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgFunctionTypeSymbol*  SgFunctionTypeSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgFunctionTypeSymbol* poolStart = reinterpret_cast<SgFunctionTypeSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgFunctionTypeSymbol::getNodeIdStringInternal(SgFunctionTypeSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgFunctionTypeSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgFunctionTypeSymbol::pool_size * sizeof(SgFunctionTypeSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgFunctionTypeSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgFunctionTypeSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24590 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateSymbol*  SgTemplateSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateSymbol* poolStart = reinterpret_cast<SgTemplateSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateSymbol::getNodeIdStringInternal(SgTemplateSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateSymbol::pool_size * sizeof(SgTemplateSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24627 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEnumFieldSymbol*  SgEnumFieldSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEnumFieldSymbol* poolStart = reinterpret_cast<SgEnumFieldSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEnumFieldSymbol::getNodeIdStringInternal(SgEnumFieldSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEnumFieldSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEnumFieldSymbol::pool_size * sizeof(SgEnumFieldSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEnumFieldSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEnumFieldSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24664 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypeSymbol*  SgTypeSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypeSymbol* poolStart = reinterpret_cast<SgTypeSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypeSymbol::getNodeIdStringInternal(SgTypeSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypeSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypeSymbol::pool_size * sizeof(SgTypeSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypeSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypeSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24701 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgClassSymbol*  SgClassSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgClassSymbol* poolStart = reinterpret_cast<SgClassSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgClassSymbol::getNodeIdStringInternal(SgClassSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgClassSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgClassSymbol::pool_size * sizeof(SgClassSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgClassSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgClassSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24738 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateClassSymbol*  SgTemplateClassSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateClassSymbol* poolStart = reinterpret_cast<SgTemplateClassSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateClassSymbol::getNodeIdStringInternal(SgTemplateClassSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateClassSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateClassSymbol::pool_size * sizeof(SgTemplateClassSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateClassSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateClassSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24775 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTypedefSymbol*  SgTypedefSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTypedefSymbol* poolStart = reinterpret_cast<SgTypedefSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTypedefSymbol::getNodeIdStringInternal(SgTypedefSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTypedefSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTypedefSymbol::pool_size * sizeof(SgTypedefSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTypedefSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTypedefSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24812 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgTemplateTypedefSymbol*  SgTemplateTypedefSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgTemplateTypedefSymbol* poolStart = reinterpret_cast<SgTemplateTypedefSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgTemplateTypedefSymbol::getNodeIdStringInternal(SgTemplateTypedefSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgTemplateTypedefSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgTemplateTypedefSymbol::pool_size * sizeof(SgTemplateTypedefSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgTemplateTypedefSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgTemplateTypedefSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24849 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgEnumSymbol*  SgEnumSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgEnumSymbol* poolStart = reinterpret_cast<SgEnumSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgEnumSymbol::getNodeIdStringInternal(SgEnumSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgEnumSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgEnumSymbol::pool_size * sizeof(SgEnumSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgEnumSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgEnumSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24886 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgLabelSymbol*  SgLabelSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgLabelSymbol* poolStart = reinterpret_cast<SgLabelSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgLabelSymbol::getNodeIdStringInternal(SgLabelSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgLabelSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgLabelSymbol::pool_size * sizeof(SgLabelSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgLabelSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgLabelSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24923 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgDefaultSymbol*  SgDefaultSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgDefaultSymbol* poolStart = reinterpret_cast<SgDefaultSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgDefaultSymbol::getNodeIdStringInternal(SgDefaultSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgDefaultSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgDefaultSymbol::pool_size * sizeof(SgDefaultSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgDefaultSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgDefaultSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24960 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgNamespaceSymbol*  SgNamespaceSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgNamespaceSymbol* poolStart = reinterpret_cast<SgNamespaceSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgNamespaceSymbol::getNodeIdStringInternal(SgNamespaceSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgNamespaceSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgNamespaceSymbol::pool_size * sizeof(SgNamespaceSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgNamespaceSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgNamespaceSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 24997 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgIntrinsicSymbol*  SgIntrinsicSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgIntrinsicSymbol* poolStart = reinterpret_cast<SgIntrinsicSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgIntrinsicSymbol::getNodeIdStringInternal(SgIntrinsicSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgIntrinsicSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgIntrinsicSymbol::pool_size * sizeof(SgIntrinsicSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgIntrinsicSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgIntrinsicSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25034 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgModuleSymbol*  SgModuleSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgModuleSymbol* poolStart = reinterpret_cast<SgModuleSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgModuleSymbol::getNodeIdStringInternal(SgModuleSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgModuleSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgModuleSymbol::pool_size * sizeof(SgModuleSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgModuleSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgModuleSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25071 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgInterfaceSymbol*  SgInterfaceSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgInterfaceSymbol* poolStart = reinterpret_cast<SgInterfaceSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgInterfaceSymbol::getNodeIdStringInternal(SgInterfaceSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgInterfaceSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgInterfaceSymbol::pool_size * sizeof(SgInterfaceSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgInterfaceSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgInterfaceSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25108 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgCommonSymbol*  SgCommonSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgCommonSymbol* poolStart = reinterpret_cast<SgCommonSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgCommonSymbol::getNodeIdStringInternal(SgCommonSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgCommonSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgCommonSymbol::pool_size * sizeof(SgCommonSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgCommonSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgCommonSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25145 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAliasSymbol*  SgAliasSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAliasSymbol* poolStart = reinterpret_cast<SgAliasSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAliasSymbol::getNodeIdStringInternal(SgAliasSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAliasSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAliasSymbol::pool_size * sizeof(SgAliasSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAliasSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAliasSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25182 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryAddressSymbol*  SgAsmBinaryAddressSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryAddressSymbol* poolStart = reinterpret_cast<SgAsmBinaryAddressSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryAddressSymbol::getNodeIdStringInternal(SgAsmBinaryAddressSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryAddressSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryAddressSymbol::pool_size * sizeof(SgAsmBinaryAddressSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryAddressSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryAddressSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25219 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryDataSymbol*  SgAsmBinaryDataSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryDataSymbol* poolStart = reinterpret_cast<SgAsmBinaryDataSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryDataSymbol::getNodeIdStringInternal(SgAsmBinaryDataSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryDataSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryDataSymbol::pool_size * sizeof(SgAsmBinaryDataSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryDataSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryDataSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25256 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgJavaLabelSymbol*  SgJavaLabelSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgJavaLabelSymbol* poolStart = reinterpret_cast<SgJavaLabelSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgJavaLabelSymbol::getNodeIdStringInternal(SgJavaLabelSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgJavaLabelSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgJavaLabelSymbol::pool_size * sizeof(SgJavaLabelSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgJavaLabelSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgJavaLabelSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25293 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaPackageSymbol*  SgAdaPackageSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaPackageSymbol* poolStart = reinterpret_cast<SgAdaPackageSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaPackageSymbol::getNodeIdStringInternal(SgAdaPackageSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaPackageSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaPackageSymbol::pool_size * sizeof(SgAdaPackageSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaPackageSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaPackageSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25330 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaTaskSymbol*  SgAdaTaskSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaTaskSymbol* poolStart = reinterpret_cast<SgAdaTaskSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaTaskSymbol::getNodeIdStringInternal(SgAdaTaskSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaTaskSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaTaskSymbol::pool_size * sizeof(SgAdaTaskSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaTaskSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaTaskSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25367 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaProtectedSymbol*  SgAdaProtectedSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaProtectedSymbol* poolStart = reinterpret_cast<SgAdaProtectedSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaProtectedSymbol::getNodeIdStringInternal(SgAdaProtectedSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaProtectedSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaProtectedSymbol::pool_size * sizeof(SgAdaProtectedSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaProtectedSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaProtectedSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25404 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaRenamingSymbol*  SgAdaRenamingSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaRenamingSymbol* poolStart = reinterpret_cast<SgAdaRenamingSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaRenamingSymbol::getNodeIdStringInternal(SgAdaRenamingSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaRenamingSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaRenamingSymbol::pool_size * sizeof(SgAdaRenamingSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaRenamingSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaRenamingSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25441 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaGenericSymbol*  SgAdaGenericSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaGenericSymbol* poolStart = reinterpret_cast<SgAdaGenericSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaGenericSymbol::getNodeIdStringInternal(SgAdaGenericSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaGenericSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaGenericSymbol::pool_size * sizeof(SgAdaGenericSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaGenericSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaGenericSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25478 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaGenericInstanceSymbol*  SgAdaGenericInstanceSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaGenericInstanceSymbol* poolStart = reinterpret_cast<SgAdaGenericInstanceSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaGenericInstanceSymbol::getNodeIdStringInternal(SgAdaGenericInstanceSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaGenericInstanceSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaGenericInstanceSymbol::pool_size * sizeof(SgAdaGenericInstanceSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaGenericInstanceSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaGenericInstanceSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25515 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAdaFormalPackageSymbol*  SgAdaFormalPackageSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAdaFormalPackageSymbol* poolStart = reinterpret_cast<SgAdaFormalPackageSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAdaFormalPackageSymbol::getNodeIdStringInternal(SgAdaFormalPackageSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAdaFormalPackageSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAdaFormalPackageSymbol::pool_size * sizeof(SgAdaFormalPackageSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAdaFormalPackageSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAdaFormalPackageSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25552 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNode*  SgAsmNode::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNode* poolStart = reinterpret_cast<SgAsmNode*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNode::getNodeIdStringInternal(SgAsmNode* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNode* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNode::pool_size * sizeof(SgAsmNode))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNode*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNode::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25589 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilNode*  SgAsmCilNode::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilNode* poolStart = reinterpret_cast<SgAsmCilNode*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilNode::getNodeIdStringInternal(SgAsmCilNode* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilNode* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilNode::pool_size * sizeof(SgAsmCilNode))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilNode*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilNode::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25626 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilDataStream*  SgAsmCilDataStream::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilDataStream* poolStart = reinterpret_cast<SgAsmCilDataStream*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilDataStream::getNodeIdStringInternal(SgAsmCilDataStream* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilDataStream* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilDataStream::pool_size * sizeof(SgAsmCilDataStream))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilDataStream*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilDataStream::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25663 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilErrorHeap*  SgAsmCilErrorHeap::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilErrorHeap* poolStart = reinterpret_cast<SgAsmCilErrorHeap*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilErrorHeap::getNodeIdStringInternal(SgAsmCilErrorHeap* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilErrorHeap* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilErrorHeap::pool_size * sizeof(SgAsmCilErrorHeap))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilErrorHeap*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilErrorHeap::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25700 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMetadataHeap*  SgAsmCilMetadataHeap::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMetadataHeap* poolStart = reinterpret_cast<SgAsmCilMetadataHeap*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMetadataHeap::getNodeIdStringInternal(SgAsmCilMetadataHeap* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMetadataHeap* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMetadataHeap::pool_size * sizeof(SgAsmCilMetadataHeap))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMetadataHeap*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMetadataHeap::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25737 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilUint32Heap*  SgAsmCilUint32Heap::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilUint32Heap* poolStart = reinterpret_cast<SgAsmCilUint32Heap*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilUint32Heap::getNodeIdStringInternal(SgAsmCilUint32Heap* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilUint32Heap* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilUint32Heap::pool_size * sizeof(SgAsmCilUint32Heap))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilUint32Heap*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilUint32Heap::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25774 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilUint8Heap*  SgAsmCilUint8Heap::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilUint8Heap* poolStart = reinterpret_cast<SgAsmCilUint8Heap*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilUint8Heap::getNodeIdStringInternal(SgAsmCilUint8Heap* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilUint8Heap* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilUint8Heap::pool_size * sizeof(SgAsmCilUint8Heap))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilUint8Heap*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilUint8Heap::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25811 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilExceptionData*  SgAsmCilExceptionData::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilExceptionData* poolStart = reinterpret_cast<SgAsmCilExceptionData*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilExceptionData::getNodeIdStringInternal(SgAsmCilExceptionData* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilExceptionData* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilExceptionData::pool_size * sizeof(SgAsmCilExceptionData))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilExceptionData*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilExceptionData::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25848 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMetadata*  SgAsmCilMetadata::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMetadata* poolStart = reinterpret_cast<SgAsmCilMetadata*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMetadata::getNodeIdStringInternal(SgAsmCilMetadata* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMetadata* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMetadata::pool_size * sizeof(SgAsmCilMetadata))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMetadata*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMetadata::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25885 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssembly*  SgAsmCilAssembly::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssembly* poolStart = reinterpret_cast<SgAsmCilAssembly*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssembly::getNodeIdStringInternal(SgAsmCilAssembly* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssembly* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssembly::pool_size * sizeof(SgAsmCilAssembly))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssembly*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssembly::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25922 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyOS*  SgAsmCilAssemblyOS::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyOS* poolStart = reinterpret_cast<SgAsmCilAssemblyOS*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyOS::getNodeIdStringInternal(SgAsmCilAssemblyOS* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyOS* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyOS::pool_size * sizeof(SgAsmCilAssemblyOS))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyOS*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyOS::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25959 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyOSTable*  SgAsmCilAssemblyOSTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyOSTable* poolStart = reinterpret_cast<SgAsmCilAssemblyOSTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyOSTable::getNodeIdStringInternal(SgAsmCilAssemblyOSTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyOSTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyOSTable::pool_size * sizeof(SgAsmCilAssemblyOSTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyOSTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyOSTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 25996 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyProcessor*  SgAsmCilAssemblyProcessor::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyProcessor* poolStart = reinterpret_cast<SgAsmCilAssemblyProcessor*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyProcessor::getNodeIdStringInternal(SgAsmCilAssemblyProcessor* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyProcessor* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyProcessor::pool_size * sizeof(SgAsmCilAssemblyProcessor))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyProcessor*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyProcessor::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26033 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyProcessorTable*  SgAsmCilAssemblyProcessorTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyProcessorTable* poolStart = reinterpret_cast<SgAsmCilAssemblyProcessorTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyProcessorTable::getNodeIdStringInternal(SgAsmCilAssemblyProcessorTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyProcessorTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyProcessorTable::pool_size * sizeof(SgAsmCilAssemblyProcessorTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyProcessorTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyProcessorTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26070 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyRef*  SgAsmCilAssemblyRef::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyRef* poolStart = reinterpret_cast<SgAsmCilAssemblyRef*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyRef::getNodeIdStringInternal(SgAsmCilAssemblyRef* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyRef* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyRef::pool_size * sizeof(SgAsmCilAssemblyRef))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyRef*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyRef::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26107 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyRefOS*  SgAsmCilAssemblyRefOS::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyRefOS* poolStart = reinterpret_cast<SgAsmCilAssemblyRefOS*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyRefOS::getNodeIdStringInternal(SgAsmCilAssemblyRefOS* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyRefOS* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyRefOS::pool_size * sizeof(SgAsmCilAssemblyRefOS))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyRefOS*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyRefOS::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26144 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyRefOSTable*  SgAsmCilAssemblyRefOSTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyRefOSTable* poolStart = reinterpret_cast<SgAsmCilAssemblyRefOSTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyRefOSTable::getNodeIdStringInternal(SgAsmCilAssemblyRefOSTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyRefOSTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyRefOSTable::pool_size * sizeof(SgAsmCilAssemblyRefOSTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyRefOSTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyRefOSTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26181 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyRefProcessor*  SgAsmCilAssemblyRefProcessor::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyRefProcessor* poolStart = reinterpret_cast<SgAsmCilAssemblyRefProcessor*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyRefProcessor::getNodeIdStringInternal(SgAsmCilAssemblyRefProcessor* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyRefProcessor* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyRefProcessor::pool_size * sizeof(SgAsmCilAssemblyRefProcessor))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyRefProcessor*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyRefProcessor::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26218 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyRefProcessorTable*  SgAsmCilAssemblyRefProcessorTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyRefProcessorTable* poolStart = reinterpret_cast<SgAsmCilAssemblyRefProcessorTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyRefProcessorTable::getNodeIdStringInternal(SgAsmCilAssemblyRefProcessorTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyRefProcessorTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyRefProcessorTable::pool_size * sizeof(SgAsmCilAssemblyRefProcessorTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyRefProcessorTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyRefProcessorTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26255 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyRefTable*  SgAsmCilAssemblyRefTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyRefTable* poolStart = reinterpret_cast<SgAsmCilAssemblyRefTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyRefTable::getNodeIdStringInternal(SgAsmCilAssemblyRefTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyRefTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyRefTable::pool_size * sizeof(SgAsmCilAssemblyRefTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyRefTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyRefTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26292 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilAssemblyTable*  SgAsmCilAssemblyTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilAssemblyTable* poolStart = reinterpret_cast<SgAsmCilAssemblyTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilAssemblyTable::getNodeIdStringInternal(SgAsmCilAssemblyTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilAssemblyTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilAssemblyTable::pool_size * sizeof(SgAsmCilAssemblyTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilAssemblyTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilAssemblyTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26329 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilClassLayout*  SgAsmCilClassLayout::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilClassLayout* poolStart = reinterpret_cast<SgAsmCilClassLayout*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilClassLayout::getNodeIdStringInternal(SgAsmCilClassLayout* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilClassLayout* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilClassLayout::pool_size * sizeof(SgAsmCilClassLayout))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilClassLayout*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilClassLayout::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26366 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilClassLayoutTable*  SgAsmCilClassLayoutTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilClassLayoutTable* poolStart = reinterpret_cast<SgAsmCilClassLayoutTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilClassLayoutTable::getNodeIdStringInternal(SgAsmCilClassLayoutTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilClassLayoutTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilClassLayoutTable::pool_size * sizeof(SgAsmCilClassLayoutTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilClassLayoutTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilClassLayoutTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26403 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilConstant*  SgAsmCilConstant::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilConstant* poolStart = reinterpret_cast<SgAsmCilConstant*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilConstant::getNodeIdStringInternal(SgAsmCilConstant* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilConstant* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilConstant::pool_size * sizeof(SgAsmCilConstant))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilConstant*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilConstant::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26440 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilConstantTable*  SgAsmCilConstantTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilConstantTable* poolStart = reinterpret_cast<SgAsmCilConstantTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilConstantTable::getNodeIdStringInternal(SgAsmCilConstantTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilConstantTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilConstantTable::pool_size * sizeof(SgAsmCilConstantTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilConstantTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilConstantTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26477 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilCustomAttribute*  SgAsmCilCustomAttribute::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilCustomAttribute* poolStart = reinterpret_cast<SgAsmCilCustomAttribute*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilCustomAttribute::getNodeIdStringInternal(SgAsmCilCustomAttribute* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilCustomAttribute* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilCustomAttribute::pool_size * sizeof(SgAsmCilCustomAttribute))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilCustomAttribute*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilCustomAttribute::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26514 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilCustomAttributeTable*  SgAsmCilCustomAttributeTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilCustomAttributeTable* poolStart = reinterpret_cast<SgAsmCilCustomAttributeTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilCustomAttributeTable::getNodeIdStringInternal(SgAsmCilCustomAttributeTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilCustomAttributeTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilCustomAttributeTable::pool_size * sizeof(SgAsmCilCustomAttributeTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilCustomAttributeTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilCustomAttributeTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26551 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilDeclSecurity*  SgAsmCilDeclSecurity::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilDeclSecurity* poolStart = reinterpret_cast<SgAsmCilDeclSecurity*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilDeclSecurity::getNodeIdStringInternal(SgAsmCilDeclSecurity* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilDeclSecurity* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilDeclSecurity::pool_size * sizeof(SgAsmCilDeclSecurity))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilDeclSecurity*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilDeclSecurity::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26588 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilDeclSecurityTable*  SgAsmCilDeclSecurityTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilDeclSecurityTable* poolStart = reinterpret_cast<SgAsmCilDeclSecurityTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilDeclSecurityTable::getNodeIdStringInternal(SgAsmCilDeclSecurityTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilDeclSecurityTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilDeclSecurityTable::pool_size * sizeof(SgAsmCilDeclSecurityTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilDeclSecurityTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilDeclSecurityTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26625 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilEvent*  SgAsmCilEvent::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilEvent* poolStart = reinterpret_cast<SgAsmCilEvent*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilEvent::getNodeIdStringInternal(SgAsmCilEvent* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilEvent* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilEvent::pool_size * sizeof(SgAsmCilEvent))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilEvent*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilEvent::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26662 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilEventMap*  SgAsmCilEventMap::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilEventMap* poolStart = reinterpret_cast<SgAsmCilEventMap*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilEventMap::getNodeIdStringInternal(SgAsmCilEventMap* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilEventMap* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilEventMap::pool_size * sizeof(SgAsmCilEventMap))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilEventMap*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilEventMap::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26699 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilEventMapTable*  SgAsmCilEventMapTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilEventMapTable* poolStart = reinterpret_cast<SgAsmCilEventMapTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilEventMapTable::getNodeIdStringInternal(SgAsmCilEventMapTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilEventMapTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilEventMapTable::pool_size * sizeof(SgAsmCilEventMapTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilEventMapTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilEventMapTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26736 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilEventTable*  SgAsmCilEventTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilEventTable* poolStart = reinterpret_cast<SgAsmCilEventTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilEventTable::getNodeIdStringInternal(SgAsmCilEventTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilEventTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilEventTable::pool_size * sizeof(SgAsmCilEventTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilEventTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilEventTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26773 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilExportedType*  SgAsmCilExportedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilExportedType* poolStart = reinterpret_cast<SgAsmCilExportedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilExportedType::getNodeIdStringInternal(SgAsmCilExportedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilExportedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilExportedType::pool_size * sizeof(SgAsmCilExportedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilExportedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilExportedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26810 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilExportedTypeTable*  SgAsmCilExportedTypeTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilExportedTypeTable* poolStart = reinterpret_cast<SgAsmCilExportedTypeTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilExportedTypeTable::getNodeIdStringInternal(SgAsmCilExportedTypeTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilExportedTypeTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilExportedTypeTable::pool_size * sizeof(SgAsmCilExportedTypeTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilExportedTypeTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilExportedTypeTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26847 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilField*  SgAsmCilField::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilField* poolStart = reinterpret_cast<SgAsmCilField*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilField::getNodeIdStringInternal(SgAsmCilField* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilField* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilField::pool_size * sizeof(SgAsmCilField))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilField*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilField::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26884 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFieldLayout*  SgAsmCilFieldLayout::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFieldLayout* poolStart = reinterpret_cast<SgAsmCilFieldLayout*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFieldLayout::getNodeIdStringInternal(SgAsmCilFieldLayout* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFieldLayout* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFieldLayout::pool_size * sizeof(SgAsmCilFieldLayout))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFieldLayout*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFieldLayout::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26921 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFieldLayoutTable*  SgAsmCilFieldLayoutTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFieldLayoutTable* poolStart = reinterpret_cast<SgAsmCilFieldLayoutTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFieldLayoutTable::getNodeIdStringInternal(SgAsmCilFieldLayoutTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFieldLayoutTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFieldLayoutTable::pool_size * sizeof(SgAsmCilFieldLayoutTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFieldLayoutTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFieldLayoutTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26958 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFieldMarshal*  SgAsmCilFieldMarshal::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFieldMarshal* poolStart = reinterpret_cast<SgAsmCilFieldMarshal*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFieldMarshal::getNodeIdStringInternal(SgAsmCilFieldMarshal* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFieldMarshal* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFieldMarshal::pool_size * sizeof(SgAsmCilFieldMarshal))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFieldMarshal*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFieldMarshal::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 26995 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFieldMarshalTable*  SgAsmCilFieldMarshalTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFieldMarshalTable* poolStart = reinterpret_cast<SgAsmCilFieldMarshalTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFieldMarshalTable::getNodeIdStringInternal(SgAsmCilFieldMarshalTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFieldMarshalTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFieldMarshalTable::pool_size * sizeof(SgAsmCilFieldMarshalTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFieldMarshalTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFieldMarshalTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27032 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFieldRVA*  SgAsmCilFieldRVA::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFieldRVA* poolStart = reinterpret_cast<SgAsmCilFieldRVA*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFieldRVA::getNodeIdStringInternal(SgAsmCilFieldRVA* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFieldRVA* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFieldRVA::pool_size * sizeof(SgAsmCilFieldRVA))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFieldRVA*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFieldRVA::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27069 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFieldRVATable*  SgAsmCilFieldRVATable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFieldRVATable* poolStart = reinterpret_cast<SgAsmCilFieldRVATable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFieldRVATable::getNodeIdStringInternal(SgAsmCilFieldRVATable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFieldRVATable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFieldRVATable::pool_size * sizeof(SgAsmCilFieldRVATable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFieldRVATable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFieldRVATable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27106 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFieldTable*  SgAsmCilFieldTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFieldTable* poolStart = reinterpret_cast<SgAsmCilFieldTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFieldTable::getNodeIdStringInternal(SgAsmCilFieldTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFieldTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFieldTable::pool_size * sizeof(SgAsmCilFieldTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFieldTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFieldTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27143 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFile*  SgAsmCilFile::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFile* poolStart = reinterpret_cast<SgAsmCilFile*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFile::getNodeIdStringInternal(SgAsmCilFile* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFile* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFile::pool_size * sizeof(SgAsmCilFile))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFile*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFile::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27180 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilFileTable*  SgAsmCilFileTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilFileTable* poolStart = reinterpret_cast<SgAsmCilFileTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilFileTable::getNodeIdStringInternal(SgAsmCilFileTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilFileTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilFileTable::pool_size * sizeof(SgAsmCilFileTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilFileTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilFileTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27217 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilGenericParamConstraint*  SgAsmCilGenericParamConstraint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilGenericParamConstraint* poolStart = reinterpret_cast<SgAsmCilGenericParamConstraint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilGenericParamConstraint::getNodeIdStringInternal(SgAsmCilGenericParamConstraint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilGenericParamConstraint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilGenericParamConstraint::pool_size * sizeof(SgAsmCilGenericParamConstraint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilGenericParamConstraint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilGenericParamConstraint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27254 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilGenericParamConstraintTable*  SgAsmCilGenericParamConstraintTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilGenericParamConstraintTable* poolStart = reinterpret_cast<SgAsmCilGenericParamConstraintTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilGenericParamConstraintTable::getNodeIdStringInternal(SgAsmCilGenericParamConstraintTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilGenericParamConstraintTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilGenericParamConstraintTable::pool_size * sizeof(SgAsmCilGenericParamConstraintTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilGenericParamConstraintTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilGenericParamConstraintTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27291 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilGenericParam*  SgAsmCilGenericParam::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilGenericParam* poolStart = reinterpret_cast<SgAsmCilGenericParam*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilGenericParam::getNodeIdStringInternal(SgAsmCilGenericParam* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilGenericParam* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilGenericParam::pool_size * sizeof(SgAsmCilGenericParam))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilGenericParam*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilGenericParam::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27328 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilGenericParamTable*  SgAsmCilGenericParamTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilGenericParamTable* poolStart = reinterpret_cast<SgAsmCilGenericParamTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilGenericParamTable::getNodeIdStringInternal(SgAsmCilGenericParamTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilGenericParamTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilGenericParamTable::pool_size * sizeof(SgAsmCilGenericParamTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilGenericParamTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilGenericParamTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27365 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilImplMap*  SgAsmCilImplMap::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilImplMap* poolStart = reinterpret_cast<SgAsmCilImplMap*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilImplMap::getNodeIdStringInternal(SgAsmCilImplMap* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilImplMap* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilImplMap::pool_size * sizeof(SgAsmCilImplMap))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilImplMap*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilImplMap::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27402 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilImplMapTable*  SgAsmCilImplMapTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilImplMapTable* poolStart = reinterpret_cast<SgAsmCilImplMapTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilImplMapTable::getNodeIdStringInternal(SgAsmCilImplMapTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilImplMapTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilImplMapTable::pool_size * sizeof(SgAsmCilImplMapTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilImplMapTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilImplMapTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27439 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilInterfaceImpl*  SgAsmCilInterfaceImpl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilInterfaceImpl* poolStart = reinterpret_cast<SgAsmCilInterfaceImpl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilInterfaceImpl::getNodeIdStringInternal(SgAsmCilInterfaceImpl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilInterfaceImpl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilInterfaceImpl::pool_size * sizeof(SgAsmCilInterfaceImpl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilInterfaceImpl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilInterfaceImpl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27476 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilInterfaceImplTable*  SgAsmCilInterfaceImplTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilInterfaceImplTable* poolStart = reinterpret_cast<SgAsmCilInterfaceImplTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilInterfaceImplTable::getNodeIdStringInternal(SgAsmCilInterfaceImplTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilInterfaceImplTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilInterfaceImplTable::pool_size * sizeof(SgAsmCilInterfaceImplTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilInterfaceImplTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilInterfaceImplTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27513 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilManifestResource*  SgAsmCilManifestResource::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilManifestResource* poolStart = reinterpret_cast<SgAsmCilManifestResource*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilManifestResource::getNodeIdStringInternal(SgAsmCilManifestResource* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilManifestResource* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilManifestResource::pool_size * sizeof(SgAsmCilManifestResource))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilManifestResource*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilManifestResource::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27550 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilManifestResourceTable*  SgAsmCilManifestResourceTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilManifestResourceTable* poolStart = reinterpret_cast<SgAsmCilManifestResourceTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilManifestResourceTable::getNodeIdStringInternal(SgAsmCilManifestResourceTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilManifestResourceTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilManifestResourceTable::pool_size * sizeof(SgAsmCilManifestResourceTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilManifestResourceTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilManifestResourceTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27587 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMemberRef*  SgAsmCilMemberRef::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMemberRef* poolStart = reinterpret_cast<SgAsmCilMemberRef*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMemberRef::getNodeIdStringInternal(SgAsmCilMemberRef* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMemberRef* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMemberRef::pool_size * sizeof(SgAsmCilMemberRef))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMemberRef*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMemberRef::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27624 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMemberRefTable*  SgAsmCilMemberRefTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMemberRefTable* poolStart = reinterpret_cast<SgAsmCilMemberRefTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMemberRefTable::getNodeIdStringInternal(SgAsmCilMemberRefTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMemberRefTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMemberRefTable::pool_size * sizeof(SgAsmCilMemberRefTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMemberRefTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMemberRefTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27661 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodDef*  SgAsmCilMethodDef::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodDef* poolStart = reinterpret_cast<SgAsmCilMethodDef*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodDef::getNodeIdStringInternal(SgAsmCilMethodDef* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodDef* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodDef::pool_size * sizeof(SgAsmCilMethodDef))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodDef*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodDef::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27698 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodDefTable*  SgAsmCilMethodDefTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodDefTable* poolStart = reinterpret_cast<SgAsmCilMethodDefTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodDefTable::getNodeIdStringInternal(SgAsmCilMethodDefTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodDefTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodDefTable::pool_size * sizeof(SgAsmCilMethodDefTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodDefTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodDefTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27735 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodImpl*  SgAsmCilMethodImpl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodImpl* poolStart = reinterpret_cast<SgAsmCilMethodImpl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodImpl::getNodeIdStringInternal(SgAsmCilMethodImpl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodImpl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodImpl::pool_size * sizeof(SgAsmCilMethodImpl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodImpl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodImpl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27772 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodImplTable*  SgAsmCilMethodImplTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodImplTable* poolStart = reinterpret_cast<SgAsmCilMethodImplTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodImplTable::getNodeIdStringInternal(SgAsmCilMethodImplTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodImplTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodImplTable::pool_size * sizeof(SgAsmCilMethodImplTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodImplTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodImplTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27809 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodSemantics*  SgAsmCilMethodSemantics::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodSemantics* poolStart = reinterpret_cast<SgAsmCilMethodSemantics*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodSemantics::getNodeIdStringInternal(SgAsmCilMethodSemantics* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodSemantics* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodSemantics::pool_size * sizeof(SgAsmCilMethodSemantics))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodSemantics*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodSemantics::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27846 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodSemanticsTable*  SgAsmCilMethodSemanticsTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodSemanticsTable* poolStart = reinterpret_cast<SgAsmCilMethodSemanticsTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodSemanticsTable::getNodeIdStringInternal(SgAsmCilMethodSemanticsTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodSemanticsTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodSemanticsTable::pool_size * sizeof(SgAsmCilMethodSemanticsTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodSemanticsTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodSemanticsTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27883 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodSpec*  SgAsmCilMethodSpec::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodSpec* poolStart = reinterpret_cast<SgAsmCilMethodSpec*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodSpec::getNodeIdStringInternal(SgAsmCilMethodSpec* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodSpec* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodSpec::pool_size * sizeof(SgAsmCilMethodSpec))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodSpec*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodSpec::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27920 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodSpecTable*  SgAsmCilMethodSpecTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodSpecTable* poolStart = reinterpret_cast<SgAsmCilMethodSpecTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodSpecTable::getNodeIdStringInternal(SgAsmCilMethodSpecTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodSpecTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodSpecTable::pool_size * sizeof(SgAsmCilMethodSpecTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodSpecTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodSpecTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27957 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilModule*  SgAsmCilModule::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilModule* poolStart = reinterpret_cast<SgAsmCilModule*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilModule::getNodeIdStringInternal(SgAsmCilModule* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilModule* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilModule::pool_size * sizeof(SgAsmCilModule))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilModule*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilModule::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 27994 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilModuleRef*  SgAsmCilModuleRef::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilModuleRef* poolStart = reinterpret_cast<SgAsmCilModuleRef*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilModuleRef::getNodeIdStringInternal(SgAsmCilModuleRef* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilModuleRef* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilModuleRef::pool_size * sizeof(SgAsmCilModuleRef))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilModuleRef*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilModuleRef::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28031 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilModuleRefTable*  SgAsmCilModuleRefTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilModuleRefTable* poolStart = reinterpret_cast<SgAsmCilModuleRefTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilModuleRefTable::getNodeIdStringInternal(SgAsmCilModuleRefTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilModuleRefTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilModuleRefTable::pool_size * sizeof(SgAsmCilModuleRefTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilModuleRefTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilModuleRefTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28068 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilModuleTable*  SgAsmCilModuleTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilModuleTable* poolStart = reinterpret_cast<SgAsmCilModuleTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilModuleTable::getNodeIdStringInternal(SgAsmCilModuleTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilModuleTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilModuleTable::pool_size * sizeof(SgAsmCilModuleTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilModuleTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilModuleTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28105 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilNestedClass*  SgAsmCilNestedClass::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilNestedClass* poolStart = reinterpret_cast<SgAsmCilNestedClass*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilNestedClass::getNodeIdStringInternal(SgAsmCilNestedClass* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilNestedClass* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilNestedClass::pool_size * sizeof(SgAsmCilNestedClass))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilNestedClass*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilNestedClass::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28142 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilNestedClassTable*  SgAsmCilNestedClassTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilNestedClassTable* poolStart = reinterpret_cast<SgAsmCilNestedClassTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilNestedClassTable::getNodeIdStringInternal(SgAsmCilNestedClassTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilNestedClassTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilNestedClassTable::pool_size * sizeof(SgAsmCilNestedClassTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilNestedClassTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilNestedClassTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28179 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilParam*  SgAsmCilParam::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilParam* poolStart = reinterpret_cast<SgAsmCilParam*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilParam::getNodeIdStringInternal(SgAsmCilParam* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilParam* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilParam::pool_size * sizeof(SgAsmCilParam))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilParam*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilParam::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28216 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilParamTable*  SgAsmCilParamTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilParamTable* poolStart = reinterpret_cast<SgAsmCilParamTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilParamTable::getNodeIdStringInternal(SgAsmCilParamTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilParamTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilParamTable::pool_size * sizeof(SgAsmCilParamTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilParamTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilParamTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28253 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilProperty*  SgAsmCilProperty::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilProperty* poolStart = reinterpret_cast<SgAsmCilProperty*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilProperty::getNodeIdStringInternal(SgAsmCilProperty* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilProperty* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilProperty::pool_size * sizeof(SgAsmCilProperty))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilProperty*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilProperty::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28290 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilPropertyMap*  SgAsmCilPropertyMap::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilPropertyMap* poolStart = reinterpret_cast<SgAsmCilPropertyMap*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilPropertyMap::getNodeIdStringInternal(SgAsmCilPropertyMap* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilPropertyMap* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilPropertyMap::pool_size * sizeof(SgAsmCilPropertyMap))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilPropertyMap*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilPropertyMap::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28327 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilPropertyMapTable*  SgAsmCilPropertyMapTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilPropertyMapTable* poolStart = reinterpret_cast<SgAsmCilPropertyMapTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilPropertyMapTable::getNodeIdStringInternal(SgAsmCilPropertyMapTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilPropertyMapTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilPropertyMapTable::pool_size * sizeof(SgAsmCilPropertyMapTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilPropertyMapTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilPropertyMapTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28364 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilPropertyTable*  SgAsmCilPropertyTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilPropertyTable* poolStart = reinterpret_cast<SgAsmCilPropertyTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilPropertyTable::getNodeIdStringInternal(SgAsmCilPropertyTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilPropertyTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilPropertyTable::pool_size * sizeof(SgAsmCilPropertyTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilPropertyTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilPropertyTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28401 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilStandAloneSig*  SgAsmCilStandAloneSig::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilStandAloneSig* poolStart = reinterpret_cast<SgAsmCilStandAloneSig*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilStandAloneSig::getNodeIdStringInternal(SgAsmCilStandAloneSig* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilStandAloneSig* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilStandAloneSig::pool_size * sizeof(SgAsmCilStandAloneSig))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilStandAloneSig*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilStandAloneSig::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28438 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilStandAloneSigTable*  SgAsmCilStandAloneSigTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilStandAloneSigTable* poolStart = reinterpret_cast<SgAsmCilStandAloneSigTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilStandAloneSigTable::getNodeIdStringInternal(SgAsmCilStandAloneSigTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilStandAloneSigTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilStandAloneSigTable::pool_size * sizeof(SgAsmCilStandAloneSigTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilStandAloneSigTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilStandAloneSigTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28475 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilTypeDef*  SgAsmCilTypeDef::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilTypeDef* poolStart = reinterpret_cast<SgAsmCilTypeDef*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilTypeDef::getNodeIdStringInternal(SgAsmCilTypeDef* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilTypeDef* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilTypeDef::pool_size * sizeof(SgAsmCilTypeDef))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilTypeDef*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilTypeDef::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28512 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilTypeDefTable*  SgAsmCilTypeDefTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilTypeDefTable* poolStart = reinterpret_cast<SgAsmCilTypeDefTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilTypeDefTable::getNodeIdStringInternal(SgAsmCilTypeDefTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilTypeDefTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilTypeDefTable::pool_size * sizeof(SgAsmCilTypeDefTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilTypeDefTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilTypeDefTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28549 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilTypeRef*  SgAsmCilTypeRef::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilTypeRef* poolStart = reinterpret_cast<SgAsmCilTypeRef*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilTypeRef::getNodeIdStringInternal(SgAsmCilTypeRef* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilTypeRef* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilTypeRef::pool_size * sizeof(SgAsmCilTypeRef))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilTypeRef*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilTypeRef::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28586 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilTypeRefTable*  SgAsmCilTypeRefTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilTypeRefTable* poolStart = reinterpret_cast<SgAsmCilTypeRefTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilTypeRefTable::getNodeIdStringInternal(SgAsmCilTypeRefTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilTypeRefTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilTypeRefTable::pool_size * sizeof(SgAsmCilTypeRefTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilTypeRefTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilTypeRefTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28623 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilTypeSpec*  SgAsmCilTypeSpec::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilTypeSpec* poolStart = reinterpret_cast<SgAsmCilTypeSpec*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilTypeSpec::getNodeIdStringInternal(SgAsmCilTypeSpec* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilTypeSpec* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilTypeSpec::pool_size * sizeof(SgAsmCilTypeSpec))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilTypeSpec*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilTypeSpec::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28660 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilTypeSpecTable*  SgAsmCilTypeSpecTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilTypeSpecTable* poolStart = reinterpret_cast<SgAsmCilTypeSpecTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilTypeSpecTable::getNodeIdStringInternal(SgAsmCilTypeSpecTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilTypeSpecTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilTypeSpecTable::pool_size * sizeof(SgAsmCilTypeSpecTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilTypeSpecTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilTypeSpecTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28697 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMetadataRoot*  SgAsmCilMetadataRoot::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMetadataRoot* poolStart = reinterpret_cast<SgAsmCilMetadataRoot*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMetadataRoot::getNodeIdStringInternal(SgAsmCilMetadataRoot* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMetadataRoot* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMetadataRoot::pool_size * sizeof(SgAsmCilMetadataRoot))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMetadataRoot*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMetadataRoot::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28734 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilMethodData*  SgAsmCilMethodData::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilMethodData* poolStart = reinterpret_cast<SgAsmCilMethodData*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilMethodData::getNodeIdStringInternal(SgAsmCilMethodData* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilMethodData* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilMethodData::pool_size * sizeof(SgAsmCilMethodData))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilMethodData*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilMethodData::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28771 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmExecutableFileFormat*  SgAsmExecutableFileFormat::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmExecutableFileFormat* poolStart = reinterpret_cast<SgAsmExecutableFileFormat*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmExecutableFileFormat::getNodeIdStringInternal(SgAsmExecutableFileFormat* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmExecutableFileFormat* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmExecutableFileFormat::pool_size * sizeof(SgAsmExecutableFileFormat))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmExecutableFileFormat*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmExecutableFileFormat::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28808 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCoffSymbolList*  SgAsmCoffSymbolList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCoffSymbolList* poolStart = reinterpret_cast<SgAsmCoffSymbolList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCoffSymbolList::getNodeIdStringInternal(SgAsmCoffSymbolList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCoffSymbolList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCoffSymbolList::pool_size * sizeof(SgAsmCoffSymbolList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCoffSymbolList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCoffSymbolList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28845 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfInformation*  SgAsmDwarfInformation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfInformation* poolStart = reinterpret_cast<SgAsmDwarfInformation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfInformation::getNodeIdStringInternal(SgAsmDwarfInformation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfInformation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfInformation::pool_size * sizeof(SgAsmDwarfInformation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfInformation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfInformation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28882 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfCompilationUnitList*  SgAsmDwarfCompilationUnitList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfCompilationUnitList* poolStart = reinterpret_cast<SgAsmDwarfCompilationUnitList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfCompilationUnitList::getNodeIdStringInternal(SgAsmDwarfCompilationUnitList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfCompilationUnitList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfCompilationUnitList::pool_size * sizeof(SgAsmDwarfCompilationUnitList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfCompilationUnitList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfCompilationUnitList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28919 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfConstruct*  SgAsmDwarfConstruct::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfConstruct* poolStart = reinterpret_cast<SgAsmDwarfConstruct*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfConstruct::getNodeIdStringInternal(SgAsmDwarfConstruct* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfConstruct* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfConstruct::pool_size * sizeof(SgAsmDwarfConstruct))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfConstruct*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfConstruct::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28956 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfAccessDeclaration*  SgAsmDwarfAccessDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfAccessDeclaration* poolStart = reinterpret_cast<SgAsmDwarfAccessDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfAccessDeclaration::getNodeIdStringInternal(SgAsmDwarfAccessDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfAccessDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfAccessDeclaration::pool_size * sizeof(SgAsmDwarfAccessDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfAccessDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfAccessDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 28993 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfArrayType*  SgAsmDwarfArrayType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfArrayType* poolStart = reinterpret_cast<SgAsmDwarfArrayType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfArrayType::getNodeIdStringInternal(SgAsmDwarfArrayType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfArrayType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfArrayType::pool_size * sizeof(SgAsmDwarfArrayType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfArrayType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfArrayType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29030 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfBaseType*  SgAsmDwarfBaseType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfBaseType* poolStart = reinterpret_cast<SgAsmDwarfBaseType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfBaseType::getNodeIdStringInternal(SgAsmDwarfBaseType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfBaseType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfBaseType::pool_size * sizeof(SgAsmDwarfBaseType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfBaseType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfBaseType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29067 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfCatchBlock*  SgAsmDwarfCatchBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfCatchBlock* poolStart = reinterpret_cast<SgAsmDwarfCatchBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfCatchBlock::getNodeIdStringInternal(SgAsmDwarfCatchBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfCatchBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfCatchBlock::pool_size * sizeof(SgAsmDwarfCatchBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfCatchBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfCatchBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29104 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfClassTemplate*  SgAsmDwarfClassTemplate::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfClassTemplate* poolStart = reinterpret_cast<SgAsmDwarfClassTemplate*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfClassTemplate::getNodeIdStringInternal(SgAsmDwarfClassTemplate* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfClassTemplate* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfClassTemplate::pool_size * sizeof(SgAsmDwarfClassTemplate))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfClassTemplate*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfClassTemplate::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29141 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfClassType*  SgAsmDwarfClassType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfClassType* poolStart = reinterpret_cast<SgAsmDwarfClassType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfClassType::getNodeIdStringInternal(SgAsmDwarfClassType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfClassType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfClassType::pool_size * sizeof(SgAsmDwarfClassType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfClassType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfClassType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29178 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfCommonBlock*  SgAsmDwarfCommonBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfCommonBlock* poolStart = reinterpret_cast<SgAsmDwarfCommonBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfCommonBlock::getNodeIdStringInternal(SgAsmDwarfCommonBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfCommonBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfCommonBlock::pool_size * sizeof(SgAsmDwarfCommonBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfCommonBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfCommonBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29215 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfCommonInclusion*  SgAsmDwarfCommonInclusion::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfCommonInclusion* poolStart = reinterpret_cast<SgAsmDwarfCommonInclusion*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfCommonInclusion::getNodeIdStringInternal(SgAsmDwarfCommonInclusion* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfCommonInclusion* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfCommonInclusion::pool_size * sizeof(SgAsmDwarfCommonInclusion))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfCommonInclusion*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfCommonInclusion::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29252 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfCompilationUnit*  SgAsmDwarfCompilationUnit::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfCompilationUnit* poolStart = reinterpret_cast<SgAsmDwarfCompilationUnit*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfCompilationUnit::getNodeIdStringInternal(SgAsmDwarfCompilationUnit* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfCompilationUnit* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfCompilationUnit::pool_size * sizeof(SgAsmDwarfCompilationUnit))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfCompilationUnit*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfCompilationUnit::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29289 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfCondition*  SgAsmDwarfCondition::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfCondition* poolStart = reinterpret_cast<SgAsmDwarfCondition*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfCondition::getNodeIdStringInternal(SgAsmDwarfCondition* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfCondition* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfCondition::pool_size * sizeof(SgAsmDwarfCondition))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfCondition*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfCondition::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29326 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfConstant*  SgAsmDwarfConstant::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfConstant* poolStart = reinterpret_cast<SgAsmDwarfConstant*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfConstant::getNodeIdStringInternal(SgAsmDwarfConstant* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfConstant* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfConstant::pool_size * sizeof(SgAsmDwarfConstant))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfConstant*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfConstant::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29363 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfConstType*  SgAsmDwarfConstType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfConstType* poolStart = reinterpret_cast<SgAsmDwarfConstType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfConstType::getNodeIdStringInternal(SgAsmDwarfConstType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfConstType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfConstType::pool_size * sizeof(SgAsmDwarfConstType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfConstType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfConstType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29400 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfDwarfProcedure*  SgAsmDwarfDwarfProcedure::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfDwarfProcedure* poolStart = reinterpret_cast<SgAsmDwarfDwarfProcedure*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfDwarfProcedure::getNodeIdStringInternal(SgAsmDwarfDwarfProcedure* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfDwarfProcedure* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfDwarfProcedure::pool_size * sizeof(SgAsmDwarfDwarfProcedure))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfDwarfProcedure*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfDwarfProcedure::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29437 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfEntryPoint*  SgAsmDwarfEntryPoint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfEntryPoint* poolStart = reinterpret_cast<SgAsmDwarfEntryPoint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfEntryPoint::getNodeIdStringInternal(SgAsmDwarfEntryPoint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfEntryPoint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfEntryPoint::pool_size * sizeof(SgAsmDwarfEntryPoint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfEntryPoint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfEntryPoint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29474 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfEnumerationType*  SgAsmDwarfEnumerationType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfEnumerationType* poolStart = reinterpret_cast<SgAsmDwarfEnumerationType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfEnumerationType::getNodeIdStringInternal(SgAsmDwarfEnumerationType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfEnumerationType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfEnumerationType::pool_size * sizeof(SgAsmDwarfEnumerationType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfEnumerationType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfEnumerationType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29511 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfEnumerator*  SgAsmDwarfEnumerator::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfEnumerator* poolStart = reinterpret_cast<SgAsmDwarfEnumerator*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfEnumerator::getNodeIdStringInternal(SgAsmDwarfEnumerator* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfEnumerator* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfEnumerator::pool_size * sizeof(SgAsmDwarfEnumerator))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfEnumerator*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfEnumerator::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29548 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfFileType*  SgAsmDwarfFileType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfFileType* poolStart = reinterpret_cast<SgAsmDwarfFileType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfFileType::getNodeIdStringInternal(SgAsmDwarfFileType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfFileType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfFileType::pool_size * sizeof(SgAsmDwarfFileType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfFileType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfFileType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29585 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfFormalParameter*  SgAsmDwarfFormalParameter::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfFormalParameter* poolStart = reinterpret_cast<SgAsmDwarfFormalParameter*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfFormalParameter::getNodeIdStringInternal(SgAsmDwarfFormalParameter* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfFormalParameter* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfFormalParameter::pool_size * sizeof(SgAsmDwarfFormalParameter))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfFormalParameter*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfFormalParameter::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29622 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfFormatLabel*  SgAsmDwarfFormatLabel::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfFormatLabel* poolStart = reinterpret_cast<SgAsmDwarfFormatLabel*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfFormatLabel::getNodeIdStringInternal(SgAsmDwarfFormatLabel* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfFormatLabel* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfFormatLabel::pool_size * sizeof(SgAsmDwarfFormatLabel))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfFormatLabel*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfFormatLabel::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29659 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfFriend*  SgAsmDwarfFriend::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfFriend* poolStart = reinterpret_cast<SgAsmDwarfFriend*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfFriend::getNodeIdStringInternal(SgAsmDwarfFriend* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfFriend* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfFriend::pool_size * sizeof(SgAsmDwarfFriend))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfFriend*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfFriend::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29696 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfFunctionTemplate*  SgAsmDwarfFunctionTemplate::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfFunctionTemplate* poolStart = reinterpret_cast<SgAsmDwarfFunctionTemplate*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfFunctionTemplate::getNodeIdStringInternal(SgAsmDwarfFunctionTemplate* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfFunctionTemplate* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfFunctionTemplate::pool_size * sizeof(SgAsmDwarfFunctionTemplate))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfFunctionTemplate*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfFunctionTemplate::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29733 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfImportedDeclaration*  SgAsmDwarfImportedDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfImportedDeclaration* poolStart = reinterpret_cast<SgAsmDwarfImportedDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfImportedDeclaration::getNodeIdStringInternal(SgAsmDwarfImportedDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfImportedDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfImportedDeclaration::pool_size * sizeof(SgAsmDwarfImportedDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfImportedDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfImportedDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29770 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfImportedModule*  SgAsmDwarfImportedModule::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfImportedModule* poolStart = reinterpret_cast<SgAsmDwarfImportedModule*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfImportedModule::getNodeIdStringInternal(SgAsmDwarfImportedModule* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfImportedModule* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfImportedModule::pool_size * sizeof(SgAsmDwarfImportedModule))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfImportedModule*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfImportedModule::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29807 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfImportedUnit*  SgAsmDwarfImportedUnit::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfImportedUnit* poolStart = reinterpret_cast<SgAsmDwarfImportedUnit*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfImportedUnit::getNodeIdStringInternal(SgAsmDwarfImportedUnit* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfImportedUnit* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfImportedUnit::pool_size * sizeof(SgAsmDwarfImportedUnit))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfImportedUnit*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfImportedUnit::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29844 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfInheritance*  SgAsmDwarfInheritance::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfInheritance* poolStart = reinterpret_cast<SgAsmDwarfInheritance*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfInheritance::getNodeIdStringInternal(SgAsmDwarfInheritance* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfInheritance* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfInheritance::pool_size * sizeof(SgAsmDwarfInheritance))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfInheritance*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfInheritance::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29881 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfInlinedSubroutine*  SgAsmDwarfInlinedSubroutine::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfInlinedSubroutine* poolStart = reinterpret_cast<SgAsmDwarfInlinedSubroutine*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfInlinedSubroutine::getNodeIdStringInternal(SgAsmDwarfInlinedSubroutine* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfInlinedSubroutine* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfInlinedSubroutine::pool_size * sizeof(SgAsmDwarfInlinedSubroutine))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfInlinedSubroutine*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfInlinedSubroutine::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29918 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfInterfaceType*  SgAsmDwarfInterfaceType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfInterfaceType* poolStart = reinterpret_cast<SgAsmDwarfInterfaceType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfInterfaceType::getNodeIdStringInternal(SgAsmDwarfInterfaceType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfInterfaceType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfInterfaceType::pool_size * sizeof(SgAsmDwarfInterfaceType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfInterfaceType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfInterfaceType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29955 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfLabel*  SgAsmDwarfLabel::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfLabel* poolStart = reinterpret_cast<SgAsmDwarfLabel*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfLabel::getNodeIdStringInternal(SgAsmDwarfLabel* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfLabel* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfLabel::pool_size * sizeof(SgAsmDwarfLabel))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfLabel*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfLabel::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 29992 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfLexicalBlock*  SgAsmDwarfLexicalBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfLexicalBlock* poolStart = reinterpret_cast<SgAsmDwarfLexicalBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfLexicalBlock::getNodeIdStringInternal(SgAsmDwarfLexicalBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfLexicalBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfLexicalBlock::pool_size * sizeof(SgAsmDwarfLexicalBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfLexicalBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfLexicalBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30029 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfMember*  SgAsmDwarfMember::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfMember* poolStart = reinterpret_cast<SgAsmDwarfMember*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfMember::getNodeIdStringInternal(SgAsmDwarfMember* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfMember* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfMember::pool_size * sizeof(SgAsmDwarfMember))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfMember*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfMember::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30066 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfModule*  SgAsmDwarfModule::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfModule* poolStart = reinterpret_cast<SgAsmDwarfModule*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfModule::getNodeIdStringInternal(SgAsmDwarfModule* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfModule* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfModule::pool_size * sizeof(SgAsmDwarfModule))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfModule*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfModule::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30103 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfMutableType*  SgAsmDwarfMutableType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfMutableType* poolStart = reinterpret_cast<SgAsmDwarfMutableType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfMutableType::getNodeIdStringInternal(SgAsmDwarfMutableType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfMutableType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfMutableType::pool_size * sizeof(SgAsmDwarfMutableType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfMutableType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfMutableType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30140 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfNamelist*  SgAsmDwarfNamelist::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfNamelist* poolStart = reinterpret_cast<SgAsmDwarfNamelist*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfNamelist::getNodeIdStringInternal(SgAsmDwarfNamelist* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfNamelist* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfNamelist::pool_size * sizeof(SgAsmDwarfNamelist))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfNamelist*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfNamelist::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30177 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfNamelistItem*  SgAsmDwarfNamelistItem::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfNamelistItem* poolStart = reinterpret_cast<SgAsmDwarfNamelistItem*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfNamelistItem::getNodeIdStringInternal(SgAsmDwarfNamelistItem* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfNamelistItem* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfNamelistItem::pool_size * sizeof(SgAsmDwarfNamelistItem))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfNamelistItem*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfNamelistItem::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30214 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfNamespace*  SgAsmDwarfNamespace::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfNamespace* poolStart = reinterpret_cast<SgAsmDwarfNamespace*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfNamespace::getNodeIdStringInternal(SgAsmDwarfNamespace* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfNamespace* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfNamespace::pool_size * sizeof(SgAsmDwarfNamespace))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfNamespace*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfNamespace::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30251 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfPackedType*  SgAsmDwarfPackedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfPackedType* poolStart = reinterpret_cast<SgAsmDwarfPackedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfPackedType::getNodeIdStringInternal(SgAsmDwarfPackedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfPackedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfPackedType::pool_size * sizeof(SgAsmDwarfPackedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfPackedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfPackedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30288 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfPartialUnit*  SgAsmDwarfPartialUnit::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfPartialUnit* poolStart = reinterpret_cast<SgAsmDwarfPartialUnit*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfPartialUnit::getNodeIdStringInternal(SgAsmDwarfPartialUnit* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfPartialUnit* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfPartialUnit::pool_size * sizeof(SgAsmDwarfPartialUnit))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfPartialUnit*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfPartialUnit::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30325 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfPointerType*  SgAsmDwarfPointerType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfPointerType* poolStart = reinterpret_cast<SgAsmDwarfPointerType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfPointerType::getNodeIdStringInternal(SgAsmDwarfPointerType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfPointerType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfPointerType::pool_size * sizeof(SgAsmDwarfPointerType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfPointerType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfPointerType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30362 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfPtrToMemberType*  SgAsmDwarfPtrToMemberType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfPtrToMemberType* poolStart = reinterpret_cast<SgAsmDwarfPtrToMemberType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfPtrToMemberType::getNodeIdStringInternal(SgAsmDwarfPtrToMemberType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfPtrToMemberType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfPtrToMemberType::pool_size * sizeof(SgAsmDwarfPtrToMemberType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfPtrToMemberType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfPtrToMemberType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30399 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfReferenceType*  SgAsmDwarfReferenceType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfReferenceType* poolStart = reinterpret_cast<SgAsmDwarfReferenceType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfReferenceType::getNodeIdStringInternal(SgAsmDwarfReferenceType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfReferenceType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfReferenceType::pool_size * sizeof(SgAsmDwarfReferenceType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfReferenceType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfReferenceType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30436 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfRestrictType*  SgAsmDwarfRestrictType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfRestrictType* poolStart = reinterpret_cast<SgAsmDwarfRestrictType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfRestrictType::getNodeIdStringInternal(SgAsmDwarfRestrictType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfRestrictType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfRestrictType::pool_size * sizeof(SgAsmDwarfRestrictType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfRestrictType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfRestrictType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30473 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfSetType*  SgAsmDwarfSetType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfSetType* poolStart = reinterpret_cast<SgAsmDwarfSetType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfSetType::getNodeIdStringInternal(SgAsmDwarfSetType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfSetType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfSetType::pool_size * sizeof(SgAsmDwarfSetType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfSetType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfSetType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30510 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfSharedType*  SgAsmDwarfSharedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfSharedType* poolStart = reinterpret_cast<SgAsmDwarfSharedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfSharedType::getNodeIdStringInternal(SgAsmDwarfSharedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfSharedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfSharedType::pool_size * sizeof(SgAsmDwarfSharedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfSharedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfSharedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30547 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfStringType*  SgAsmDwarfStringType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfStringType* poolStart = reinterpret_cast<SgAsmDwarfStringType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfStringType::getNodeIdStringInternal(SgAsmDwarfStringType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfStringType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfStringType::pool_size * sizeof(SgAsmDwarfStringType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfStringType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfStringType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30584 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfStructureType*  SgAsmDwarfStructureType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfStructureType* poolStart = reinterpret_cast<SgAsmDwarfStructureType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfStructureType::getNodeIdStringInternal(SgAsmDwarfStructureType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfStructureType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfStructureType::pool_size * sizeof(SgAsmDwarfStructureType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfStructureType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfStructureType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30621 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfSubprogram*  SgAsmDwarfSubprogram::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfSubprogram* poolStart = reinterpret_cast<SgAsmDwarfSubprogram*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfSubprogram::getNodeIdStringInternal(SgAsmDwarfSubprogram* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfSubprogram* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfSubprogram::pool_size * sizeof(SgAsmDwarfSubprogram))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfSubprogram*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfSubprogram::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30658 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfSubrangeType*  SgAsmDwarfSubrangeType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfSubrangeType* poolStart = reinterpret_cast<SgAsmDwarfSubrangeType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfSubrangeType::getNodeIdStringInternal(SgAsmDwarfSubrangeType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfSubrangeType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfSubrangeType::pool_size * sizeof(SgAsmDwarfSubrangeType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfSubrangeType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfSubrangeType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30695 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfSubroutineType*  SgAsmDwarfSubroutineType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfSubroutineType* poolStart = reinterpret_cast<SgAsmDwarfSubroutineType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfSubroutineType::getNodeIdStringInternal(SgAsmDwarfSubroutineType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfSubroutineType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfSubroutineType::pool_size * sizeof(SgAsmDwarfSubroutineType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfSubroutineType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfSubroutineType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30732 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfTemplateTypeParameter*  SgAsmDwarfTemplateTypeParameter::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfTemplateTypeParameter* poolStart = reinterpret_cast<SgAsmDwarfTemplateTypeParameter*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfTemplateTypeParameter::getNodeIdStringInternal(SgAsmDwarfTemplateTypeParameter* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfTemplateTypeParameter* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfTemplateTypeParameter::pool_size * sizeof(SgAsmDwarfTemplateTypeParameter))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfTemplateTypeParameter*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfTemplateTypeParameter::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30769 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfTemplateValueParameter*  SgAsmDwarfTemplateValueParameter::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfTemplateValueParameter* poolStart = reinterpret_cast<SgAsmDwarfTemplateValueParameter*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfTemplateValueParameter::getNodeIdStringInternal(SgAsmDwarfTemplateValueParameter* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfTemplateValueParameter* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfTemplateValueParameter::pool_size * sizeof(SgAsmDwarfTemplateValueParameter))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfTemplateValueParameter*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfTemplateValueParameter::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30806 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfThrownType*  SgAsmDwarfThrownType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfThrownType* poolStart = reinterpret_cast<SgAsmDwarfThrownType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfThrownType::getNodeIdStringInternal(SgAsmDwarfThrownType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfThrownType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfThrownType::pool_size * sizeof(SgAsmDwarfThrownType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfThrownType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfThrownType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30843 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfTryBlock*  SgAsmDwarfTryBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfTryBlock* poolStart = reinterpret_cast<SgAsmDwarfTryBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfTryBlock::getNodeIdStringInternal(SgAsmDwarfTryBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfTryBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfTryBlock::pool_size * sizeof(SgAsmDwarfTryBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfTryBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfTryBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30880 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfTypedef*  SgAsmDwarfTypedef::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfTypedef* poolStart = reinterpret_cast<SgAsmDwarfTypedef*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfTypedef::getNodeIdStringInternal(SgAsmDwarfTypedef* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfTypedef* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfTypedef::pool_size * sizeof(SgAsmDwarfTypedef))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfTypedef*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfTypedef::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30917 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfUnionType*  SgAsmDwarfUnionType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfUnionType* poolStart = reinterpret_cast<SgAsmDwarfUnionType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfUnionType::getNodeIdStringInternal(SgAsmDwarfUnionType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfUnionType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfUnionType::pool_size * sizeof(SgAsmDwarfUnionType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfUnionType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfUnionType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30954 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfUnknownConstruct*  SgAsmDwarfUnknownConstruct::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfUnknownConstruct* poolStart = reinterpret_cast<SgAsmDwarfUnknownConstruct*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfUnknownConstruct::getNodeIdStringInternal(SgAsmDwarfUnknownConstruct* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfUnknownConstruct* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfUnknownConstruct::pool_size * sizeof(SgAsmDwarfUnknownConstruct))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfUnknownConstruct*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfUnknownConstruct::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 30991 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfUnspecifiedParameters*  SgAsmDwarfUnspecifiedParameters::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfUnspecifiedParameters* poolStart = reinterpret_cast<SgAsmDwarfUnspecifiedParameters*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfUnspecifiedParameters::getNodeIdStringInternal(SgAsmDwarfUnspecifiedParameters* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfUnspecifiedParameters* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfUnspecifiedParameters::pool_size * sizeof(SgAsmDwarfUnspecifiedParameters))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfUnspecifiedParameters*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfUnspecifiedParameters::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31028 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfUnspecifiedType*  SgAsmDwarfUnspecifiedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfUnspecifiedType* poolStart = reinterpret_cast<SgAsmDwarfUnspecifiedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfUnspecifiedType::getNodeIdStringInternal(SgAsmDwarfUnspecifiedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfUnspecifiedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfUnspecifiedType::pool_size * sizeof(SgAsmDwarfUnspecifiedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfUnspecifiedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfUnspecifiedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31065 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfUpcRelaxedType*  SgAsmDwarfUpcRelaxedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfUpcRelaxedType* poolStart = reinterpret_cast<SgAsmDwarfUpcRelaxedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfUpcRelaxedType::getNodeIdStringInternal(SgAsmDwarfUpcRelaxedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfUpcRelaxedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfUpcRelaxedType::pool_size * sizeof(SgAsmDwarfUpcRelaxedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfUpcRelaxedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfUpcRelaxedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31102 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfUpcSharedType*  SgAsmDwarfUpcSharedType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfUpcSharedType* poolStart = reinterpret_cast<SgAsmDwarfUpcSharedType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfUpcSharedType::getNodeIdStringInternal(SgAsmDwarfUpcSharedType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfUpcSharedType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfUpcSharedType::pool_size * sizeof(SgAsmDwarfUpcSharedType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfUpcSharedType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfUpcSharedType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31139 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfUpcStrictType*  SgAsmDwarfUpcStrictType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfUpcStrictType* poolStart = reinterpret_cast<SgAsmDwarfUpcStrictType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfUpcStrictType::getNodeIdStringInternal(SgAsmDwarfUpcStrictType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfUpcStrictType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfUpcStrictType::pool_size * sizeof(SgAsmDwarfUpcStrictType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfUpcStrictType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfUpcStrictType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31176 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfVariable*  SgAsmDwarfVariable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfVariable* poolStart = reinterpret_cast<SgAsmDwarfVariable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfVariable::getNodeIdStringInternal(SgAsmDwarfVariable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfVariable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfVariable::pool_size * sizeof(SgAsmDwarfVariable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfVariable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfVariable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31213 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfVariant*  SgAsmDwarfVariant::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfVariant* poolStart = reinterpret_cast<SgAsmDwarfVariant*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfVariant::getNodeIdStringInternal(SgAsmDwarfVariant* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfVariant* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfVariant::pool_size * sizeof(SgAsmDwarfVariant))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfVariant*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfVariant::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31250 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfVariantPart*  SgAsmDwarfVariantPart::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfVariantPart* poolStart = reinterpret_cast<SgAsmDwarfVariantPart*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfVariantPart::getNodeIdStringInternal(SgAsmDwarfVariantPart* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfVariantPart* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfVariantPart::pool_size * sizeof(SgAsmDwarfVariantPart))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfVariantPart*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfVariantPart::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31287 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfVolatileType*  SgAsmDwarfVolatileType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfVolatileType* poolStart = reinterpret_cast<SgAsmDwarfVolatileType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfVolatileType::getNodeIdStringInternal(SgAsmDwarfVolatileType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfVolatileType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfVolatileType::pool_size * sizeof(SgAsmDwarfVolatileType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfVolatileType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfVolatileType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31324 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfWithStmt*  SgAsmDwarfWithStmt::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfWithStmt* poolStart = reinterpret_cast<SgAsmDwarfWithStmt*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfWithStmt::getNodeIdStringInternal(SgAsmDwarfWithStmt* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfWithStmt* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfWithStmt::pool_size * sizeof(SgAsmDwarfWithStmt))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfWithStmt*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfWithStmt::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31361 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfConstructList*  SgAsmDwarfConstructList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfConstructList* poolStart = reinterpret_cast<SgAsmDwarfConstructList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfConstructList::getNodeIdStringInternal(SgAsmDwarfConstructList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfConstructList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfConstructList::pool_size * sizeof(SgAsmDwarfConstructList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfConstructList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfConstructList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31398 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfLine*  SgAsmDwarfLine::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfLine* poolStart = reinterpret_cast<SgAsmDwarfLine*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfLine::getNodeIdStringInternal(SgAsmDwarfLine* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfLine* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfLine::pool_size * sizeof(SgAsmDwarfLine))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfLine*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfLine::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31435 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfLineList*  SgAsmDwarfLineList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfLineList* poolStart = reinterpret_cast<SgAsmDwarfLineList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfLineList::getNodeIdStringInternal(SgAsmDwarfLineList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfLineList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfLineList::pool_size * sizeof(SgAsmDwarfLineList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfLineList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfLineList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31472 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfMacro*  SgAsmDwarfMacro::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfMacro* poolStart = reinterpret_cast<SgAsmDwarfMacro*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfMacro::getNodeIdStringInternal(SgAsmDwarfMacro* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfMacro* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfMacro::pool_size * sizeof(SgAsmDwarfMacro))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfMacro*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfMacro::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31509 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDwarfMacroList*  SgAsmDwarfMacroList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDwarfMacroList* poolStart = reinterpret_cast<SgAsmDwarfMacroList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDwarfMacroList::getNodeIdStringInternal(SgAsmDwarfMacroList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDwarfMacroList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDwarfMacroList::pool_size * sizeof(SgAsmDwarfMacroList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDwarfMacroList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDwarfMacroList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31546 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfDynamicEntry*  SgAsmElfDynamicEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfDynamicEntry* poolStart = reinterpret_cast<SgAsmElfDynamicEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfDynamicEntry::getNodeIdStringInternal(SgAsmElfDynamicEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfDynamicEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfDynamicEntry::pool_size * sizeof(SgAsmElfDynamicEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfDynamicEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfDynamicEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31583 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfDynamicEntryList*  SgAsmElfDynamicEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfDynamicEntryList* poolStart = reinterpret_cast<SgAsmElfDynamicEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfDynamicEntryList::getNodeIdStringInternal(SgAsmElfDynamicEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfDynamicEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfDynamicEntryList::pool_size * sizeof(SgAsmElfDynamicEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfDynamicEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfDynamicEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31620 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfEHFrameEntryCI*  SgAsmElfEHFrameEntryCI::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfEHFrameEntryCI* poolStart = reinterpret_cast<SgAsmElfEHFrameEntryCI*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfEHFrameEntryCI::getNodeIdStringInternal(SgAsmElfEHFrameEntryCI* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfEHFrameEntryCI* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfEHFrameEntryCI::pool_size * sizeof(SgAsmElfEHFrameEntryCI))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfEHFrameEntryCI*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfEHFrameEntryCI::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31657 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfEHFrameEntryCIList*  SgAsmElfEHFrameEntryCIList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfEHFrameEntryCIList* poolStart = reinterpret_cast<SgAsmElfEHFrameEntryCIList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfEHFrameEntryCIList::getNodeIdStringInternal(SgAsmElfEHFrameEntryCIList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfEHFrameEntryCIList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfEHFrameEntryCIList::pool_size * sizeof(SgAsmElfEHFrameEntryCIList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfEHFrameEntryCIList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfEHFrameEntryCIList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31694 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfEHFrameEntryFD*  SgAsmElfEHFrameEntryFD::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfEHFrameEntryFD* poolStart = reinterpret_cast<SgAsmElfEHFrameEntryFD*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfEHFrameEntryFD::getNodeIdStringInternal(SgAsmElfEHFrameEntryFD* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfEHFrameEntryFD* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfEHFrameEntryFD::pool_size * sizeof(SgAsmElfEHFrameEntryFD))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfEHFrameEntryFD*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfEHFrameEntryFD::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31731 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfEHFrameEntryFDList*  SgAsmElfEHFrameEntryFDList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfEHFrameEntryFDList* poolStart = reinterpret_cast<SgAsmElfEHFrameEntryFDList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfEHFrameEntryFDList::getNodeIdStringInternal(SgAsmElfEHFrameEntryFDList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfEHFrameEntryFDList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfEHFrameEntryFDList::pool_size * sizeof(SgAsmElfEHFrameEntryFDList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfEHFrameEntryFDList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfEHFrameEntryFDList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31768 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfNoteEntry*  SgAsmElfNoteEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfNoteEntry* poolStart = reinterpret_cast<SgAsmElfNoteEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfNoteEntry::getNodeIdStringInternal(SgAsmElfNoteEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfNoteEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfNoteEntry::pool_size * sizeof(SgAsmElfNoteEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfNoteEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfNoteEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31805 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfNoteEntryList*  SgAsmElfNoteEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfNoteEntryList* poolStart = reinterpret_cast<SgAsmElfNoteEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfNoteEntryList::getNodeIdStringInternal(SgAsmElfNoteEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfNoteEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfNoteEntryList::pool_size * sizeof(SgAsmElfNoteEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfNoteEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfNoteEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31842 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfRelocEntry*  SgAsmElfRelocEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfRelocEntry* poolStart = reinterpret_cast<SgAsmElfRelocEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfRelocEntry::getNodeIdStringInternal(SgAsmElfRelocEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfRelocEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfRelocEntry::pool_size * sizeof(SgAsmElfRelocEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfRelocEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfRelocEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31879 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfRelocEntryList*  SgAsmElfRelocEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfRelocEntryList* poolStart = reinterpret_cast<SgAsmElfRelocEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfRelocEntryList::getNodeIdStringInternal(SgAsmElfRelocEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfRelocEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfRelocEntryList::pool_size * sizeof(SgAsmElfRelocEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfRelocEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfRelocEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31916 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSectionTableEntry*  SgAsmElfSectionTableEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSectionTableEntry* poolStart = reinterpret_cast<SgAsmElfSectionTableEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSectionTableEntry::getNodeIdStringInternal(SgAsmElfSectionTableEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSectionTableEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSectionTableEntry::pool_size * sizeof(SgAsmElfSectionTableEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSectionTableEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSectionTableEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31953 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSegmentTableEntry*  SgAsmElfSegmentTableEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSegmentTableEntry* poolStart = reinterpret_cast<SgAsmElfSegmentTableEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSegmentTableEntry::getNodeIdStringInternal(SgAsmElfSegmentTableEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSegmentTableEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSegmentTableEntry::pool_size * sizeof(SgAsmElfSegmentTableEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSegmentTableEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSegmentTableEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 31990 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSegmentTableEntryList*  SgAsmElfSegmentTableEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSegmentTableEntryList* poolStart = reinterpret_cast<SgAsmElfSegmentTableEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSegmentTableEntryList::getNodeIdStringInternal(SgAsmElfSegmentTableEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSegmentTableEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSegmentTableEntryList::pool_size * sizeof(SgAsmElfSegmentTableEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSegmentTableEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSegmentTableEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32027 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymbolList*  SgAsmElfSymbolList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymbolList* poolStart = reinterpret_cast<SgAsmElfSymbolList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymbolList::getNodeIdStringInternal(SgAsmElfSymbolList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymbolList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymbolList::pool_size * sizeof(SgAsmElfSymbolList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymbolList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymbolList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32064 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverDefinedAux*  SgAsmElfSymverDefinedAux::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverDefinedAux* poolStart = reinterpret_cast<SgAsmElfSymverDefinedAux*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverDefinedAux::getNodeIdStringInternal(SgAsmElfSymverDefinedAux* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverDefinedAux* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverDefinedAux::pool_size * sizeof(SgAsmElfSymverDefinedAux))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverDefinedAux*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverDefinedAux::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32101 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverDefinedAuxList*  SgAsmElfSymverDefinedAuxList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverDefinedAuxList* poolStart = reinterpret_cast<SgAsmElfSymverDefinedAuxList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverDefinedAuxList::getNodeIdStringInternal(SgAsmElfSymverDefinedAuxList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverDefinedAuxList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverDefinedAuxList::pool_size * sizeof(SgAsmElfSymverDefinedAuxList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverDefinedAuxList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverDefinedAuxList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32138 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverDefinedEntry*  SgAsmElfSymverDefinedEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverDefinedEntry* poolStart = reinterpret_cast<SgAsmElfSymverDefinedEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverDefinedEntry::getNodeIdStringInternal(SgAsmElfSymverDefinedEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverDefinedEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverDefinedEntry::pool_size * sizeof(SgAsmElfSymverDefinedEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverDefinedEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverDefinedEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32175 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverDefinedEntryList*  SgAsmElfSymverDefinedEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverDefinedEntryList* poolStart = reinterpret_cast<SgAsmElfSymverDefinedEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverDefinedEntryList::getNodeIdStringInternal(SgAsmElfSymverDefinedEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverDefinedEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverDefinedEntryList::pool_size * sizeof(SgAsmElfSymverDefinedEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverDefinedEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverDefinedEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32212 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverEntry*  SgAsmElfSymverEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverEntry* poolStart = reinterpret_cast<SgAsmElfSymverEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverEntry::getNodeIdStringInternal(SgAsmElfSymverEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverEntry::pool_size * sizeof(SgAsmElfSymverEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32249 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverEntryList*  SgAsmElfSymverEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverEntryList* poolStart = reinterpret_cast<SgAsmElfSymverEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverEntryList::getNodeIdStringInternal(SgAsmElfSymverEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverEntryList::pool_size * sizeof(SgAsmElfSymverEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32286 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverNeededAux*  SgAsmElfSymverNeededAux::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverNeededAux* poolStart = reinterpret_cast<SgAsmElfSymverNeededAux*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverNeededAux::getNodeIdStringInternal(SgAsmElfSymverNeededAux* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverNeededAux* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverNeededAux::pool_size * sizeof(SgAsmElfSymverNeededAux))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverNeededAux*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverNeededAux::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32323 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverNeededAuxList*  SgAsmElfSymverNeededAuxList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverNeededAuxList* poolStart = reinterpret_cast<SgAsmElfSymverNeededAuxList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverNeededAuxList::getNodeIdStringInternal(SgAsmElfSymverNeededAuxList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverNeededAuxList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverNeededAuxList::pool_size * sizeof(SgAsmElfSymverNeededAuxList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverNeededAuxList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverNeededAuxList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32360 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverNeededEntry*  SgAsmElfSymverNeededEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverNeededEntry* poolStart = reinterpret_cast<SgAsmElfSymverNeededEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverNeededEntry::getNodeIdStringInternal(SgAsmElfSymverNeededEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverNeededEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverNeededEntry::pool_size * sizeof(SgAsmElfSymverNeededEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverNeededEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverNeededEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32397 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverNeededEntryList*  SgAsmElfSymverNeededEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverNeededEntryList* poolStart = reinterpret_cast<SgAsmElfSymverNeededEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverNeededEntryList::getNodeIdStringInternal(SgAsmElfSymverNeededEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverNeededEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverNeededEntryList::pool_size * sizeof(SgAsmElfSymverNeededEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverNeededEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverNeededEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32434 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericDLL*  SgAsmGenericDLL::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericDLL* poolStart = reinterpret_cast<SgAsmGenericDLL*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericDLL::getNodeIdStringInternal(SgAsmGenericDLL* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericDLL* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericDLL::pool_size * sizeof(SgAsmGenericDLL))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericDLL*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericDLL::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32471 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericDLLList*  SgAsmGenericDLLList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericDLLList* poolStart = reinterpret_cast<SgAsmGenericDLLList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericDLLList::getNodeIdStringInternal(SgAsmGenericDLLList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericDLLList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericDLLList::pool_size * sizeof(SgAsmGenericDLLList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericDLLList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericDLLList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32508 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericFile*  SgAsmGenericFile::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericFile* poolStart = reinterpret_cast<SgAsmGenericFile*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericFile::getNodeIdStringInternal(SgAsmGenericFile* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericFile* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericFile::pool_size * sizeof(SgAsmGenericFile))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericFile*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericFile::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32545 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericFormat*  SgAsmGenericFormat::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericFormat* poolStart = reinterpret_cast<SgAsmGenericFormat*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericFormat::getNodeIdStringInternal(SgAsmGenericFormat* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericFormat* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericFormat::pool_size * sizeof(SgAsmGenericFormat))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericFormat*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericFormat::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32582 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericHeaderList*  SgAsmGenericHeaderList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericHeaderList* poolStart = reinterpret_cast<SgAsmGenericHeaderList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericHeaderList::getNodeIdStringInternal(SgAsmGenericHeaderList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericHeaderList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericHeaderList::pool_size * sizeof(SgAsmGenericHeaderList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericHeaderList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericHeaderList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32619 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericSection*  SgAsmGenericSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericSection* poolStart = reinterpret_cast<SgAsmGenericSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericSection::getNodeIdStringInternal(SgAsmGenericSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericSection::pool_size * sizeof(SgAsmGenericSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32656 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCliHeader*  SgAsmCliHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCliHeader* poolStart = reinterpret_cast<SgAsmCliHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCliHeader::getNodeIdStringInternal(SgAsmCliHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCliHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCliHeader::pool_size * sizeof(SgAsmCliHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCliHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCliHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32693 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCoffSymbolTable*  SgAsmCoffSymbolTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCoffSymbolTable* poolStart = reinterpret_cast<SgAsmCoffSymbolTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCoffSymbolTable::getNodeIdStringInternal(SgAsmCoffSymbolTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCoffSymbolTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCoffSymbolTable::pool_size * sizeof(SgAsmCoffSymbolTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCoffSymbolTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCoffSymbolTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32730 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDOSExtendedHeader*  SgAsmDOSExtendedHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDOSExtendedHeader* poolStart = reinterpret_cast<SgAsmDOSExtendedHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDOSExtendedHeader::getNodeIdStringInternal(SgAsmDOSExtendedHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDOSExtendedHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDOSExtendedHeader::pool_size * sizeof(SgAsmDOSExtendedHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDOSExtendedHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDOSExtendedHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32767 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSection*  SgAsmElfSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSection* poolStart = reinterpret_cast<SgAsmElfSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSection::getNodeIdStringInternal(SgAsmElfSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSection::pool_size * sizeof(SgAsmElfSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32804 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfDynamicSection*  SgAsmElfDynamicSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfDynamicSection* poolStart = reinterpret_cast<SgAsmElfDynamicSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfDynamicSection::getNodeIdStringInternal(SgAsmElfDynamicSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfDynamicSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfDynamicSection::pool_size * sizeof(SgAsmElfDynamicSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfDynamicSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfDynamicSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32841 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfEHFrameSection*  SgAsmElfEHFrameSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfEHFrameSection* poolStart = reinterpret_cast<SgAsmElfEHFrameSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfEHFrameSection::getNodeIdStringInternal(SgAsmElfEHFrameSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfEHFrameSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfEHFrameSection::pool_size * sizeof(SgAsmElfEHFrameSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfEHFrameSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfEHFrameSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32878 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfNoteSection*  SgAsmElfNoteSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfNoteSection* poolStart = reinterpret_cast<SgAsmElfNoteSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfNoteSection::getNodeIdStringInternal(SgAsmElfNoteSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfNoteSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfNoteSection::pool_size * sizeof(SgAsmElfNoteSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfNoteSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfNoteSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32915 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfRelocSection*  SgAsmElfRelocSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfRelocSection* poolStart = reinterpret_cast<SgAsmElfRelocSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfRelocSection::getNodeIdStringInternal(SgAsmElfRelocSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfRelocSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfRelocSection::pool_size * sizeof(SgAsmElfRelocSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfRelocSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfRelocSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32952 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfStringSection*  SgAsmElfStringSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfStringSection* poolStart = reinterpret_cast<SgAsmElfStringSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfStringSection::getNodeIdStringInternal(SgAsmElfStringSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfStringSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfStringSection::pool_size * sizeof(SgAsmElfStringSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfStringSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfStringSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 32989 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymbolSection*  SgAsmElfSymbolSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymbolSection* poolStart = reinterpret_cast<SgAsmElfSymbolSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymbolSection::getNodeIdStringInternal(SgAsmElfSymbolSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymbolSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymbolSection::pool_size * sizeof(SgAsmElfSymbolSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymbolSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymbolSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33026 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverDefinedSection*  SgAsmElfSymverDefinedSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverDefinedSection* poolStart = reinterpret_cast<SgAsmElfSymverDefinedSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverDefinedSection::getNodeIdStringInternal(SgAsmElfSymverDefinedSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverDefinedSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverDefinedSection::pool_size * sizeof(SgAsmElfSymverDefinedSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverDefinedSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverDefinedSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33063 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverNeededSection*  SgAsmElfSymverNeededSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverNeededSection* poolStart = reinterpret_cast<SgAsmElfSymverNeededSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverNeededSection::getNodeIdStringInternal(SgAsmElfSymverNeededSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverNeededSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverNeededSection::pool_size * sizeof(SgAsmElfSymverNeededSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverNeededSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverNeededSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33100 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymverSection*  SgAsmElfSymverSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymverSection* poolStart = reinterpret_cast<SgAsmElfSymverSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymverSection::getNodeIdStringInternal(SgAsmElfSymverSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymverSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymverSection::pool_size * sizeof(SgAsmElfSymverSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymverSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymverSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33137 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSectionTable*  SgAsmElfSectionTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSectionTable* poolStart = reinterpret_cast<SgAsmElfSectionTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSectionTable::getNodeIdStringInternal(SgAsmElfSectionTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSectionTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSectionTable::pool_size * sizeof(SgAsmElfSectionTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSectionTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSectionTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33174 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSegmentTable*  SgAsmElfSegmentTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSegmentTable* poolStart = reinterpret_cast<SgAsmElfSegmentTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSegmentTable::getNodeIdStringInternal(SgAsmElfSegmentTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSegmentTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSegmentTable::pool_size * sizeof(SgAsmElfSegmentTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSegmentTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSegmentTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33211 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericHeader*  SgAsmGenericHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericHeader* poolStart = reinterpret_cast<SgAsmGenericHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericHeader::getNodeIdStringInternal(SgAsmGenericHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericHeader::pool_size * sizeof(SgAsmGenericHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33248 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDOSFileHeader*  SgAsmDOSFileHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDOSFileHeader* poolStart = reinterpret_cast<SgAsmDOSFileHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDOSFileHeader::getNodeIdStringInternal(SgAsmDOSFileHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDOSFileHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDOSFileHeader::pool_size * sizeof(SgAsmDOSFileHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDOSFileHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDOSFileHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33285 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfFileHeader*  SgAsmElfFileHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfFileHeader* poolStart = reinterpret_cast<SgAsmElfFileHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfFileHeader::getNodeIdStringInternal(SgAsmElfFileHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfFileHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfFileHeader::pool_size * sizeof(SgAsmElfFileHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfFileHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfFileHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33322 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmFileHeader*  SgAsmJvmFileHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmFileHeader* poolStart = reinterpret_cast<SgAsmJvmFileHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmFileHeader::getNodeIdStringInternal(SgAsmJvmFileHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmFileHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmFileHeader::pool_size * sizeof(SgAsmJvmFileHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmFileHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmFileHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33359 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLEFileHeader*  SgAsmLEFileHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLEFileHeader* poolStart = reinterpret_cast<SgAsmLEFileHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLEFileHeader::getNodeIdStringInternal(SgAsmLEFileHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLEFileHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLEFileHeader::pool_size * sizeof(SgAsmLEFileHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLEFileHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLEFileHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33396 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNEFileHeader*  SgAsmNEFileHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNEFileHeader* poolStart = reinterpret_cast<SgAsmNEFileHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNEFileHeader::getNodeIdStringInternal(SgAsmNEFileHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNEFileHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNEFileHeader::pool_size * sizeof(SgAsmNEFileHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNEFileHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNEFileHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33433 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEFileHeader*  SgAsmPEFileHeader::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEFileHeader* poolStart = reinterpret_cast<SgAsmPEFileHeader*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEFileHeader::getNodeIdStringInternal(SgAsmPEFileHeader* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEFileHeader* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEFileHeader::pool_size * sizeof(SgAsmPEFileHeader))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEFileHeader*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEFileHeader::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33470 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmAttributeTable*  SgAsmJvmAttributeTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmAttributeTable* poolStart = reinterpret_cast<SgAsmJvmAttributeTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmAttributeTable::getNodeIdStringInternal(SgAsmJvmAttributeTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmAttributeTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmAttributeTable::pool_size * sizeof(SgAsmJvmAttributeTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmAttributeTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmAttributeTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33507 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmConstantPool*  SgAsmJvmConstantPool::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmConstantPool* poolStart = reinterpret_cast<SgAsmJvmConstantPool*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmConstantPool::getNodeIdStringInternal(SgAsmJvmConstantPool* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmConstantPool* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmConstantPool::pool_size * sizeof(SgAsmJvmConstantPool))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmConstantPool*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmConstantPool::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33544 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmFieldTable*  SgAsmJvmFieldTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmFieldTable* poolStart = reinterpret_cast<SgAsmJvmFieldTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmFieldTable::getNodeIdStringInternal(SgAsmJvmFieldTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmFieldTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmFieldTable::pool_size * sizeof(SgAsmJvmFieldTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmFieldTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmFieldTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33581 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmMethodTable*  SgAsmJvmMethodTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmMethodTable* poolStart = reinterpret_cast<SgAsmJvmMethodTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmMethodTable::getNodeIdStringInternal(SgAsmJvmMethodTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmMethodTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmMethodTable::pool_size * sizeof(SgAsmJvmMethodTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmMethodTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmMethodTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33618 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLEEntryTable*  SgAsmLEEntryTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLEEntryTable* poolStart = reinterpret_cast<SgAsmLEEntryTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLEEntryTable::getNodeIdStringInternal(SgAsmLEEntryTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLEEntryTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLEEntryTable::pool_size * sizeof(SgAsmLEEntryTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLEEntryTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLEEntryTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33655 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLENameTable*  SgAsmLENameTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLENameTable* poolStart = reinterpret_cast<SgAsmLENameTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLENameTable::getNodeIdStringInternal(SgAsmLENameTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLENameTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLENameTable::pool_size * sizeof(SgAsmLENameTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLENameTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLENameTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33692 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLEPageTable*  SgAsmLEPageTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLEPageTable* poolStart = reinterpret_cast<SgAsmLEPageTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLEPageTable::getNodeIdStringInternal(SgAsmLEPageTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLEPageTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLEPageTable::pool_size * sizeof(SgAsmLEPageTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLEPageTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLEPageTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33729 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLERelocTable*  SgAsmLERelocTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLERelocTable* poolStart = reinterpret_cast<SgAsmLERelocTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLERelocTable::getNodeIdStringInternal(SgAsmLERelocTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLERelocTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLERelocTable::pool_size * sizeof(SgAsmLERelocTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLERelocTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLERelocTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33766 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLESection*  SgAsmLESection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLESection* poolStart = reinterpret_cast<SgAsmLESection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLESection::getNodeIdStringInternal(SgAsmLESection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLESection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLESection::pool_size * sizeof(SgAsmLESection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLESection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLESection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33803 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLESectionTable*  SgAsmLESectionTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLESectionTable* poolStart = reinterpret_cast<SgAsmLESectionTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLESectionTable::getNodeIdStringInternal(SgAsmLESectionTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLESectionTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLESectionTable::pool_size * sizeof(SgAsmLESectionTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLESectionTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLESectionTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33840 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNEEntryTable*  SgAsmNEEntryTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNEEntryTable* poolStart = reinterpret_cast<SgAsmNEEntryTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNEEntryTable::getNodeIdStringInternal(SgAsmNEEntryTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNEEntryTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNEEntryTable::pool_size * sizeof(SgAsmNEEntryTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNEEntryTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNEEntryTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33877 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNEModuleTable*  SgAsmNEModuleTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNEModuleTable* poolStart = reinterpret_cast<SgAsmNEModuleTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNEModuleTable::getNodeIdStringInternal(SgAsmNEModuleTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNEModuleTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNEModuleTable::pool_size * sizeof(SgAsmNEModuleTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNEModuleTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNEModuleTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33914 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNENameTable*  SgAsmNENameTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNENameTable* poolStart = reinterpret_cast<SgAsmNENameTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNENameTable::getNodeIdStringInternal(SgAsmNENameTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNENameTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNENameTable::pool_size * sizeof(SgAsmNENameTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNENameTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNENameTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33951 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNERelocTable*  SgAsmNERelocTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNERelocTable* poolStart = reinterpret_cast<SgAsmNERelocTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNERelocTable::getNodeIdStringInternal(SgAsmNERelocTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNERelocTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNERelocTable::pool_size * sizeof(SgAsmNERelocTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNERelocTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNERelocTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 33988 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNESection*  SgAsmNESection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNESection* poolStart = reinterpret_cast<SgAsmNESection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNESection::getNodeIdStringInternal(SgAsmNESection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNESection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNESection::pool_size * sizeof(SgAsmNESection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNESection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNESection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34025 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNESectionTable*  SgAsmNESectionTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNESectionTable* poolStart = reinterpret_cast<SgAsmNESectionTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNESectionTable::getNodeIdStringInternal(SgAsmNESectionTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNESectionTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNESectionTable::pool_size * sizeof(SgAsmNESectionTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNESectionTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNESectionTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34062 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNEStringTable*  SgAsmNEStringTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNEStringTable* poolStart = reinterpret_cast<SgAsmNEStringTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNEStringTable::getNodeIdStringInternal(SgAsmNEStringTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNEStringTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNEStringTable::pool_size * sizeof(SgAsmNEStringTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNEStringTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNEStringTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34099 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPESection*  SgAsmPESection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPESection* poolStart = reinterpret_cast<SgAsmPESection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPESection::getNodeIdStringInternal(SgAsmPESection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPESection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPESection::pool_size * sizeof(SgAsmPESection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPESection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPESection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34136 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEExportSection*  SgAsmPEExportSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEExportSection* poolStart = reinterpret_cast<SgAsmPEExportSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEExportSection::getNodeIdStringInternal(SgAsmPEExportSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEExportSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEExportSection::pool_size * sizeof(SgAsmPEExportSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEExportSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEExportSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34173 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEImportSection*  SgAsmPEImportSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEImportSection* poolStart = reinterpret_cast<SgAsmPEImportSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEImportSection::getNodeIdStringInternal(SgAsmPEImportSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEImportSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEImportSection::pool_size * sizeof(SgAsmPEImportSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEImportSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEImportSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34210 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEStringSection*  SgAsmPEStringSection::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEStringSection* poolStart = reinterpret_cast<SgAsmPEStringSection*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEStringSection::getNodeIdStringInternal(SgAsmPEStringSection* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEStringSection* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEStringSection::pool_size * sizeof(SgAsmPEStringSection))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEStringSection*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEStringSection::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34247 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPESectionTable*  SgAsmPESectionTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPESectionTable* poolStart = reinterpret_cast<SgAsmPESectionTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPESectionTable::getNodeIdStringInternal(SgAsmPESectionTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPESectionTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPESectionTable::pool_size * sizeof(SgAsmPESectionTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPESectionTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPESectionTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34284 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericSectionList*  SgAsmGenericSectionList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericSectionList* poolStart = reinterpret_cast<SgAsmGenericSectionList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericSectionList::getNodeIdStringInternal(SgAsmGenericSectionList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericSectionList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericSectionList::pool_size * sizeof(SgAsmGenericSectionList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericSectionList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericSectionList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34321 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericString*  SgAsmGenericString::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericString* poolStart = reinterpret_cast<SgAsmGenericString*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericString::getNodeIdStringInternal(SgAsmGenericString* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericString* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericString::pool_size * sizeof(SgAsmGenericString))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericString*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericString::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34358 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBasicString*  SgAsmBasicString::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBasicString* poolStart = reinterpret_cast<SgAsmBasicString*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBasicString::getNodeIdStringInternal(SgAsmBasicString* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBasicString* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBasicString::pool_size * sizeof(SgAsmBasicString))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBasicString*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBasicString::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34395 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmStoredString*  SgAsmStoredString::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmStoredString* poolStart = reinterpret_cast<SgAsmStoredString*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmStoredString::getNodeIdStringInternal(SgAsmStoredString* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmStoredString* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmStoredString::pool_size * sizeof(SgAsmStoredString))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmStoredString*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmStoredString::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34432 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericStrtab*  SgAsmGenericStrtab::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericStrtab* poolStart = reinterpret_cast<SgAsmGenericStrtab*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericStrtab::getNodeIdStringInternal(SgAsmGenericStrtab* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericStrtab* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericStrtab::pool_size * sizeof(SgAsmGenericStrtab))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericStrtab*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericStrtab::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34469 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCoffStrtab*  SgAsmCoffStrtab::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCoffStrtab* poolStart = reinterpret_cast<SgAsmCoffStrtab*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCoffStrtab::getNodeIdStringInternal(SgAsmCoffStrtab* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCoffStrtab* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCoffStrtab::pool_size * sizeof(SgAsmCoffStrtab))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCoffStrtab*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCoffStrtab::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34506 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfStrtab*  SgAsmElfStrtab::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfStrtab* poolStart = reinterpret_cast<SgAsmElfStrtab*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfStrtab::getNodeIdStringInternal(SgAsmElfStrtab* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfStrtab* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfStrtab::pool_size * sizeof(SgAsmElfStrtab))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfStrtab*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfStrtab::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34543 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericSymbol*  SgAsmGenericSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericSymbol* poolStart = reinterpret_cast<SgAsmGenericSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericSymbol::getNodeIdStringInternal(SgAsmGenericSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericSymbol::pool_size * sizeof(SgAsmGenericSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34580 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCoffSymbol*  SgAsmCoffSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCoffSymbol* poolStart = reinterpret_cast<SgAsmCoffSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCoffSymbol::getNodeIdStringInternal(SgAsmCoffSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCoffSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCoffSymbol::pool_size * sizeof(SgAsmCoffSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCoffSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCoffSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34617 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmElfSymbol*  SgAsmElfSymbol::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmElfSymbol* poolStart = reinterpret_cast<SgAsmElfSymbol*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmElfSymbol::getNodeIdStringInternal(SgAsmElfSymbol* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmElfSymbol* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmElfSymbol::pool_size * sizeof(SgAsmElfSymbol))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmElfSymbol*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmElfSymbol::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34654 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericSymbolList*  SgAsmGenericSymbolList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericSymbolList* poolStart = reinterpret_cast<SgAsmGenericSymbolList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericSymbolList::getNodeIdStringInternal(SgAsmGenericSymbolList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericSymbolList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericSymbolList::pool_size * sizeof(SgAsmGenericSymbolList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericSymbolList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericSymbolList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34691 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLEEntryPoint*  SgAsmLEEntryPoint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLEEntryPoint* poolStart = reinterpret_cast<SgAsmLEEntryPoint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLEEntryPoint::getNodeIdStringInternal(SgAsmLEEntryPoint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLEEntryPoint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLEEntryPoint::pool_size * sizeof(SgAsmLEEntryPoint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLEEntryPoint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLEEntryPoint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34728 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLEPageTableEntry*  SgAsmLEPageTableEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLEPageTableEntry* poolStart = reinterpret_cast<SgAsmLEPageTableEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLEPageTableEntry::getNodeIdStringInternal(SgAsmLEPageTableEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLEPageTableEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLEPageTableEntry::pool_size * sizeof(SgAsmLEPageTableEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLEPageTableEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLEPageTableEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34765 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmLESectionTableEntry*  SgAsmLESectionTableEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmLESectionTableEntry* poolStart = reinterpret_cast<SgAsmLESectionTableEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmLESectionTableEntry::getNodeIdStringInternal(SgAsmLESectionTableEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmLESectionTableEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmLESectionTableEntry::pool_size * sizeof(SgAsmLESectionTableEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmLESectionTableEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmLESectionTableEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34802 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNEEntryPoint*  SgAsmNEEntryPoint::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNEEntryPoint* poolStart = reinterpret_cast<SgAsmNEEntryPoint*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNEEntryPoint::getNodeIdStringInternal(SgAsmNEEntryPoint* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNEEntryPoint* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNEEntryPoint::pool_size * sizeof(SgAsmNEEntryPoint))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNEEntryPoint*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNEEntryPoint::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34839 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNERelocEntry*  SgAsmNERelocEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNERelocEntry* poolStart = reinterpret_cast<SgAsmNERelocEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNERelocEntry::getNodeIdStringInternal(SgAsmNERelocEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNERelocEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNERelocEntry::pool_size * sizeof(SgAsmNERelocEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNERelocEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNERelocEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34876 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNESectionTableEntry*  SgAsmNESectionTableEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNESectionTableEntry* poolStart = reinterpret_cast<SgAsmNESectionTableEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNESectionTableEntry::getNodeIdStringInternal(SgAsmNESectionTableEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNESectionTableEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNESectionTableEntry::pool_size * sizeof(SgAsmNESectionTableEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNESectionTableEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNESectionTableEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34913 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEExportDirectory*  SgAsmPEExportDirectory::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEExportDirectory* poolStart = reinterpret_cast<SgAsmPEExportDirectory*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEExportDirectory::getNodeIdStringInternal(SgAsmPEExportDirectory* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEExportDirectory* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEExportDirectory::pool_size * sizeof(SgAsmPEExportDirectory))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEExportDirectory*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEExportDirectory::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34950 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEExportEntry*  SgAsmPEExportEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEExportEntry* poolStart = reinterpret_cast<SgAsmPEExportEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEExportEntry::getNodeIdStringInternal(SgAsmPEExportEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEExportEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEExportEntry::pool_size * sizeof(SgAsmPEExportEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEExportEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEExportEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 34987 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEExportEntryList*  SgAsmPEExportEntryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEExportEntryList* poolStart = reinterpret_cast<SgAsmPEExportEntryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEExportEntryList::getNodeIdStringInternal(SgAsmPEExportEntryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEExportEntryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEExportEntryList::pool_size * sizeof(SgAsmPEExportEntryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEExportEntryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEExportEntryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35024 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEImportDirectory*  SgAsmPEImportDirectory::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEImportDirectory* poolStart = reinterpret_cast<SgAsmPEImportDirectory*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEImportDirectory::getNodeIdStringInternal(SgAsmPEImportDirectory* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEImportDirectory* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEImportDirectory::pool_size * sizeof(SgAsmPEImportDirectory))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEImportDirectory*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEImportDirectory::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35061 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEImportDirectoryList*  SgAsmPEImportDirectoryList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEImportDirectoryList* poolStart = reinterpret_cast<SgAsmPEImportDirectoryList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEImportDirectoryList::getNodeIdStringInternal(SgAsmPEImportDirectoryList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEImportDirectoryList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEImportDirectoryList::pool_size * sizeof(SgAsmPEImportDirectoryList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEImportDirectoryList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEImportDirectoryList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35098 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEImportItem*  SgAsmPEImportItem::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEImportItem* poolStart = reinterpret_cast<SgAsmPEImportItem*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEImportItem::getNodeIdStringInternal(SgAsmPEImportItem* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEImportItem* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEImportItem::pool_size * sizeof(SgAsmPEImportItem))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEImportItem*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEImportItem::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35135 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPEImportItemList*  SgAsmPEImportItemList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPEImportItemList* poolStart = reinterpret_cast<SgAsmPEImportItemList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPEImportItemList::getNodeIdStringInternal(SgAsmPEImportItemList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPEImportItemList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPEImportItemList::pool_size * sizeof(SgAsmPEImportItemList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPEImportItemList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPEImportItemList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35172 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPERVASizePair*  SgAsmPERVASizePair::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPERVASizePair* poolStart = reinterpret_cast<SgAsmPERVASizePair*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPERVASizePair::getNodeIdStringInternal(SgAsmPERVASizePair* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPERVASizePair* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPERVASizePair::pool_size * sizeof(SgAsmPERVASizePair))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPERVASizePair*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPERVASizePair::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35209 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPERVASizePairList*  SgAsmPERVASizePairList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPERVASizePairList* poolStart = reinterpret_cast<SgAsmPERVASizePairList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPERVASizePairList::getNodeIdStringInternal(SgAsmPERVASizePairList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPERVASizePairList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPERVASizePairList::pool_size * sizeof(SgAsmPERVASizePairList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPERVASizePairList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPERVASizePairList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35246 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPESectionTableEntry*  SgAsmPESectionTableEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPESectionTableEntry* poolStart = reinterpret_cast<SgAsmPESectionTableEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPESectionTableEntry::getNodeIdStringInternal(SgAsmPESectionTableEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPESectionTableEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPESectionTableEntry::pool_size * sizeof(SgAsmPESectionTableEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPESectionTableEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPESectionTableEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35283 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmStringStorage*  SgAsmStringStorage::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmStringStorage* poolStart = reinterpret_cast<SgAsmStringStorage*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmStringStorage::getNodeIdStringInternal(SgAsmStringStorage* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmStringStorage* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmStringStorage::pool_size * sizeof(SgAsmStringStorage))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmStringStorage*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmStringStorage::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35320 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmExpression*  SgAsmExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmExpression* poolStart = reinterpret_cast<SgAsmExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmExpression::getNodeIdStringInternal(SgAsmExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmExpression::pool_size * sizeof(SgAsmExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35357 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmAarch32Coprocessor*  SgAsmAarch32Coprocessor::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmAarch32Coprocessor* poolStart = reinterpret_cast<SgAsmAarch32Coprocessor*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmAarch32Coprocessor::getNodeIdStringInternal(SgAsmAarch32Coprocessor* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmAarch32Coprocessor* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmAarch32Coprocessor::pool_size * sizeof(SgAsmAarch32Coprocessor))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmAarch32Coprocessor*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmAarch32Coprocessor::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35394 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryExpression*  SgAsmBinaryExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryExpression* poolStart = reinterpret_cast<SgAsmBinaryExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryExpression::getNodeIdStringInternal(SgAsmBinaryExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryExpression::pool_size * sizeof(SgAsmBinaryExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35431 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryAdd*  SgAsmBinaryAdd::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryAdd* poolStart = reinterpret_cast<SgAsmBinaryAdd*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryAdd::getNodeIdStringInternal(SgAsmBinaryAdd* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryAdd* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryAdd::pool_size * sizeof(SgAsmBinaryAdd))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryAdd*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryAdd::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35468 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryAsr*  SgAsmBinaryAsr::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryAsr* poolStart = reinterpret_cast<SgAsmBinaryAsr*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryAsr::getNodeIdStringInternal(SgAsmBinaryAsr* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryAsr* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryAsr::pool_size * sizeof(SgAsmBinaryAsr))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryAsr*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryAsr::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35505 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryConcat*  SgAsmBinaryConcat::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryConcat* poolStart = reinterpret_cast<SgAsmBinaryConcat*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryConcat::getNodeIdStringInternal(SgAsmBinaryConcat* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryConcat* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryConcat::pool_size * sizeof(SgAsmBinaryConcat))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryConcat*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryConcat::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35542 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryDivide*  SgAsmBinaryDivide::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryDivide* poolStart = reinterpret_cast<SgAsmBinaryDivide*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryDivide::getNodeIdStringInternal(SgAsmBinaryDivide* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryDivide* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryDivide::pool_size * sizeof(SgAsmBinaryDivide))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryDivide*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryDivide::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35579 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryLsl*  SgAsmBinaryLsl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryLsl* poolStart = reinterpret_cast<SgAsmBinaryLsl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryLsl::getNodeIdStringInternal(SgAsmBinaryLsl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryLsl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryLsl::pool_size * sizeof(SgAsmBinaryLsl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryLsl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryLsl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35616 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryLsr*  SgAsmBinaryLsr::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryLsr* poolStart = reinterpret_cast<SgAsmBinaryLsr*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryLsr::getNodeIdStringInternal(SgAsmBinaryLsr* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryLsr* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryLsr::pool_size * sizeof(SgAsmBinaryLsr))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryLsr*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryLsr::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35653 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryMod*  SgAsmBinaryMod::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryMod* poolStart = reinterpret_cast<SgAsmBinaryMod*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryMod::getNodeIdStringInternal(SgAsmBinaryMod* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryMod* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryMod::pool_size * sizeof(SgAsmBinaryMod))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryMod*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryMod::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35690 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryMsl*  SgAsmBinaryMsl::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryMsl* poolStart = reinterpret_cast<SgAsmBinaryMsl*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryMsl::getNodeIdStringInternal(SgAsmBinaryMsl* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryMsl* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryMsl::pool_size * sizeof(SgAsmBinaryMsl))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryMsl*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryMsl::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35727 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryMultiply*  SgAsmBinaryMultiply::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryMultiply* poolStart = reinterpret_cast<SgAsmBinaryMultiply*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryMultiply::getNodeIdStringInternal(SgAsmBinaryMultiply* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryMultiply* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryMultiply::pool_size * sizeof(SgAsmBinaryMultiply))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryMultiply*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryMultiply::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35764 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryPostupdate*  SgAsmBinaryPostupdate::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryPostupdate* poolStart = reinterpret_cast<SgAsmBinaryPostupdate*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryPostupdate::getNodeIdStringInternal(SgAsmBinaryPostupdate* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryPostupdate* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryPostupdate::pool_size * sizeof(SgAsmBinaryPostupdate))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryPostupdate*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryPostupdate::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35801 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryPreupdate*  SgAsmBinaryPreupdate::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryPreupdate* poolStart = reinterpret_cast<SgAsmBinaryPreupdate*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryPreupdate::getNodeIdStringInternal(SgAsmBinaryPreupdate* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryPreupdate* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryPreupdate::pool_size * sizeof(SgAsmBinaryPreupdate))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryPreupdate*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryPreupdate::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35838 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinaryRor*  SgAsmBinaryRor::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinaryRor* poolStart = reinterpret_cast<SgAsmBinaryRor*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinaryRor::getNodeIdStringInternal(SgAsmBinaryRor* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinaryRor* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinaryRor::pool_size * sizeof(SgAsmBinaryRor))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinaryRor*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinaryRor::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35875 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBinarySubtract*  SgAsmBinarySubtract::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBinarySubtract* poolStart = reinterpret_cast<SgAsmBinarySubtract*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBinarySubtract::getNodeIdStringInternal(SgAsmBinarySubtract* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBinarySubtract* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBinarySubtract::pool_size * sizeof(SgAsmBinarySubtract))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBinarySubtract*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBinarySubtract::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35912 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmByteOrder*  SgAsmByteOrder::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmByteOrder* poolStart = reinterpret_cast<SgAsmByteOrder*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmByteOrder::getNodeIdStringInternal(SgAsmByteOrder* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmByteOrder* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmByteOrder::pool_size * sizeof(SgAsmByteOrder))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmByteOrder*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmByteOrder::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35949 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCommonSubExpression*  SgAsmCommonSubExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCommonSubExpression* poolStart = reinterpret_cast<SgAsmCommonSubExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCommonSubExpression::getNodeIdStringInternal(SgAsmCommonSubExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCommonSubExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCommonSubExpression::pool_size * sizeof(SgAsmCommonSubExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCommonSubExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCommonSubExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 35986 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmControlFlagsExpression*  SgAsmControlFlagsExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmControlFlagsExpression* poolStart = reinterpret_cast<SgAsmControlFlagsExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmControlFlagsExpression::getNodeIdStringInternal(SgAsmControlFlagsExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmControlFlagsExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmControlFlagsExpression::pool_size * sizeof(SgAsmControlFlagsExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmControlFlagsExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmControlFlagsExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36023 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmExprListExp*  SgAsmExprListExp::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmExprListExp* poolStart = reinterpret_cast<SgAsmExprListExp*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmExprListExp::getNodeIdStringInternal(SgAsmExprListExp* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmExprListExp* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmExprListExp::pool_size * sizeof(SgAsmExprListExp))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmExprListExp*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmExprListExp::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36060 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmMemoryReferenceExpression*  SgAsmMemoryReferenceExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmMemoryReferenceExpression* poolStart = reinterpret_cast<SgAsmMemoryReferenceExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmMemoryReferenceExpression::getNodeIdStringInternal(SgAsmMemoryReferenceExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmMemoryReferenceExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmMemoryReferenceExpression::pool_size * sizeof(SgAsmMemoryReferenceExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmMemoryReferenceExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmMemoryReferenceExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36097 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmRegisterNames*  SgAsmRegisterNames::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmRegisterNames* poolStart = reinterpret_cast<SgAsmRegisterNames*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmRegisterNames::getNodeIdStringInternal(SgAsmRegisterNames* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmRegisterNames* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmRegisterNames::pool_size * sizeof(SgAsmRegisterNames))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmRegisterNames*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmRegisterNames::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36134 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmRegisterReferenceExpression*  SgAsmRegisterReferenceExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmRegisterReferenceExpression* poolStart = reinterpret_cast<SgAsmRegisterReferenceExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmRegisterReferenceExpression::getNodeIdStringInternal(SgAsmRegisterReferenceExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmRegisterReferenceExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmRegisterReferenceExpression::pool_size * sizeof(SgAsmRegisterReferenceExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmRegisterReferenceExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmRegisterReferenceExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36171 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmDirectRegisterExpression*  SgAsmDirectRegisterExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmDirectRegisterExpression* poolStart = reinterpret_cast<SgAsmDirectRegisterExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmDirectRegisterExpression::getNodeIdStringInternal(SgAsmDirectRegisterExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmDirectRegisterExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmDirectRegisterExpression::pool_size * sizeof(SgAsmDirectRegisterExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmDirectRegisterExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmDirectRegisterExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36208 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmIndirectRegisterExpression*  SgAsmIndirectRegisterExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmIndirectRegisterExpression* poolStart = reinterpret_cast<SgAsmIndirectRegisterExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmIndirectRegisterExpression::getNodeIdStringInternal(SgAsmIndirectRegisterExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmIndirectRegisterExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmIndirectRegisterExpression::pool_size * sizeof(SgAsmIndirectRegisterExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmIndirectRegisterExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmIndirectRegisterExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36245 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmRiscOperation*  SgAsmRiscOperation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmRiscOperation* poolStart = reinterpret_cast<SgAsmRiscOperation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmRiscOperation::getNodeIdStringInternal(SgAsmRiscOperation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmRiscOperation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmRiscOperation::pool_size * sizeof(SgAsmRiscOperation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmRiscOperation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmRiscOperation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36282 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmStackExpression*  SgAsmStackExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmStackExpression* poolStart = reinterpret_cast<SgAsmStackExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmStackExpression::getNodeIdStringInternal(SgAsmStackExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmStackExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmStackExpression::pool_size * sizeof(SgAsmStackExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmStackExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmStackExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36319 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUnaryExpression*  SgAsmUnaryExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUnaryExpression* poolStart = reinterpret_cast<SgAsmUnaryExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUnaryExpression::getNodeIdStringInternal(SgAsmUnaryExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUnaryExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUnaryExpression::pool_size * sizeof(SgAsmUnaryExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUnaryExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUnaryExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36356 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUnaryMinus*  SgAsmUnaryMinus::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUnaryMinus* poolStart = reinterpret_cast<SgAsmUnaryMinus*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUnaryMinus::getNodeIdStringInternal(SgAsmUnaryMinus* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUnaryMinus* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUnaryMinus::pool_size * sizeof(SgAsmUnaryMinus))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUnaryMinus*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUnaryMinus::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36393 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUnaryPlus*  SgAsmUnaryPlus::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUnaryPlus* poolStart = reinterpret_cast<SgAsmUnaryPlus*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUnaryPlus::getNodeIdStringInternal(SgAsmUnaryPlus* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUnaryPlus* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUnaryPlus::pool_size * sizeof(SgAsmUnaryPlus))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUnaryPlus*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUnaryPlus::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36430 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUnaryRrx*  SgAsmUnaryRrx::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUnaryRrx* poolStart = reinterpret_cast<SgAsmUnaryRrx*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUnaryRrx::getNodeIdStringInternal(SgAsmUnaryRrx* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUnaryRrx* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUnaryRrx::pool_size * sizeof(SgAsmUnaryRrx))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUnaryRrx*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUnaryRrx::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36467 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUnarySignedExtend*  SgAsmUnarySignedExtend::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUnarySignedExtend* poolStart = reinterpret_cast<SgAsmUnarySignedExtend*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUnarySignedExtend::getNodeIdStringInternal(SgAsmUnarySignedExtend* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUnarySignedExtend* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUnarySignedExtend::pool_size * sizeof(SgAsmUnarySignedExtend))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUnarySignedExtend*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUnarySignedExtend::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36504 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUnaryTruncate*  SgAsmUnaryTruncate::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUnaryTruncate* poolStart = reinterpret_cast<SgAsmUnaryTruncate*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUnaryTruncate::getNodeIdStringInternal(SgAsmUnaryTruncate* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUnaryTruncate* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUnaryTruncate::pool_size * sizeof(SgAsmUnaryTruncate))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUnaryTruncate*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUnaryTruncate::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36541 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUnaryUnsignedExtend*  SgAsmUnaryUnsignedExtend::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUnaryUnsignedExtend* poolStart = reinterpret_cast<SgAsmUnaryUnsignedExtend*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUnaryUnsignedExtend::getNodeIdStringInternal(SgAsmUnaryUnsignedExtend* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUnaryUnsignedExtend* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUnaryUnsignedExtend::pool_size * sizeof(SgAsmUnaryUnsignedExtend))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUnaryUnsignedExtend*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUnaryUnsignedExtend::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36578 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmValueExpression*  SgAsmValueExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmValueExpression* poolStart = reinterpret_cast<SgAsmValueExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmValueExpression::getNodeIdStringInternal(SgAsmValueExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmValueExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmValueExpression::pool_size * sizeof(SgAsmValueExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmValueExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmValueExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36615 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmConstantExpression*  SgAsmConstantExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmConstantExpression* poolStart = reinterpret_cast<SgAsmConstantExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmConstantExpression::getNodeIdStringInternal(SgAsmConstantExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmConstantExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmConstantExpression::pool_size * sizeof(SgAsmConstantExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmConstantExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmConstantExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36652 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmFloatValueExpression*  SgAsmFloatValueExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmFloatValueExpression* poolStart = reinterpret_cast<SgAsmFloatValueExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmFloatValueExpression::getNodeIdStringInternal(SgAsmFloatValueExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmFloatValueExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmFloatValueExpression::pool_size * sizeof(SgAsmFloatValueExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmFloatValueExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmFloatValueExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36689 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmIntegerValueExpression*  SgAsmIntegerValueExpression::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmIntegerValueExpression* poolStart = reinterpret_cast<SgAsmIntegerValueExpression*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmIntegerValueExpression::getNodeIdStringInternal(SgAsmIntegerValueExpression* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmIntegerValueExpression* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmIntegerValueExpression::pool_size * sizeof(SgAsmIntegerValueExpression))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmIntegerValueExpression*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmIntegerValueExpression::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36726 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmGenericFileList*  SgAsmGenericFileList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmGenericFileList* poolStart = reinterpret_cast<SgAsmGenericFileList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmGenericFileList::getNodeIdStringInternal(SgAsmGenericFileList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmGenericFileList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmGenericFileList::pool_size * sizeof(SgAsmGenericFileList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmGenericFileList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmGenericFileList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36763 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmInstructionList*  SgAsmInstructionList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmInstructionList* poolStart = reinterpret_cast<SgAsmInstructionList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmInstructionList::getNodeIdStringInternal(SgAsmInstructionList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmInstructionList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmInstructionList::pool_size * sizeof(SgAsmInstructionList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmInstructionList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmInstructionList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36800 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmInterpretation*  SgAsmInterpretation::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmInterpretation* poolStart = reinterpret_cast<SgAsmInterpretation*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmInterpretation::getNodeIdStringInternal(SgAsmInterpretation* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmInterpretation* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmInterpretation::pool_size * sizeof(SgAsmInterpretation))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmInterpretation*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmInterpretation::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36837 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmInterpretationList*  SgAsmInterpretationList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmInterpretationList* poolStart = reinterpret_cast<SgAsmInterpretationList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmInterpretationList::getNodeIdStringInternal(SgAsmInterpretationList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmInterpretationList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmInterpretationList::pool_size * sizeof(SgAsmInterpretationList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmInterpretationList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmInterpretationList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36874 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmNode*  SgAsmJvmNode::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmNode* poolStart = reinterpret_cast<SgAsmJvmNode*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmNode::getNodeIdStringInternal(SgAsmJvmNode* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmNode* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmNode::pool_size * sizeof(SgAsmJvmNode))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmNode*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmNode::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36911 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmAttribute*  SgAsmJvmAttribute::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmAttribute* poolStart = reinterpret_cast<SgAsmJvmAttribute*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmAttribute::getNodeIdStringInternal(SgAsmJvmAttribute* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmAttribute* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmAttribute::pool_size * sizeof(SgAsmJvmAttribute))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmAttribute*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmAttribute::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36948 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmBootstrapMethods*  SgAsmJvmBootstrapMethods::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmBootstrapMethods* poolStart = reinterpret_cast<SgAsmJvmBootstrapMethods*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmBootstrapMethods::getNodeIdStringInternal(SgAsmJvmBootstrapMethods* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmBootstrapMethods* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmBootstrapMethods::pool_size * sizeof(SgAsmJvmBootstrapMethods))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmBootstrapMethods*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmBootstrapMethods::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 36985 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmCodeAttribute*  SgAsmJvmCodeAttribute::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmCodeAttribute* poolStart = reinterpret_cast<SgAsmJvmCodeAttribute*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmCodeAttribute::getNodeIdStringInternal(SgAsmJvmCodeAttribute* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmCodeAttribute* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmCodeAttribute::pool_size * sizeof(SgAsmJvmCodeAttribute))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmCodeAttribute*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmCodeAttribute::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37022 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmConstantValue*  SgAsmJvmConstantValue::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmConstantValue* poolStart = reinterpret_cast<SgAsmJvmConstantValue*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmConstantValue::getNodeIdStringInternal(SgAsmJvmConstantValue* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmConstantValue* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmConstantValue::pool_size * sizeof(SgAsmJvmConstantValue))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmConstantValue*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmConstantValue::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37059 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmDeprecated*  SgAsmJvmDeprecated::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmDeprecated* poolStart = reinterpret_cast<SgAsmJvmDeprecated*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmDeprecated::getNodeIdStringInternal(SgAsmJvmDeprecated* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmDeprecated* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmDeprecated::pool_size * sizeof(SgAsmJvmDeprecated))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmDeprecated*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmDeprecated::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37096 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmEnclosingMethod*  SgAsmJvmEnclosingMethod::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmEnclosingMethod* poolStart = reinterpret_cast<SgAsmJvmEnclosingMethod*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmEnclosingMethod::getNodeIdStringInternal(SgAsmJvmEnclosingMethod* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmEnclosingMethod* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmEnclosingMethod::pool_size * sizeof(SgAsmJvmEnclosingMethod))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmEnclosingMethod*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmEnclosingMethod::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37133 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmExceptions*  SgAsmJvmExceptions::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmExceptions* poolStart = reinterpret_cast<SgAsmJvmExceptions*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmExceptions::getNodeIdStringInternal(SgAsmJvmExceptions* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmExceptions* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmExceptions::pool_size * sizeof(SgAsmJvmExceptions))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmExceptions*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmExceptions::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37170 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmInnerClasses*  SgAsmJvmInnerClasses::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmInnerClasses* poolStart = reinterpret_cast<SgAsmJvmInnerClasses*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmInnerClasses::getNodeIdStringInternal(SgAsmJvmInnerClasses* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmInnerClasses* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmInnerClasses::pool_size * sizeof(SgAsmJvmInnerClasses))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmInnerClasses*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmInnerClasses::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37207 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmLineNumberTable*  SgAsmJvmLineNumberTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmLineNumberTable* poolStart = reinterpret_cast<SgAsmJvmLineNumberTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmLineNumberTable::getNodeIdStringInternal(SgAsmJvmLineNumberTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmLineNumberTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmLineNumberTable::pool_size * sizeof(SgAsmJvmLineNumberTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmLineNumberTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmLineNumberTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37244 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmLocalVariableTable*  SgAsmJvmLocalVariableTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmLocalVariableTable* poolStart = reinterpret_cast<SgAsmJvmLocalVariableTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmLocalVariableTable::getNodeIdStringInternal(SgAsmJvmLocalVariableTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmLocalVariableTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmLocalVariableTable::pool_size * sizeof(SgAsmJvmLocalVariableTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmLocalVariableTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmLocalVariableTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37281 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmLocalVariableTypeTable*  SgAsmJvmLocalVariableTypeTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmLocalVariableTypeTable* poolStart = reinterpret_cast<SgAsmJvmLocalVariableTypeTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmLocalVariableTypeTable::getNodeIdStringInternal(SgAsmJvmLocalVariableTypeTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmLocalVariableTypeTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmLocalVariableTypeTable::pool_size * sizeof(SgAsmJvmLocalVariableTypeTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmLocalVariableTypeTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmLocalVariableTypeTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37318 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmMethodParameters*  SgAsmJvmMethodParameters::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmMethodParameters* poolStart = reinterpret_cast<SgAsmJvmMethodParameters*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmMethodParameters::getNodeIdStringInternal(SgAsmJvmMethodParameters* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmMethodParameters* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmMethodParameters::pool_size * sizeof(SgAsmJvmMethodParameters))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmMethodParameters*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmMethodParameters::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37355 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmModuleMainClass*  SgAsmJvmModuleMainClass::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmModuleMainClass* poolStart = reinterpret_cast<SgAsmJvmModuleMainClass*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmModuleMainClass::getNodeIdStringInternal(SgAsmJvmModuleMainClass* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmModuleMainClass* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmModuleMainClass::pool_size * sizeof(SgAsmJvmModuleMainClass))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmModuleMainClass*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmModuleMainClass::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37392 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmNestHost*  SgAsmJvmNestHost::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmNestHost* poolStart = reinterpret_cast<SgAsmJvmNestHost*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmNestHost::getNodeIdStringInternal(SgAsmJvmNestHost* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmNestHost* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmNestHost::pool_size * sizeof(SgAsmJvmNestHost))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmNestHost*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmNestHost::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37429 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmNestMembers*  SgAsmJvmNestMembers::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmNestMembers* poolStart = reinterpret_cast<SgAsmJvmNestMembers*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmNestMembers::getNodeIdStringInternal(SgAsmJvmNestMembers* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmNestMembers* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmNestMembers::pool_size * sizeof(SgAsmJvmNestMembers))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmNestMembers*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmNestMembers::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37466 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmSignature*  SgAsmJvmSignature::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmSignature* poolStart = reinterpret_cast<SgAsmJvmSignature*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmSignature::getNodeIdStringInternal(SgAsmJvmSignature* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmSignature* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmSignature::pool_size * sizeof(SgAsmJvmSignature))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmSignature*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmSignature::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37503 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmSourceFile*  SgAsmJvmSourceFile::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmSourceFile* poolStart = reinterpret_cast<SgAsmJvmSourceFile*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmSourceFile::getNodeIdStringInternal(SgAsmJvmSourceFile* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmSourceFile* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmSourceFile::pool_size * sizeof(SgAsmJvmSourceFile))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmSourceFile*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmSourceFile::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37540 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmStackMapTable*  SgAsmJvmStackMapTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmStackMapTable* poolStart = reinterpret_cast<SgAsmJvmStackMapTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmStackMapTable::getNodeIdStringInternal(SgAsmJvmStackMapTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmStackMapTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmStackMapTable::pool_size * sizeof(SgAsmJvmStackMapTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmStackMapTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmStackMapTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37577 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmSynthetic*  SgAsmJvmSynthetic::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmSynthetic* poolStart = reinterpret_cast<SgAsmJvmSynthetic*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmSynthetic::getNodeIdStringInternal(SgAsmJvmSynthetic* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmSynthetic* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmSynthetic::pool_size * sizeof(SgAsmJvmSynthetic))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmSynthetic*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmSynthetic::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37614 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmBootstrapMethod*  SgAsmJvmBootstrapMethod::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmBootstrapMethod* poolStart = reinterpret_cast<SgAsmJvmBootstrapMethod*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmBootstrapMethod::getNodeIdStringInternal(SgAsmJvmBootstrapMethod* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmBootstrapMethod* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmBootstrapMethod::pool_size * sizeof(SgAsmJvmBootstrapMethod))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmBootstrapMethod*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmBootstrapMethod::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37651 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmClass*  SgAsmJvmClass::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmClass* poolStart = reinterpret_cast<SgAsmJvmClass*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmClass::getNodeIdStringInternal(SgAsmJvmClass* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmClass* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmClass::pool_size * sizeof(SgAsmJvmClass))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmClass*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmClass::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37688 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmConstantPoolEntry*  SgAsmJvmConstantPoolEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmConstantPoolEntry* poolStart = reinterpret_cast<SgAsmJvmConstantPoolEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmConstantPoolEntry::getNodeIdStringInternal(SgAsmJvmConstantPoolEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmConstantPoolEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmConstantPoolEntry::pool_size * sizeof(SgAsmJvmConstantPoolEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmConstantPoolEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmConstantPoolEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37725 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmExceptionHandler*  SgAsmJvmExceptionHandler::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmExceptionHandler* poolStart = reinterpret_cast<SgAsmJvmExceptionHandler*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmExceptionHandler::getNodeIdStringInternal(SgAsmJvmExceptionHandler* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmExceptionHandler* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmExceptionHandler::pool_size * sizeof(SgAsmJvmExceptionHandler))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmExceptionHandler*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmExceptionHandler::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37762 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmExceptionTable*  SgAsmJvmExceptionTable::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmExceptionTable* poolStart = reinterpret_cast<SgAsmJvmExceptionTable*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmExceptionTable::getNodeIdStringInternal(SgAsmJvmExceptionTable* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmExceptionTable* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmExceptionTable::pool_size * sizeof(SgAsmJvmExceptionTable))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmExceptionTable*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmExceptionTable::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37799 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmField*  SgAsmJvmField::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmField* poolStart = reinterpret_cast<SgAsmJvmField*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmField::getNodeIdStringInternal(SgAsmJvmField* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmField* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmField::pool_size * sizeof(SgAsmJvmField))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmField*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmField::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37836 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmInnerClassesEntry*  SgAsmJvmInnerClassesEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmInnerClassesEntry* poolStart = reinterpret_cast<SgAsmJvmInnerClassesEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmInnerClassesEntry::getNodeIdStringInternal(SgAsmJvmInnerClassesEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmInnerClassesEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmInnerClassesEntry::pool_size * sizeof(SgAsmJvmInnerClassesEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmInnerClassesEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmInnerClassesEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37873 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmLineNumberEntry*  SgAsmJvmLineNumberEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmLineNumberEntry* poolStart = reinterpret_cast<SgAsmJvmLineNumberEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmLineNumberEntry::getNodeIdStringInternal(SgAsmJvmLineNumberEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmLineNumberEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmLineNumberEntry::pool_size * sizeof(SgAsmJvmLineNumberEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmLineNumberEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmLineNumberEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37910 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmLocalVariableEntry*  SgAsmJvmLocalVariableEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmLocalVariableEntry* poolStart = reinterpret_cast<SgAsmJvmLocalVariableEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmLocalVariableEntry::getNodeIdStringInternal(SgAsmJvmLocalVariableEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmLocalVariableEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmLocalVariableEntry::pool_size * sizeof(SgAsmJvmLocalVariableEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmLocalVariableEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmLocalVariableEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37947 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmLocalVariableTypeEntry*  SgAsmJvmLocalVariableTypeEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmLocalVariableTypeEntry* poolStart = reinterpret_cast<SgAsmJvmLocalVariableTypeEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmLocalVariableTypeEntry::getNodeIdStringInternal(SgAsmJvmLocalVariableTypeEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmLocalVariableTypeEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmLocalVariableTypeEntry::pool_size * sizeof(SgAsmJvmLocalVariableTypeEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmLocalVariableTypeEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmLocalVariableTypeEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 37984 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmMethod*  SgAsmJvmMethod::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmMethod* poolStart = reinterpret_cast<SgAsmJvmMethod*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmMethod::getNodeIdStringInternal(SgAsmJvmMethod* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmMethod* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmMethod::pool_size * sizeof(SgAsmJvmMethod))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmMethod*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmMethod::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38021 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmMethodParametersEntry*  SgAsmJvmMethodParametersEntry::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmMethodParametersEntry* poolStart = reinterpret_cast<SgAsmJvmMethodParametersEntry*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmMethodParametersEntry::getNodeIdStringInternal(SgAsmJvmMethodParametersEntry* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmMethodParametersEntry* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmMethodParametersEntry::pool_size * sizeof(SgAsmJvmMethodParametersEntry))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmMethodParametersEntry*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmMethodParametersEntry::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38058 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmStackMapFrame*  SgAsmJvmStackMapFrame::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmStackMapFrame* poolStart = reinterpret_cast<SgAsmJvmStackMapFrame*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmStackMapFrame::getNodeIdStringInternal(SgAsmJvmStackMapFrame* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmStackMapFrame* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmStackMapFrame::pool_size * sizeof(SgAsmJvmStackMapFrame))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmStackMapFrame*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmStackMapFrame::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38095 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmStackMapVerificationType*  SgAsmJvmStackMapVerificationType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmStackMapVerificationType* poolStart = reinterpret_cast<SgAsmJvmStackMapVerificationType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmStackMapVerificationType::getNodeIdStringInternal(SgAsmJvmStackMapVerificationType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmStackMapVerificationType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmStackMapVerificationType::pool_size * sizeof(SgAsmJvmStackMapVerificationType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmStackMapVerificationType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmStackMapVerificationType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38132 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmOperandList*  SgAsmOperandList::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmOperandList* poolStart = reinterpret_cast<SgAsmOperandList*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmOperandList::getNodeIdStringInternal(SgAsmOperandList* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmOperandList* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmOperandList::pool_size * sizeof(SgAsmOperandList))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmOperandList*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmOperandList::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38169 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmStatement*  SgAsmStatement::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmStatement* poolStart = reinterpret_cast<SgAsmStatement*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmStatement::getNodeIdStringInternal(SgAsmStatement* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmStatement* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmStatement::pool_size * sizeof(SgAsmStatement))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmStatement*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmStatement::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38206 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmBlock*  SgAsmBlock::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmBlock* poolStart = reinterpret_cast<SgAsmBlock*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmBlock::getNodeIdStringInternal(SgAsmBlock* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmBlock* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmBlock::pool_size * sizeof(SgAsmBlock))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmBlock*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmBlock::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38243 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmInstruction*  SgAsmInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmInstruction* poolStart = reinterpret_cast<SgAsmInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmInstruction::getNodeIdStringInternal(SgAsmInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmInstruction::pool_size * sizeof(SgAsmInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38280 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmCilInstruction*  SgAsmCilInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmCilInstruction* poolStart = reinterpret_cast<SgAsmCilInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmCilInstruction::getNodeIdStringInternal(SgAsmCilInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmCilInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmCilInstruction::pool_size * sizeof(SgAsmCilInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmCilInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmCilInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38317 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmJvmInstruction*  SgAsmJvmInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmJvmInstruction* poolStart = reinterpret_cast<SgAsmJvmInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmJvmInstruction::getNodeIdStringInternal(SgAsmJvmInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmJvmInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmJvmInstruction::pool_size * sizeof(SgAsmJvmInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmJvmInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmJvmInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38354 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmM68kInstruction*  SgAsmM68kInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmM68kInstruction* poolStart = reinterpret_cast<SgAsmM68kInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmM68kInstruction::getNodeIdStringInternal(SgAsmM68kInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmM68kInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmM68kInstruction::pool_size * sizeof(SgAsmM68kInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmM68kInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmM68kInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38391 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmMipsInstruction*  SgAsmMipsInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmMipsInstruction* poolStart = reinterpret_cast<SgAsmMipsInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmMipsInstruction::getNodeIdStringInternal(SgAsmMipsInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmMipsInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmMipsInstruction::pool_size * sizeof(SgAsmMipsInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmMipsInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmMipsInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38428 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmNullInstruction*  SgAsmNullInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmNullInstruction* poolStart = reinterpret_cast<SgAsmNullInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmNullInstruction::getNodeIdStringInternal(SgAsmNullInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmNullInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmNullInstruction::pool_size * sizeof(SgAsmNullInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmNullInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmNullInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38465 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPowerpcInstruction*  SgAsmPowerpcInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPowerpcInstruction* poolStart = reinterpret_cast<SgAsmPowerpcInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPowerpcInstruction::getNodeIdStringInternal(SgAsmPowerpcInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPowerpcInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPowerpcInstruction::pool_size * sizeof(SgAsmPowerpcInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPowerpcInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPowerpcInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38502 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmUserInstruction*  SgAsmUserInstruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmUserInstruction* poolStart = reinterpret_cast<SgAsmUserInstruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmUserInstruction::getNodeIdStringInternal(SgAsmUserInstruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmUserInstruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmUserInstruction::pool_size * sizeof(SgAsmUserInstruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmUserInstruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmUserInstruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38539 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmX86Instruction*  SgAsmX86Instruction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmX86Instruction* poolStart = reinterpret_cast<SgAsmX86Instruction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmX86Instruction::getNodeIdStringInternal(SgAsmX86Instruction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmX86Instruction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmX86Instruction::pool_size * sizeof(SgAsmX86Instruction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmX86Instruction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmX86Instruction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38576 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmStaticData*  SgAsmStaticData::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmStaticData* poolStart = reinterpret_cast<SgAsmStaticData*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmStaticData::getNodeIdStringInternal(SgAsmStaticData* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmStaticData* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmStaticData::pool_size * sizeof(SgAsmStaticData))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmStaticData*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmStaticData::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38613 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmSynthesizedDeclaration*  SgAsmSynthesizedDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmSynthesizedDeclaration* poolStart = reinterpret_cast<SgAsmSynthesizedDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmSynthesizedDeclaration::getNodeIdStringInternal(SgAsmSynthesizedDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmSynthesizedDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmSynthesizedDeclaration::pool_size * sizeof(SgAsmSynthesizedDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmSynthesizedDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmSynthesizedDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38650 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmFunction*  SgAsmFunction::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmFunction* poolStart = reinterpret_cast<SgAsmFunction*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmFunction::getNodeIdStringInternal(SgAsmFunction* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmFunction* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmFunction::pool_size * sizeof(SgAsmFunction))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmFunction*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmFunction::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38687 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmSynthesizedDataStructureDeclaration*  SgAsmSynthesizedDataStructureDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmSynthesizedDataStructureDeclaration* poolStart = reinterpret_cast<SgAsmSynthesizedDataStructureDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmSynthesizedDataStructureDeclaration::getNodeIdStringInternal(SgAsmSynthesizedDataStructureDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmSynthesizedDataStructureDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmSynthesizedDataStructureDeclaration::pool_size * sizeof(SgAsmSynthesizedDataStructureDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmSynthesizedDataStructureDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmSynthesizedDataStructureDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38724 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmSynthesizedFieldDeclaration*  SgAsmSynthesizedFieldDeclaration::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmSynthesizedFieldDeclaration* poolStart = reinterpret_cast<SgAsmSynthesizedFieldDeclaration*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmSynthesizedFieldDeclaration::getNodeIdStringInternal(SgAsmSynthesizedFieldDeclaration* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmSynthesizedFieldDeclaration* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmSynthesizedFieldDeclaration::pool_size * sizeof(SgAsmSynthesizedFieldDeclaration))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmSynthesizedFieldDeclaration*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmSynthesizedFieldDeclaration::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38761 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmType*  SgAsmType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmType* poolStart = reinterpret_cast<SgAsmType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmType::getNodeIdStringInternal(SgAsmType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmType::pool_size * sizeof(SgAsmType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38798 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmScalarType*  SgAsmScalarType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmScalarType* poolStart = reinterpret_cast<SgAsmScalarType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmScalarType::getNodeIdStringInternal(SgAsmScalarType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmScalarType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmScalarType::pool_size * sizeof(SgAsmScalarType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmScalarType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmScalarType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38835 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmFloatType*  SgAsmFloatType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmFloatType* poolStart = reinterpret_cast<SgAsmFloatType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmFloatType::getNodeIdStringInternal(SgAsmFloatType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmFloatType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmFloatType::pool_size * sizeof(SgAsmFloatType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmFloatType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmFloatType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38872 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmIntegerType*  SgAsmIntegerType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmIntegerType* poolStart = reinterpret_cast<SgAsmIntegerType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmIntegerType::getNodeIdStringInternal(SgAsmIntegerType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmIntegerType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmIntegerType::pool_size * sizeof(SgAsmIntegerType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmIntegerType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmIntegerType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38909 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmPointerType*  SgAsmPointerType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmPointerType* poolStart = reinterpret_cast<SgAsmPointerType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmPointerType::getNodeIdStringInternal(SgAsmPointerType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmPointerType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmPointerType::pool_size * sizeof(SgAsmPointerType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmPointerType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmPointerType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38946 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmVectorType*  SgAsmVectorType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmVectorType* poolStart = reinterpret_cast<SgAsmVectorType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmVectorType::getNodeIdStringInternal(SgAsmVectorType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmVectorType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmVectorType::pool_size * sizeof(SgAsmVectorType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmVectorType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmVectorType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }

/* #line 38983 "/workspace/generated/src/frontend/SageIII//Cxx_GrammarNodeIdSupport.C" */

/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarNodeId.macro" */

SgAsmVoidType*  SgAsmVoidType::getNodeByNodeIdInternal(size_t poolIdx, size_t itemIdx)
  {          
     ROSE_ASSERT(poolIdx < pools.size());
     SgAsmVoidType* poolStart = reinterpret_cast<SgAsmVoidType*>(pools[poolIdx]);
      
     ROSE_ASSERT(itemIdx < pool_size);
     return poolStart+itemIdx; 
  }


std::string SgAsmVoidType::getNodeIdStringInternal(SgAsmVoidType* node)
  {       
     // Do a linear search for a pool that contains this node (because pools are not sorted)
     auto poolIt = pools.begin();
     SgAsmVoidType* poolStart = nullptr;
     for(;poolIt != pools.end(); ++poolIt) {
       //Check for containment by seeing if the node pointer is contined in the range of the pool
       if(*poolIt <= (unsigned char*) node && (*poolIt + (SgAsmVoidType::pool_size * sizeof(SgAsmVoidType))) > (unsigned char*) node) {
	 poolStart = reinterpret_cast<SgAsmVoidType*>(*poolIt);
	 break;
       } 
     }	
     ROSE_ASSERT(poolStart != nullptr);
     size_t poolIdx = std::distance(pools.begin(), poolIt);  //Check this to make index from iterator
  
     ROSE_ASSERT(node >= poolStart && node <  poolStart + SgAsmVoidType::pool_size);
     size_t itemIdx = std::distance(poolStart, node);
  
     std::stringstream ss;
     ss << poolIdx << "_" << itemIdx;
     return ss.str();
  }


