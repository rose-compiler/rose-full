/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStaticDataManagingClassSource.macro" */
/* JH (01/01/2006) This file is generated using ROSETTA. It should never be 
   manipulated by hand. The generation is located in buildStorageClasses.C!

    This file contains all decfinitions for the StorageClasses used for the ast file IO.
*/

#ifndef STORAGE_CLASSES_H
#define STORAGE_CLASSES_H

#include "sage3basic.hhh" // static data managing

/* JH (02/02/2006) REMARK: Since the declarations, definitions and use of the static member functions of 
   the templated EasyStorage classes is spread over the files below, we need to compile them all together 
   at this point. The splitting into several files is just to simplify and separate their contents! 
*/

#include "rosedefs.h"
#include "Cxx_Grammar.h"

#include "AST_FILE_IO.h"
#include "Cxx_GrammarMemoryPoolSupport.h"
#include "StorageClasses.h"

// DQ (3/7/2010): Added to support debugging.
#include "AstDiagnostics.h"

#include "StorageClassMemoryManagement.C"
#include "SourcesOfIRNodesAstFileIOSupport.C"


SgProject* 
AstSpecificDataManagingClass::getRootOfAst () const
   {
     return rootOfAst;
   }

unsigned long 
AstSpecificDataManagingClass::getNumberOfAccumulatedNodes (const int position) const
   {
     return listOfAccumulatedPoolSizes[position];
   }

unsigned long
AstSpecificDataManagingClass::getMemoryPoolSize (const int position) const
   {
     return listOfAccumulatedPoolSizes[position + 1] - listOfAccumulatedPoolSizes[position];
   }

unsigned long 
AstSpecificDataManagingClass::getTotalNumberOfASTIRNodes ( ) const
   {
     return listOfAccumulatedPoolSizes[ 1073 ] ;
   }

int 
AstSpecificDataManagingClass::get_AstIndex() const
   {
     return astIndex;
   }


/* #line 64 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */
SgFunctionTypeTable*
AstSpecificDataManagingClass::get_SgNode_globalFunctionTypeTable() const
  {
    return SgNode_globalFunctionTypeTable;
  }

SgTypeTable*
AstSpecificDataManagingClass::get_SgNode_globalTypeTable() const
  {
    return SgNode_globalTypeTable;
  }

std::map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalMangledNameMap() const
  {
    return SgNode_globalMangledNameMap;
  }

std::map<std::string, uint64_t>
AstSpecificDataManagingClass::get_SgNode_shortMangledNameCache() const
  {
    return SgNode_shortMangledNameCache;
  }

std::unordered_map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalQualifiedNameMapForNames() const
  {
    return SgNode_globalQualifiedNameMapForNames;
  }

std::unordered_map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalQualifiedNameMapForTypes() const
  {
    return SgNode_globalQualifiedNameMapForTypes;
  }

std::unordered_map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalQualifiedNameMapForTemplateHeaders() const
  {
    return SgNode_globalQualifiedNameMapForTemplateHeaders;
  }

std::unordered_map<SgNode*,std::string>
AstSpecificDataManagingClass::get_SgNode_globalTypeNameMap() const
  {
    return SgNode_globalTypeNameMap;
  }

std::map<SgNode*,std::unordered_map<SgNode*,std::string> >
AstSpecificDataManagingClass::get_SgNode_globalQualifiedNameMapForMapsOfTypes() const
  {
    return SgNode_globalQualifiedNameMapForMapsOfTypes;
  }

SgUnorderedNodeSet
AstSpecificDataManagingClass::get_SgSymbolTable_aliasSymbolCausalNodeSet() const
  {
    return SgSymbolTable_aliasSymbolCausalNodeSet;
  }

bool
AstSpecificDataManagingClass::get_SgSymbolTable_force_search_of_base_classes() const
  {
    return SgSymbolTable_force_search_of_base_classes;
  }

bool
AstSpecificDataManagingClass::get_SgSymbolTable_name_qualification_mode() const
  {
    return SgSymbolTable_name_qualification_mode;
  }

std::map<int, std::string>
AstSpecificDataManagingClass::get_Sg_File_Info_fileidtoname_map() const
  {
    return Sg_File_Info_fileidtoname_map;
  }

std::map<std::string, int>
AstSpecificDataManagingClass::get_Sg_File_Info_nametofileid_map() const
  {
    return Sg_File_Info_nametofileid_map;
  }

bool
AstSpecificDataManagingClass::get_SgFile_skip_unparse_asm_commands() const
  {
    return SgFile_skip_unparse_asm_commands;
  }

bool
AstSpecificDataManagingClass::get_SgFile_header_file_unparsing_optimization() const
  {
    return SgFile_header_file_unparsing_optimization;
  }

SgTypePtrList
AstSpecificDataManagingClass::get_SgUnparse_Info_structureTagProcessingList() const
  {
    return SgUnparse_Info_structureTagProcessingList;
  }

bool
AstSpecificDataManagingClass::get_SgUnparse_Info_forceDefaultConstructorToTriggerError() const
  {
    return SgUnparse_Info_forceDefaultConstructorToTriggerError;
  }

bool
AstSpecificDataManagingClass::get_SgUnparse_Info_extern_C_with_braces() const
  {
    return SgUnparse_Info_extern_C_with_braces;
  }

SgStatement*
AstSpecificDataManagingClass::get_SgUnparse_Info_previouslyUnparsedStatement() const
  {
    return SgUnparse_Info_previouslyUnparsedStatement;
  }

bool
AstSpecificDataManagingClass::get_SgUnparse_Info_previousStatementUnparsedFromTokenStream() const
  {
    return SgUnparse_Info_previousStatementUnparsedFromTokenStream;
  }

int
AstSpecificDataManagingClass::get_SgGraph_index_counter() const
  {
    return SgGraph_index_counter;
  }

int
AstSpecificDataManagingClass::get_SgGraphNode_index_counter() const
  {
    return SgGraphNode_index_counter;
  }

int
AstSpecificDataManagingClass::get_SgGraphEdge_index_counter() const
  {
    return SgGraphEdge_index_counter;
  }

SgTypeUnknown*
AstSpecificDataManagingClass::get_SgTypeUnknown_builtin_type() const
  {
    return SgTypeUnknown_builtin_type;
  }

SgTypeChar*
AstSpecificDataManagingClass::get_SgTypeChar_builtin_type() const
  {
    return SgTypeChar_builtin_type;
  }

SgTypeSignedChar*
AstSpecificDataManagingClass::get_SgTypeSignedChar_builtin_type() const
  {
    return SgTypeSignedChar_builtin_type;
  }

SgTypeUnsignedChar*
AstSpecificDataManagingClass::get_SgTypeUnsignedChar_builtin_type() const
  {
    return SgTypeUnsignedChar_builtin_type;
  }

SgTypeShort*
AstSpecificDataManagingClass::get_SgTypeShort_builtin_type() const
  {
    return SgTypeShort_builtin_type;
  }

SgTypeSignedShort*
AstSpecificDataManagingClass::get_SgTypeSignedShort_builtin_type() const
  {
    return SgTypeSignedShort_builtin_type;
  }

SgTypeUnsignedShort*
AstSpecificDataManagingClass::get_SgTypeUnsignedShort_builtin_type() const
  {
    return SgTypeUnsignedShort_builtin_type;
  }

SgTypeInt*
AstSpecificDataManagingClass::get_SgTypeInt_builtin_type() const
  {
    return SgTypeInt_builtin_type;
  }

SgTypeSignedInt*
AstSpecificDataManagingClass::get_SgTypeSignedInt_builtin_type() const
  {
    return SgTypeSignedInt_builtin_type;
  }

SgTypeUnsignedInt*
AstSpecificDataManagingClass::get_SgTypeUnsignedInt_builtin_type() const
  {
    return SgTypeUnsignedInt_builtin_type;
  }

SgTypeLong*
AstSpecificDataManagingClass::get_SgTypeLong_builtin_type() const
  {
    return SgTypeLong_builtin_type;
  }

SgTypeSignedLong*
AstSpecificDataManagingClass::get_SgTypeSignedLong_builtin_type() const
  {
    return SgTypeSignedLong_builtin_type;
  }

SgTypeUnsignedLong*
AstSpecificDataManagingClass::get_SgTypeUnsignedLong_builtin_type() const
  {
    return SgTypeUnsignedLong_builtin_type;
  }

SgTypeVoid*
AstSpecificDataManagingClass::get_SgTypeVoid_builtin_type() const
  {
    return SgTypeVoid_builtin_type;
  }

SgTypeGlobalVoid*
AstSpecificDataManagingClass::get_SgTypeGlobalVoid_builtin_type() const
  {
    return SgTypeGlobalVoid_builtin_type;
  }

SgTypeWchar*
AstSpecificDataManagingClass::get_SgTypeWchar_builtin_type() const
  {
    return SgTypeWchar_builtin_type;
  }

SgTypeFloat*
AstSpecificDataManagingClass::get_SgTypeFloat_builtin_type() const
  {
    return SgTypeFloat_builtin_type;
  }

SgTypeDouble*
AstSpecificDataManagingClass::get_SgTypeDouble_builtin_type() const
  {
    return SgTypeDouble_builtin_type;
  }

SgTypeLongLong*
AstSpecificDataManagingClass::get_SgTypeLongLong_builtin_type() const
  {
    return SgTypeLongLong_builtin_type;
  }

SgTypeSignedLongLong*
AstSpecificDataManagingClass::get_SgTypeSignedLongLong_builtin_type() const
  {
    return SgTypeSignedLongLong_builtin_type;
  }

SgTypeUnsignedLongLong*
AstSpecificDataManagingClass::get_SgTypeUnsignedLongLong_builtin_type() const
  {
    return SgTypeUnsignedLongLong_builtin_type;
  }

SgTypeSigned128bitInteger*
AstSpecificDataManagingClass::get_SgTypeSigned128bitInteger_builtin_type() const
  {
    return SgTypeSigned128bitInteger_builtin_type;
  }

SgTypeUnsigned128bitInteger*
AstSpecificDataManagingClass::get_SgTypeUnsigned128bitInteger_builtin_type() const
  {
    return SgTypeUnsigned128bitInteger_builtin_type;
  }

SgTypeFloat80*
AstSpecificDataManagingClass::get_SgTypeFloat80_builtin_type() const
  {
    return SgTypeFloat80_builtin_type;
  }

SgTypeLongDouble*
AstSpecificDataManagingClass::get_SgTypeLongDouble_builtin_type() const
  {
    return SgTypeLongDouble_builtin_type;
  }

SgTypeBool*
AstSpecificDataManagingClass::get_SgTypeBool_builtin_type() const
  {
    return SgTypeBool_builtin_type;
  }

SgNamedType*
AstSpecificDataManagingClass::get_SgNamedType_builtin_type() const
  {
    return SgNamedType_builtin_type;
  }

SgPartialFunctionModifierType*
AstSpecificDataManagingClass::get_SgPartialFunctionModifierType_builtin_type() const
  {
    return SgPartialFunctionModifierType_builtin_type;
  }

SgTypeEllipse*
AstSpecificDataManagingClass::get_SgTypeEllipse_builtin_type() const
  {
    return SgTypeEllipse_builtin_type;
  }

SgTypeDefault*
AstSpecificDataManagingClass::get_SgTypeDefault_builtin_type() const
  {
    return SgTypeDefault_builtin_type;
  }

SgTypeCAFTeam*
AstSpecificDataManagingClass::get_SgTypeCAFTeam_builtin_type() const
  {
    return SgTypeCAFTeam_builtin_type;
  }

SgTypeCrayPointer*
AstSpecificDataManagingClass::get_SgTypeCrayPointer_builtin_type() const
  {
    return SgTypeCrayPointer_builtin_type;
  }

SgTypeLabel*
AstSpecificDataManagingClass::get_SgTypeLabel_builtin_type() const
  {
    return SgTypeLabel_builtin_type;
  }

SgTypeNullptr*
AstSpecificDataManagingClass::get_SgTypeNullptr_builtin_type() const
  {
    return SgTypeNullptr_builtin_type;
  }

SgTypeMatrix*
AstSpecificDataManagingClass::get_SgTypeMatrix_builtin_type() const
  {
    return SgTypeMatrix_builtin_type;
  }

SgTypeTuple*
AstSpecificDataManagingClass::get_SgTypeTuple_builtin_type() const
  {
    return SgTypeTuple_builtin_type;
  }

SgTypeChar16*
AstSpecificDataManagingClass::get_SgTypeChar16_builtin_type() const
  {
    return SgTypeChar16_builtin_type;
  }

SgTypeChar32*
AstSpecificDataManagingClass::get_SgTypeChar32_builtin_type() const
  {
    return SgTypeChar32_builtin_type;
  }

SgTypeFloat128*
AstSpecificDataManagingClass::get_SgTypeFloat128_builtin_type() const
  {
    return SgTypeFloat128_builtin_type;
  }

SgAdaDiscreteType*
AstSpecificDataManagingClass::get_SgAdaDiscreteType_builtin_type() const
  {
    return SgAdaDiscreteType_builtin_type;
  }

AstSpecificDataManagingClass::AstSpecificDataManagingClass( SgProject* root )
   {
     rootOfAst = root;
     astIndex = AST_FILE_IO::getNumberOfAsts(); 
     SgNode_globalFunctionTypeTable = SgNode::p_globalFunctionTypeTable;
     SgNode_globalTypeTable = SgNode::p_globalTypeTable;
     SgNode_globalMangledNameMap = SgNode::p_globalMangledNameMap;
     SgNode_shortMangledNameCache = SgNode::p_shortMangledNameCache;
     SgNode_globalQualifiedNameMapForNames = SgNode::p_globalQualifiedNameMapForNames;
     SgNode_globalQualifiedNameMapForTypes = SgNode::p_globalQualifiedNameMapForTypes;
     SgNode_globalQualifiedNameMapForTemplateHeaders = SgNode::p_globalQualifiedNameMapForTemplateHeaders;
     SgNode_globalTypeNameMap = SgNode::p_globalTypeNameMap;
     SgNode_globalQualifiedNameMapForMapsOfTypes = SgNode::p_globalQualifiedNameMapForMapsOfTypes;
     SgSymbolTable_aliasSymbolCausalNodeSet = SgSymbolTable::p_aliasSymbolCausalNodeSet;
     SgSymbolTable_force_search_of_base_classes = SgSymbolTable::p_force_search_of_base_classes;
     SgSymbolTable_name_qualification_mode = SgSymbolTable::p_name_qualification_mode;
     Sg_File_Info_fileidtoname_map = Sg_File_Info::p_fileidtoname_map;
     Sg_File_Info_nametofileid_map = Sg_File_Info::p_nametofileid_map;
     SgFile_skip_unparse_asm_commands = SgFile::p_skip_unparse_asm_commands;
     SgFile_header_file_unparsing_optimization = SgFile::p_header_file_unparsing_optimization;
     SgUnparse_Info_structureTagProcessingList = SgUnparse_Info::p_structureTagProcessingList;
     SgUnparse_Info_forceDefaultConstructorToTriggerError = SgUnparse_Info::p_forceDefaultConstructorToTriggerError;
     SgUnparse_Info_extern_C_with_braces = SgUnparse_Info::p_extern_C_with_braces;
     SgUnparse_Info_previouslyUnparsedStatement = SgUnparse_Info::p_previouslyUnparsedStatement;
     SgUnparse_Info_previousStatementUnparsedFromTokenStream = SgUnparse_Info::p_previousStatementUnparsedFromTokenStream;
     SgGraph_index_counter = SgGraph::p_index_counter;
     SgGraphNode_index_counter = SgGraphNode::p_index_counter;
     SgGraphEdge_index_counter = SgGraphEdge::p_index_counter;
     SgTypeUnknown_builtin_type = SgTypeUnknown::p_builtin_type;
     SgTypeChar_builtin_type = SgTypeChar::p_builtin_type;
     SgTypeSignedChar_builtin_type = SgTypeSignedChar::p_builtin_type;
     SgTypeUnsignedChar_builtin_type = SgTypeUnsignedChar::p_builtin_type;
     SgTypeShort_builtin_type = SgTypeShort::p_builtin_type;
     SgTypeSignedShort_builtin_type = SgTypeSignedShort::p_builtin_type;
     SgTypeUnsignedShort_builtin_type = SgTypeUnsignedShort::p_builtin_type;
     SgTypeInt_builtin_type = SgTypeInt::p_builtin_type;
     SgTypeSignedInt_builtin_type = SgTypeSignedInt::p_builtin_type;
     SgTypeUnsignedInt_builtin_type = SgTypeUnsignedInt::p_builtin_type;
     SgTypeLong_builtin_type = SgTypeLong::p_builtin_type;
     SgTypeSignedLong_builtin_type = SgTypeSignedLong::p_builtin_type;
     SgTypeUnsignedLong_builtin_type = SgTypeUnsignedLong::p_builtin_type;
     SgTypeVoid_builtin_type = SgTypeVoid::p_builtin_type;
     SgTypeGlobalVoid_builtin_type = SgTypeGlobalVoid::p_builtin_type;
     SgTypeWchar_builtin_type = SgTypeWchar::p_builtin_type;
     SgTypeFloat_builtin_type = SgTypeFloat::p_builtin_type;
     SgTypeDouble_builtin_type = SgTypeDouble::p_builtin_type;
     SgTypeLongLong_builtin_type = SgTypeLongLong::p_builtin_type;
     SgTypeSignedLongLong_builtin_type = SgTypeSignedLongLong::p_builtin_type;
     SgTypeUnsignedLongLong_builtin_type = SgTypeUnsignedLongLong::p_builtin_type;
     SgTypeSigned128bitInteger_builtin_type = SgTypeSigned128bitInteger::p_builtin_type;
     SgTypeUnsigned128bitInteger_builtin_type = SgTypeUnsigned128bitInteger::p_builtin_type;
     SgTypeFloat80_builtin_type = SgTypeFloat80::p_builtin_type;
     SgTypeLongDouble_builtin_type = SgTypeLongDouble::p_builtin_type;
     SgTypeBool_builtin_type = SgTypeBool::p_builtin_type;
     SgNamedType_builtin_type = SgNamedType::p_builtin_type;
     SgPartialFunctionModifierType_builtin_type = SgPartialFunctionModifierType::p_builtin_type;
     SgTypeEllipse_builtin_type = SgTypeEllipse::p_builtin_type;
     SgTypeDefault_builtin_type = SgTypeDefault::p_builtin_type;
     SgTypeCAFTeam_builtin_type = SgTypeCAFTeam::p_builtin_type;
     SgTypeCrayPointer_builtin_type = SgTypeCrayPointer::p_builtin_type;
     SgTypeLabel_builtin_type = SgTypeLabel::p_builtin_type;
     SgTypeNullptr_builtin_type = SgTypeNullptr::p_builtin_type;
     SgTypeMatrix_builtin_type = SgTypeMatrix::p_builtin_type;
     SgTypeTuple_builtin_type = SgTypeTuple::p_builtin_type;
     SgTypeChar16_builtin_type = SgTypeChar16::p_builtin_type;
     SgTypeChar32_builtin_type = SgTypeChar32::p_builtin_type;
     SgTypeFloat128_builtin_type = SgTypeFloat128::p_builtin_type;
     SgAdaDiscreteType_builtin_type = SgAdaDiscreteType::p_builtin_type;
   }

void
AstSpecificDataManagingClass::setStaticDataMembersOfIRNodes ( ) const
   {
     if ( SgNode_globalFunctionTypeTable != nullptr ) 
        {
          if (SgNode::p_globalFunctionTypeTable == nullptr)
             {
               SgNode::p_globalFunctionTypeTable = SgNode_globalFunctionTypeTable;
             }
        }
     if ( SgNode_globalTypeTable != nullptr ) 
        {
          if (SgNode::p_globalTypeTable == nullptr)
             {
               SgNode::p_globalTypeTable = SgNode_globalTypeTable;
             }
        }
     SgNode::p_globalMangledNameMap = SgNode_globalMangledNameMap;
     SgNode::p_shortMangledNameCache = SgNode_shortMangledNameCache;
     SgNode::p_globalQualifiedNameMapForNames = SgNode_globalQualifiedNameMapForNames;
     SgNode::p_globalQualifiedNameMapForTypes = SgNode_globalQualifiedNameMapForTypes;
     SgNode::p_globalQualifiedNameMapForTemplateHeaders = SgNode_globalQualifiedNameMapForTemplateHeaders;
     SgNode::p_globalTypeNameMap = SgNode_globalTypeNameMap;
     SgNode::p_globalQualifiedNameMapForMapsOfTypes = SgNode_globalQualifiedNameMapForMapsOfTypes;
     SgSymbolTable::p_aliasSymbolCausalNodeSet = SgSymbolTable_aliasSymbolCausalNodeSet;
     SgSymbolTable::p_force_search_of_base_classes = SgSymbolTable_force_search_of_base_classes;
     SgSymbolTable::p_name_qualification_mode = SgSymbolTable_name_qualification_mode;
     Sg_File_Info::p_fileidtoname_map = Sg_File_Info_fileidtoname_map;
     Sg_File_Info::p_nametofileid_map = Sg_File_Info_nametofileid_map;
     SgFile::p_skip_unparse_asm_commands = SgFile_skip_unparse_asm_commands;
     SgFile::p_header_file_unparsing_optimization = SgFile_header_file_unparsing_optimization;
     SgUnparse_Info::p_structureTagProcessingList = SgUnparse_Info_structureTagProcessingList;
     SgUnparse_Info::p_forceDefaultConstructorToTriggerError = SgUnparse_Info_forceDefaultConstructorToTriggerError;
     SgUnparse_Info::p_extern_C_with_braces = SgUnparse_Info_extern_C_with_braces;
     if ( SgUnparse_Info_previouslyUnparsedStatement != nullptr ) 
        {
          if (SgUnparse_Info::p_previouslyUnparsedStatement == nullptr)
             {
               SgUnparse_Info::p_previouslyUnparsedStatement = SgUnparse_Info_previouslyUnparsedStatement;
             }
        }
     SgUnparse_Info::p_previousStatementUnparsedFromTokenStream = SgUnparse_Info_previousStatementUnparsedFromTokenStream;
     SgGraph::p_index_counter = SgGraph_index_counter;
     SgGraphNode::p_index_counter = SgGraphNode_index_counter;
     SgGraphEdge::p_index_counter = SgGraphEdge_index_counter;
     if ( SgTypeUnknown_builtin_type != nullptr ) 
        {
          if (SgTypeUnknown::p_builtin_type == nullptr)
             {
               SgTypeUnknown::p_builtin_type = SgTypeUnknown_builtin_type;
             }
        }
     if ( SgTypeChar_builtin_type != nullptr ) 
        {
          if (SgTypeChar::p_builtin_type == nullptr)
             {
               SgTypeChar::p_builtin_type = SgTypeChar_builtin_type;
             }
        }
     if ( SgTypeSignedChar_builtin_type != nullptr ) 
        {
          if (SgTypeSignedChar::p_builtin_type == nullptr)
             {
               SgTypeSignedChar::p_builtin_type = SgTypeSignedChar_builtin_type;
             }
        }
     if ( SgTypeUnsignedChar_builtin_type != nullptr ) 
        {
          if (SgTypeUnsignedChar::p_builtin_type == nullptr)
             {
               SgTypeUnsignedChar::p_builtin_type = SgTypeUnsignedChar_builtin_type;
             }
        }
     if ( SgTypeShort_builtin_type != nullptr ) 
        {
          if (SgTypeShort::p_builtin_type == nullptr)
             {
               SgTypeShort::p_builtin_type = SgTypeShort_builtin_type;
             }
        }
     if ( SgTypeSignedShort_builtin_type != nullptr ) 
        {
          if (SgTypeSignedShort::p_builtin_type == nullptr)
             {
               SgTypeSignedShort::p_builtin_type = SgTypeSignedShort_builtin_type;
             }
        }
     if ( SgTypeUnsignedShort_builtin_type != nullptr ) 
        {
          if (SgTypeUnsignedShort::p_builtin_type == nullptr)
             {
               SgTypeUnsignedShort::p_builtin_type = SgTypeUnsignedShort_builtin_type;
             }
        }
     if ( SgTypeInt_builtin_type != nullptr ) 
        {
          if (SgTypeInt::p_builtin_type == nullptr)
             {
               SgTypeInt::p_builtin_type = SgTypeInt_builtin_type;
             }
        }
     if ( SgTypeSignedInt_builtin_type != nullptr ) 
        {
          if (SgTypeSignedInt::p_builtin_type == nullptr)
             {
               SgTypeSignedInt::p_builtin_type = SgTypeSignedInt_builtin_type;
             }
        }
     if ( SgTypeUnsignedInt_builtin_type != nullptr ) 
        {
          if (SgTypeUnsignedInt::p_builtin_type == nullptr)
             {
               SgTypeUnsignedInt::p_builtin_type = SgTypeUnsignedInt_builtin_type;
             }
        }
     if ( SgTypeLong_builtin_type != nullptr ) 
        {
          if (SgTypeLong::p_builtin_type == nullptr)
             {
               SgTypeLong::p_builtin_type = SgTypeLong_builtin_type;
             }
        }
     if ( SgTypeSignedLong_builtin_type != nullptr ) 
        {
          if (SgTypeSignedLong::p_builtin_type == nullptr)
             {
               SgTypeSignedLong::p_builtin_type = SgTypeSignedLong_builtin_type;
             }
        }
     if ( SgTypeUnsignedLong_builtin_type != nullptr ) 
        {
          if (SgTypeUnsignedLong::p_builtin_type == nullptr)
             {
               SgTypeUnsignedLong::p_builtin_type = SgTypeUnsignedLong_builtin_type;
             }
        }
     if ( SgTypeVoid_builtin_type != nullptr ) 
        {
          if (SgTypeVoid::p_builtin_type == nullptr)
             {
               SgTypeVoid::p_builtin_type = SgTypeVoid_builtin_type;
             }
        }
     if ( SgTypeGlobalVoid_builtin_type != nullptr ) 
        {
          if (SgTypeGlobalVoid::p_builtin_type == nullptr)
             {
               SgTypeGlobalVoid::p_builtin_type = SgTypeGlobalVoid_builtin_type;
             }
        }
     if ( SgTypeWchar_builtin_type != nullptr ) 
        {
          if (SgTypeWchar::p_builtin_type == nullptr)
             {
               SgTypeWchar::p_builtin_type = SgTypeWchar_builtin_type;
             }
        }
     if ( SgTypeFloat_builtin_type != nullptr ) 
        {
          if (SgTypeFloat::p_builtin_type == nullptr)
             {
               SgTypeFloat::p_builtin_type = SgTypeFloat_builtin_type;
             }
        }
     if ( SgTypeDouble_builtin_type != nullptr ) 
        {
          if (SgTypeDouble::p_builtin_type == nullptr)
             {
               SgTypeDouble::p_builtin_type = SgTypeDouble_builtin_type;
             }
        }
     if ( SgTypeLongLong_builtin_type != nullptr ) 
        {
          if (SgTypeLongLong::p_builtin_type == nullptr)
             {
               SgTypeLongLong::p_builtin_type = SgTypeLongLong_builtin_type;
             }
        }
     if ( SgTypeSignedLongLong_builtin_type != nullptr ) 
        {
          if (SgTypeSignedLongLong::p_builtin_type == nullptr)
             {
               SgTypeSignedLongLong::p_builtin_type = SgTypeSignedLongLong_builtin_type;
             }
        }
     if ( SgTypeUnsignedLongLong_builtin_type != nullptr ) 
        {
          if (SgTypeUnsignedLongLong::p_builtin_type == nullptr)
             {
               SgTypeUnsignedLongLong::p_builtin_type = SgTypeUnsignedLongLong_builtin_type;
             }
        }
     if ( SgTypeSigned128bitInteger_builtin_type != nullptr ) 
        {
          if (SgTypeSigned128bitInteger::p_builtin_type == nullptr)
             {
               SgTypeSigned128bitInteger::p_builtin_type = SgTypeSigned128bitInteger_builtin_type;
             }
        }
     if ( SgTypeUnsigned128bitInteger_builtin_type != nullptr ) 
        {
          if (SgTypeUnsigned128bitInteger::p_builtin_type == nullptr)
             {
               SgTypeUnsigned128bitInteger::p_builtin_type = SgTypeUnsigned128bitInteger_builtin_type;
             }
        }
     if ( SgTypeFloat80_builtin_type != nullptr ) 
        {
          if (SgTypeFloat80::p_builtin_type == nullptr)
             {
               SgTypeFloat80::p_builtin_type = SgTypeFloat80_builtin_type;
             }
        }
     if ( SgTypeLongDouble_builtin_type != nullptr ) 
        {
          if (SgTypeLongDouble::p_builtin_type == nullptr)
             {
               SgTypeLongDouble::p_builtin_type = SgTypeLongDouble_builtin_type;
             }
        }
     if ( SgTypeBool_builtin_type != nullptr ) 
        {
          if (SgTypeBool::p_builtin_type == nullptr)
             {
               SgTypeBool::p_builtin_type = SgTypeBool_builtin_type;
             }
        }
     if ( SgNamedType_builtin_type != nullptr ) 
        {
          if (SgNamedType::p_builtin_type == nullptr)
             {
               SgNamedType::p_builtin_type = SgNamedType_builtin_type;
             }
        }
     if ( SgPartialFunctionModifierType_builtin_type != nullptr ) 
        {
          if (SgPartialFunctionModifierType::p_builtin_type == nullptr)
             {
               SgPartialFunctionModifierType::p_builtin_type = SgPartialFunctionModifierType_builtin_type;
             }
        }
     if ( SgTypeEllipse_builtin_type != nullptr ) 
        {
          if (SgTypeEllipse::p_builtin_type == nullptr)
             {
               SgTypeEllipse::p_builtin_type = SgTypeEllipse_builtin_type;
             }
        }
     if ( SgTypeDefault_builtin_type != nullptr ) 
        {
          if (SgTypeDefault::p_builtin_type == nullptr)
             {
               SgTypeDefault::p_builtin_type = SgTypeDefault_builtin_type;
             }
        }
     if ( SgTypeCAFTeam_builtin_type != nullptr ) 
        {
          if (SgTypeCAFTeam::p_builtin_type == nullptr)
             {
               SgTypeCAFTeam::p_builtin_type = SgTypeCAFTeam_builtin_type;
             }
        }
     if ( SgTypeCrayPointer_builtin_type != nullptr ) 
        {
          if (SgTypeCrayPointer::p_builtin_type == nullptr)
             {
               SgTypeCrayPointer::p_builtin_type = SgTypeCrayPointer_builtin_type;
             }
        }
     if ( SgTypeLabel_builtin_type != nullptr ) 
        {
          if (SgTypeLabel::p_builtin_type == nullptr)
             {
               SgTypeLabel::p_builtin_type = SgTypeLabel_builtin_type;
             }
        }
     if ( SgTypeNullptr_builtin_type != nullptr ) 
        {
          if (SgTypeNullptr::p_builtin_type == nullptr)
             {
               SgTypeNullptr::p_builtin_type = SgTypeNullptr_builtin_type;
             }
        }
     if ( SgTypeMatrix_builtin_type != nullptr ) 
        {
          if (SgTypeMatrix::p_builtin_type == nullptr)
             {
               SgTypeMatrix::p_builtin_type = SgTypeMatrix_builtin_type;
             }
        }
     if ( SgTypeTuple_builtin_type != nullptr ) 
        {
          if (SgTypeTuple::p_builtin_type == nullptr)
             {
               SgTypeTuple::p_builtin_type = SgTypeTuple_builtin_type;
             }
        }
     if ( SgTypeChar16_builtin_type != nullptr ) 
        {
          if (SgTypeChar16::p_builtin_type == nullptr)
             {
               SgTypeChar16::p_builtin_type = SgTypeChar16_builtin_type;
             }
        }
     if ( SgTypeChar32_builtin_type != nullptr ) 
        {
          if (SgTypeChar32::p_builtin_type == nullptr)
             {
               SgTypeChar32::p_builtin_type = SgTypeChar32_builtin_type;
             }
        }
     if ( SgTypeFloat128_builtin_type != nullptr ) 
        {
          if (SgTypeFloat128::p_builtin_type == nullptr)
             {
               SgTypeFloat128::p_builtin_type = SgTypeFloat128_builtin_type;
             }
        }
     if ( SgAdaDiscreteType_builtin_type != nullptr ) 
        {
          if (SgAdaDiscreteType::p_builtin_type == nullptr)
             {
               SgAdaDiscreteType::p_builtin_type = SgAdaDiscreteType_builtin_type;
             }
        }
   }

void
AstSpecificDataManagingClassStorageClass::pickOutIRNodeData ( AstSpecificDataManagingClass* source )
   {
     for(int i =  0; i < 1073 + 1; ++ i )
        {
          listOfAccumulatedPoolSizes[i] = source->listOfAccumulatedPoolSizes[i];
        }
     rootOfAst =  AST_FILE_IO::getGlobalIndexFromSgClassPointer (source->rootOfAst);
     storageOf_SgNode_globalFunctionTypeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNode_globalFunctionTypeTable );
     storageOf_SgNode_globalTypeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNode_globalTypeTable );
     storageOf_SgNode_globalMangledNameMap.storeDataInEasyStorageClass( source->SgNode_globalMangledNameMap);
     storageOf_SgNode_shortMangledNameCache.storeDataInEasyStorageClass( source->SgNode_shortMangledNameCache);
     storageOf_SgNode_globalQualifiedNameMapForNames.storeDataInEasyStorageClass( source->SgNode_globalQualifiedNameMapForNames);
     storageOf_SgNode_globalQualifiedNameMapForTypes.storeDataInEasyStorageClass( source->SgNode_globalQualifiedNameMapForTypes);
     storageOf_SgNode_globalQualifiedNameMapForTemplateHeaders.storeDataInEasyStorageClass( source->SgNode_globalQualifiedNameMapForTemplateHeaders);
     storageOf_SgNode_globalTypeNameMap.storeDataInEasyStorageClass( source->SgNode_globalTypeNameMap);
     storageOf_SgNode_globalQualifiedNameMapForMapsOfTypes.storeDataInEasyStorageClass( source->SgNode_globalQualifiedNameMapForMapsOfTypes);
     storageOf_SgSymbolTable_aliasSymbolCausalNodeSet.storeDataInEasyStorageClass( source->SgSymbolTable_aliasSymbolCausalNodeSet);
     storageOf_SgSymbolTable_force_search_of_base_classes =  source->SgSymbolTable_force_search_of_base_classes ;
     storageOf_SgSymbolTable_name_qualification_mode =  source->SgSymbolTable_name_qualification_mode ;
     storageOf_Sg_File_Info_fileidtoname_map.storeDataInEasyStorageClass( source->Sg_File_Info_fileidtoname_map);
     storageOf_Sg_File_Info_nametofileid_map.storeDataInEasyStorageClass( source->Sg_File_Info_nametofileid_map);
     storageOf_SgFile_skip_unparse_asm_commands =  source->SgFile_skip_unparse_asm_commands ;
     storageOf_SgFile_header_file_unparsing_optimization =  source->SgFile_header_file_unparsing_optimization ;
     SgTypePtrList::iterator i_SgUnparse_Info = source->SgUnparse_Info_structureTagProcessingList.begin() ; 
     unsigned int tempListCountSgUnparse_Info = 0; 
     SgTypePtrList::value_type *  tempListSgUnparse_Info = new SgTypePtrList::value_type[ source->SgUnparse_Info_structureTagProcessingList.size() ]; 
     for ( ; i_SgUnparse_Info != source->SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          tempListSgUnparse_Info[tempListCountSgUnparse_Info] = *i_SgUnparse_Info;
          tempListCountSgUnparse_Info++; 
          (*i_SgUnparse_Info) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_SgUnparse_Info ) );
        }
     storageOf_SgUnparse_Info_structureTagProcessingList.storeDataInEasyStorageClass(source->SgUnparse_Info_structureTagProcessingList);
     tempListCountSgUnparse_Info = 0; 
     i_SgUnparse_Info = source->SgUnparse_Info_structureTagProcessingList.begin() ; 
     for ( ; i_SgUnparse_Info != source->SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          *i_SgUnparse_Info = tempListSgUnparse_Info[tempListCountSgUnparse_Info] ;
          tempListCountSgUnparse_Info++; 
        }
      delete [] tempListSgUnparse_Info; 
     storageOf_SgUnparse_Info_forceDefaultConstructorToTriggerError =  source->SgUnparse_Info_forceDefaultConstructorToTriggerError ;
     storageOf_SgUnparse_Info_extern_C_with_braces =  source->SgUnparse_Info_extern_C_with_braces ;
     storageOf_SgUnparse_Info_previouslyUnparsedStatement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgUnparse_Info_previouslyUnparsedStatement );
     storageOf_SgUnparse_Info_previousStatementUnparsedFromTokenStream =  source->SgUnparse_Info_previousStatementUnparsedFromTokenStream ;
     storageOf_SgGraph_index_counter =  source->SgGraph_index_counter ;
     storageOf_SgGraphNode_index_counter =  source->SgGraphNode_index_counter ;
     storageOf_SgGraphEdge_index_counter =  source->SgGraphEdge_index_counter ;
     storageOf_SgTypeUnknown_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnknown_builtin_type );
     storageOf_SgTypeChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeChar_builtin_type );
     storageOf_SgTypeSignedChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedChar_builtin_type );
     storageOf_SgTypeUnsignedChar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedChar_builtin_type );
     storageOf_SgTypeShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeShort_builtin_type );
     storageOf_SgTypeSignedShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedShort_builtin_type );
     storageOf_SgTypeUnsignedShort_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedShort_builtin_type );
     storageOf_SgTypeInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeInt_builtin_type );
     storageOf_SgTypeSignedInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedInt_builtin_type );
     storageOf_SgTypeUnsignedInt_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedInt_builtin_type );
     storageOf_SgTypeLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLong_builtin_type );
     storageOf_SgTypeSignedLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedLong_builtin_type );
     storageOf_SgTypeUnsignedLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedLong_builtin_type );
     storageOf_SgTypeVoid_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeVoid_builtin_type );
     storageOf_SgTypeGlobalVoid_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeGlobalVoid_builtin_type );
     storageOf_SgTypeWchar_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeWchar_builtin_type );
     storageOf_SgTypeFloat_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeFloat_builtin_type );
     storageOf_SgTypeDouble_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeDouble_builtin_type );
     storageOf_SgTypeLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLongLong_builtin_type );
     storageOf_SgTypeSignedLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSignedLongLong_builtin_type );
     storageOf_SgTypeUnsignedLongLong_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsignedLongLong_builtin_type );
     storageOf_SgTypeSigned128bitInteger_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeSigned128bitInteger_builtin_type );
     storageOf_SgTypeUnsigned128bitInteger_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeUnsigned128bitInteger_builtin_type );
     storageOf_SgTypeFloat80_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeFloat80_builtin_type );
     storageOf_SgTypeLongDouble_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLongDouble_builtin_type );
     storageOf_SgTypeBool_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeBool_builtin_type );
     storageOf_SgNamedType_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgNamedType_builtin_type );
     storageOf_SgPartialFunctionModifierType_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgPartialFunctionModifierType_builtin_type );
     storageOf_SgTypeEllipse_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeEllipse_builtin_type );
     storageOf_SgTypeDefault_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeDefault_builtin_type );
     storageOf_SgTypeCAFTeam_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeCAFTeam_builtin_type );
     storageOf_SgTypeCrayPointer_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeCrayPointer_builtin_type );
     storageOf_SgTypeLabel_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeLabel_builtin_type );
     storageOf_SgTypeNullptr_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeNullptr_builtin_type );
     storageOf_SgTypeMatrix_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeMatrix_builtin_type );
     storageOf_SgTypeTuple_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeTuple_builtin_type );
     storageOf_SgTypeChar16_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeChar16_builtin_type );
     storageOf_SgTypeChar32_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeChar32_builtin_type );
     storageOf_SgTypeFloat128_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgTypeFloat128_builtin_type );
     storageOf_SgAdaDiscreteType_builtin_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->SgAdaDiscreteType_builtin_type );
   }

AstSpecificDataManagingClass::AstSpecificDataManagingClass(const AstSpecificDataManagingClassStorageClass& source)
   {
     for(int i =  0; i < 1073 + 1; ++ i )
        {
          listOfAccumulatedPoolSizes[i] = source.listOfAccumulatedPoolSizes[i];
        }
     astIndex = AST_FILE_IO::getNumberOfAsts();
     AST_FILE_IO::addNewAst(this);

  // Note that this call is required to define the locations of IR nodes as addresses 
  // which will be used to reset pointers from global IDs to pointer valuses within the 
  // AST FILE I/O (reading binary ASTs) 
     AST_FILE_IO::extendMemoryPoolsForRebuildingAST();

     rootOfAst = (SgProject*)(AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.rootOfAst));
     SgNode_globalFunctionTypeTable = (SgFunctionTypeTable* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNode_globalFunctionTypeTable ) );
     SgNode_globalTypeTable = (SgTypeTable* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNode_globalTypeTable ) );
     SgNode_globalMangledNameMap = source.storageOf_SgNode_globalMangledNameMap.rebuildDataStoredInEasyStorageClass();
     SgNode_shortMangledNameCache = source.storageOf_SgNode_shortMangledNameCache.rebuildDataStoredInEasyStorageClass();
     SgNode_globalQualifiedNameMapForNames = source.storageOf_SgNode_globalQualifiedNameMapForNames.rebuildDataStoredInEasyStorageClass();
     SgNode_globalQualifiedNameMapForTypes = source.storageOf_SgNode_globalQualifiedNameMapForTypes.rebuildDataStoredInEasyStorageClass();
     SgNode_globalQualifiedNameMapForTemplateHeaders = source.storageOf_SgNode_globalQualifiedNameMapForTemplateHeaders.rebuildDataStoredInEasyStorageClass();
     SgNode_globalTypeNameMap = source.storageOf_SgNode_globalTypeNameMap.rebuildDataStoredInEasyStorageClass();
     SgNode_globalQualifiedNameMapForMapsOfTypes = source.storageOf_SgNode_globalQualifiedNameMapForMapsOfTypes.rebuildDataStoredInEasyStorageClass();
     SgSymbolTable_aliasSymbolCausalNodeSet = source.storageOf_SgSymbolTable_aliasSymbolCausalNodeSet.rebuildDataStoredInEasyStorageClass();
     SgSymbolTable_force_search_of_base_classes = source.storageOf_SgSymbolTable_force_search_of_base_classes;
     SgSymbolTable_name_qualification_mode = source.storageOf_SgSymbolTable_name_qualification_mode;
     Sg_File_Info_fileidtoname_map = source.storageOf_Sg_File_Info_fileidtoname_map.rebuildDataStoredInEasyStorageClass();
     Sg_File_Info_nametofileid_map = source.storageOf_Sg_File_Info_nametofileid_map.rebuildDataStoredInEasyStorageClass();
     SgFile_skip_unparse_asm_commands = source.storageOf_SgFile_skip_unparse_asm_commands;
     SgFile_header_file_unparsing_optimization = source.storageOf_SgFile_header_file_unparsing_optimization;
     SgUnparse_Info_structureTagProcessingList = source.storageOf_SgUnparse_Info_structureTagProcessingList.rebuildDataStoredInEasyStorageClass();
     SgTypePtrList::iterator i_SgUnparse_Info = SgUnparse_Info_structureTagProcessingList.begin() ; 
     for ( ; i_SgUnparse_Info != SgUnparse_Info_structureTagProcessingList.end(); ++i_SgUnparse_Info ) 
        {
          (*i_SgUnparse_Info) = (SgTypePtrList::value_type)(AST_FILE_IO::getSgClassPointerFromGlobalIndex ( (unsigned long) (*i_SgUnparse_Info )  ) );
        }
     SgUnparse_Info_forceDefaultConstructorToTriggerError = source.storageOf_SgUnparse_Info_forceDefaultConstructorToTriggerError;
     SgUnparse_Info_extern_C_with_braces = source.storageOf_SgUnparse_Info_extern_C_with_braces;
     SgUnparse_Info_previouslyUnparsedStatement = (SgStatement* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgUnparse_Info_previouslyUnparsedStatement ) );
     SgUnparse_Info_previousStatementUnparsedFromTokenStream = source.storageOf_SgUnparse_Info_previousStatementUnparsedFromTokenStream;
     SgGraph_index_counter = source.storageOf_SgGraph_index_counter;
     SgGraphNode_index_counter = source.storageOf_SgGraphNode_index_counter;
     SgGraphEdge_index_counter = source.storageOf_SgGraphEdge_index_counter;
     SgTypeUnknown_builtin_type = (SgTypeUnknown* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnknown_builtin_type ) );
     SgTypeChar_builtin_type = (SgTypeChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeChar_builtin_type ) );
     SgTypeSignedChar_builtin_type = (SgTypeSignedChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedChar_builtin_type ) );
     SgTypeUnsignedChar_builtin_type = (SgTypeUnsignedChar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedChar_builtin_type ) );
     SgTypeShort_builtin_type = (SgTypeShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeShort_builtin_type ) );
     SgTypeSignedShort_builtin_type = (SgTypeSignedShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedShort_builtin_type ) );
     SgTypeUnsignedShort_builtin_type = (SgTypeUnsignedShort* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedShort_builtin_type ) );
     SgTypeInt_builtin_type = (SgTypeInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeInt_builtin_type ) );
     SgTypeSignedInt_builtin_type = (SgTypeSignedInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedInt_builtin_type ) );
     SgTypeUnsignedInt_builtin_type = (SgTypeUnsignedInt* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedInt_builtin_type ) );
     SgTypeLong_builtin_type = (SgTypeLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLong_builtin_type ) );
     SgTypeSignedLong_builtin_type = (SgTypeSignedLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedLong_builtin_type ) );
     SgTypeUnsignedLong_builtin_type = (SgTypeUnsignedLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedLong_builtin_type ) );
     SgTypeVoid_builtin_type = (SgTypeVoid* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeVoid_builtin_type ) );
     SgTypeGlobalVoid_builtin_type = (SgTypeGlobalVoid* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeGlobalVoid_builtin_type ) );
     SgTypeWchar_builtin_type = (SgTypeWchar* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeWchar_builtin_type ) );
     SgTypeFloat_builtin_type = (SgTypeFloat* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeFloat_builtin_type ) );
     SgTypeDouble_builtin_type = (SgTypeDouble* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeDouble_builtin_type ) );
     SgTypeLongLong_builtin_type = (SgTypeLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLongLong_builtin_type ) );
     SgTypeSignedLongLong_builtin_type = (SgTypeSignedLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSignedLongLong_builtin_type ) );
     SgTypeUnsignedLongLong_builtin_type = (SgTypeUnsignedLongLong* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsignedLongLong_builtin_type ) );
     SgTypeSigned128bitInteger_builtin_type = (SgTypeSigned128bitInteger* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeSigned128bitInteger_builtin_type ) );
     SgTypeUnsigned128bitInteger_builtin_type = (SgTypeUnsigned128bitInteger* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeUnsigned128bitInteger_builtin_type ) );
     SgTypeFloat80_builtin_type = (SgTypeFloat80* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeFloat80_builtin_type ) );
     SgTypeLongDouble_builtin_type = (SgTypeLongDouble* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLongDouble_builtin_type ) );
     SgTypeBool_builtin_type = (SgTypeBool* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeBool_builtin_type ) );
     SgNamedType_builtin_type = (SgNamedType* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgNamedType_builtin_type ) );
     SgPartialFunctionModifierType_builtin_type = (SgPartialFunctionModifierType* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgPartialFunctionModifierType_builtin_type ) );
     SgTypeEllipse_builtin_type = (SgTypeEllipse* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeEllipse_builtin_type ) );
     SgTypeDefault_builtin_type = (SgTypeDefault* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeDefault_builtin_type ) );
     SgTypeCAFTeam_builtin_type = (SgTypeCAFTeam* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeCAFTeam_builtin_type ) );
     SgTypeCrayPointer_builtin_type = (SgTypeCrayPointer* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeCrayPointer_builtin_type ) );
     SgTypeLabel_builtin_type = (SgTypeLabel* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeLabel_builtin_type ) );
     SgTypeNullptr_builtin_type = (SgTypeNullptr* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeNullptr_builtin_type ) );
     SgTypeMatrix_builtin_type = (SgTypeMatrix* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeMatrix_builtin_type ) );
     SgTypeTuple_builtin_type = (SgTypeTuple* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeTuple_builtin_type ) );
     SgTypeChar16_builtin_type = (SgTypeChar16* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeChar16_builtin_type ) );
     SgTypeChar32_builtin_type = (SgTypeChar32* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeChar32_builtin_type ) );
     SgTypeFloat128_builtin_type = (SgTypeFloat128* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgTypeFloat128_builtin_type ) );
     SgAdaDiscreteType_builtin_type = (SgAdaDiscreteType* ) (AST_FILE_IO::getSgClassPointerFromGlobalIndex (source.storageOf_SgAdaDiscreteType_builtin_type ) );
   }

void
AstSpecificDataManagingClassStorageClass:: writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage<std::map<SgNode*,std::string> > :: writeToFile(out);
     EasyStorage<std::map<std::string, uint64_t> > :: writeToFile(out);
     EasyStorage<std::unordered_map<SgNode*,std::string> > :: writeToFile(out);
     EasyStorage<std::map<SgNode*,std::unordered_map<SgNode*,std::string> > > :: writeToFile(out);
     EasyStorage<SgUnorderedNodeSet > :: writeToFile(out);
     EasyStorage<std::map<int, std::string> > :: writeToFile(out);
     EasyStorage<std::map<std::string, int> > :: writeToFile(out);
     EasyStorage<SgTypePtrList > :: writeToFile(out);
   }

void
AstSpecificDataManagingClassStorageClass:: readEasyStorageDataFromFile (std::istream& in)
   {
     EasyStorage<std::map<SgNode*,std::string> > :: readFromFile(in) ;
     EasyStorage<std::map<std::string, uint64_t> > :: readFromFile(in) ;
     EasyStorage<std::unordered_map<SgNode*,std::string> > :: readFromFile(in) ;
     EasyStorage<std::map<SgNode*,std::unordered_map<SgNode*,std::string> > > :: readFromFile(in) ;
     EasyStorage<SgUnorderedNodeSet > :: readFromFile(in) ;
     EasyStorage<std::map<int, std::string> > :: readFromFile(in) ;
     EasyStorage<std::map<std::string, int> > :: readFromFile(in) ;
     EasyStorage<SgTypePtrList > :: readFromFile(in) ;
   }

void
AstSpecificDataManagingClassStorageClass:: arrangeStaticDataOfEasyStorageClassesInOneBlock()
   {
     EasyStorage<std::map<SgNode*,std::string> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<std::string, uint64_t> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::unordered_map<SgNode*,std::string> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<SgNode*,std::unordered_map<SgNode*,std::string> > > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<SgUnorderedNodeSet > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<std::map<std::string, int> > :: arrangeMemoryPoolInOneBlock();
     EasyStorage<SgTypePtrList > :: arrangeMemoryPoolInOneBlock();
   }

void
AstSpecificDataManagingClassStorageClass:: deleteStaticDataOfEasyStorageClasses()
   {
     EasyStorage<std::map<SgNode*,std::string> > :: deleteMemoryPool();
     EasyStorage<std::map<std::string, uint64_t> > :: deleteMemoryPool();
     EasyStorage<std::unordered_map<SgNode*,std::string> > :: deleteMemoryPool();
     EasyStorage<std::map<SgNode*,std::unordered_map<SgNode*,std::string> > > :: deleteMemoryPool();
     EasyStorage<SgUnorderedNodeSet > :: deleteMemoryPool();
     EasyStorage<std::map<int, std::string> > :: deleteMemoryPool();
     EasyStorage<std::map<std::string, int> > :: deleteMemoryPool();
     EasyStorage<SgTypePtrList > :: deleteMemoryPool();
   }



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1086 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNodeStorageClass::pickOutIRNodeData ( SgNode* pointer ) 
   { 
     SgNode* source = (SgNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1108 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSupportStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1121 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSupportStorageClass::pickOutIRNodeData ( SgSupport* pointer ) 
   { 
     SgSupport* source = (SgSupport*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1143 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1156 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgModifierStorageClass::pickOutIRNodeData ( SgModifier* pointer ) 
   { 
     SgModifier* source = (SgModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1178 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierNodesStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1191 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgModifierNodesStorageClass::pickOutIRNodeData ( SgModifierNodes* pointer ) 
   { 
     SgModifierNodes* source = (SgModifierNodes*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgModifierTypePtrVector::iterator i_nodes = source->p_nodes.begin() ; 
     unsigned int tempListCountnodes = 0; 
     SgModifierTypePtrVector::value_type *  tempListnodes = new SgModifierTypePtrVector::value_type[ source->p_nodes.size() ]; 
     for ( ; i_nodes != source->p_nodes.end(); ++i_nodes ) 
        {
          tempListnodes[tempListCountnodes] = *i_nodes;
          tempListCountnodes++; 
          (*i_nodes) = (SgModifierTypePtrVector::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_nodes ) );
        }
     storageOf_nodes.storeDataInEasyStorageClass(source->p_nodes);
     tempListCountnodes = 0; 
     i_nodes = source->p_nodes.begin() ; 
     for ( ; i_nodes != source->p_nodes.end(); ++i_nodes ) 
        {
          *i_nodes = tempListnodes[tempListCountnodes] ;
          tempListCountnodes++; 
        }
      delete [] tempListnodes; 
     storageOf_next = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_next );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgModifierNodesStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgModifierTypePtrVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModifierNodesStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgModifierTypePtrVector > :: deleteMemoryPool() ;
   }

void
SgModifierNodesStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgModifierTypePtrVector > :: writeToFile(out) ;
   }


void
SgModifierNodesStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgModifierTypePtrVector > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1258 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConstVolatileModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1271 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgConstVolatileModifierStorageClass::pickOutIRNodeData ( SgConstVolatileModifier* pointer ) 
   { 
     SgConstVolatileModifier* source = (SgConstVolatileModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1294 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStorageModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1307 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStorageModifierStorageClass::pickOutIRNodeData ( SgStorageModifier* pointer ) 
   { 
     SgStorageModifier* source = (SgStorageModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_thread_local_storage =  source->p_thread_local_storage ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1331 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAccessModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1344 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAccessModifierStorageClass::pickOutIRNodeData ( SgAccessModifier* pointer ) 
   { 
     SgAccessModifier* source = (SgAccessModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1367 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1380 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionModifierStorageClass::pickOutIRNodeData ( SgFunctionModifier* pointer ) 
   { 
     SgFunctionModifier* source = (SgFunctionModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_gnu_attribute_constructor_destructor_priority =  source->p_gnu_attribute_constructor_destructor_priority ;
     storageOf_gnu_attribute_named_weak_reference.storeDataInEasyStorageClass(source->p_gnu_attribute_named_weak_reference);
     storageOf_gnu_attribute_named_alias.storeDataInEasyStorageClass(source->p_gnu_attribute_named_alias);
     storageOf_opencl_vec_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_opencl_vec_type );
     storageOf_opencl_work_group_size =  source->p_opencl_work_group_size ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgFunctionModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgFunctionModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1438 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUPC_AccessModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1451 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUPC_AccessModifierStorageClass::pickOutIRNodeData ( SgUPC_AccessModifier* pointer ) 
   { 
     SgUPC_AccessModifier* source = (SgUPC_AccessModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_isShared =  source->p_isShared ;
     storageOf_layout =  source->p_layout ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1476 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSpecialFunctionModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1489 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSpecialFunctionModifierStorageClass::pickOutIRNodeData ( SgSpecialFunctionModifier* pointer ) 
   { 
     SgSpecialFunctionModifier* source = (SgSpecialFunctionModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSpecialFunctionModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSpecialFunctionModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
   }

void
SgSpecialFunctionModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
   }


void
SgSpecialFunctionModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1538 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElaboratedTypeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1551 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElaboratedTypeModifierStorageClass::pickOutIRNodeData ( SgElaboratedTypeModifier* pointer ) 
   { 
     SgElaboratedTypeModifier* source = (SgElaboratedTypeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1574 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLinkageModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1587 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLinkageModifierStorageClass::pickOutIRNodeData ( SgLinkageModifier* pointer ) 
   { 
     SgLinkageModifier* source = (SgLinkageModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1610 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBaseClassModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1623 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBaseClassModifierStorageClass::pickOutIRNodeData ( SgBaseClassModifier* pointer ) 
   { 
     SgBaseClassModifier* source = (SgBaseClassModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_accessModifier.pickOutIRNodeData( &(source->p_accessModifier) );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBaseClassModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
   }

void
SgBaseClassModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
   }

void
SgBaseClassModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
   }


void
SgBaseClassModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1669 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStructureModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1682 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStructureModifierStorageClass::pickOutIRNodeData ( SgStructureModifier* pointer ) 
   { 
     SgStructureModifier* source = (SgStructureModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_bits_per_entry =  source->p_bits_per_entry ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1706 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1719 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeModifierStorageClass::pickOutIRNodeData ( SgTypeModifier* pointer ) 
   { 
     SgTypeModifier* source = (SgTypeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_upcModifier.pickOutIRNodeData( &(source->p_upcModifier) );
     storageOf_structureModifier.pickOutIRNodeData( &(source->p_structureModifier) );
     storageOf_constVolatileModifier.pickOutIRNodeData( &(source->p_constVolatileModifier) );
     storageOf_elaboratedTypeModifier.pickOutIRNodeData( &(source->p_elaboratedTypeModifier) );
     storageOf_gnu_extension_machine_mode =  source->p_gnu_extension_machine_mode ;
     storageOf_gnu_attribute_alignment =  source->p_gnu_attribute_alignment ;
     storageOf_gnu_attribute_sentinel =  source->p_gnu_attribute_sentinel ;
     storageOf_address_space_value =  source->p_address_space_value ;
     storageOf_vector_size =  source->p_vector_size ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
   }

void
SgTypeModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
   }


void
SgTypeModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1777 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclarationModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1790 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDeclarationModifierStorageClass::pickOutIRNodeData ( SgDeclarationModifier* pointer ) 
   { 
     SgDeclarationModifier* source = (SgDeclarationModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifierVector.storeDataInEasyStorageClass(source->p_modifierVector);
     storageOf_typeModifier.pickOutIRNodeData( &(source->p_typeModifier) );
     storageOf_accessModifier.pickOutIRNodeData( &(source->p_accessModifier) );
     storageOf_storageModifier.pickOutIRNodeData( &(source->p_storageModifier) );
     storageOf_gnu_attribute_section_name.storeDataInEasyStorageClass(source->p_gnu_attribute_section_name);
     storageOf_gnu_attribute_visability =  source->p_gnu_attribute_visability ;
     storageOf_microsoft_uuid_string.storeDataInEasyStorageClass(source->p_microsoft_uuid_string);
     storageOf_microsoft_property_get_function_name.storeDataInEasyStorageClass(source->p_microsoft_property_get_function_name);
     storageOf_microsoft_property_put_function_name.storeDataInEasyStorageClass(source->p_microsoft_property_put_function_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDeclarationModifierStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclarationModifierStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgDeclarationModifierStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgDeclarationModifierStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     SgTypeModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1855 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOpenclAccessModeModifierStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1868 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOpenclAccessModeModifierStorageClass::pickOutIRNodeData ( SgOpenclAccessModeModifier* pointer ) 
   { 
     SgOpenclAccessModeModifier* source = (SgOpenclAccessModeModifier*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modifier =  source->p_modifier ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1891 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1904 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNameStorageClass::pickOutIRNodeData ( SgName* pointer ) 
   { 
     SgName* source = (SgName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_char.storeDataInEasyStorageClass(source->p_char);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNameStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNameStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgNameStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgNameStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 1953 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSymbolTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 1966 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSymbolTableStorageClass::pickOutIRNodeData ( SgSymbolTable* pointer ) 
   { 
     SgSymbolTable* source = (SgSymbolTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_no_name =  source->p_no_name ;
     rose_hash_multimap::iterator it; 
     unsigned int tempListCounttable = 0; 
     SgSymbol** tempListtable = new SgSymbol* [ source->p_table->size() ]; 
     for (it = source->p_table->begin(); it != source->p_table->end(); ++it)
        {
          tempListtable[tempListCounttable] = it->second;
          tempListCounttable++; 
          it->second = (SgSymbol*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(it->second) ); 
        }
     storageOf_table.storeDataInEasyStorageClass(source->p_table);
     tempListCounttable = 0; 
     for (it = source->p_table->begin(); it != source->p_table->end(); ++it) 
        {
          it->second = tempListtable [ tempListCounttable ]; 
          tempListCounttable++; 
        }
      delete [] tempListtable; 
     storageOf_symbolSet.storeDataInEasyStorageClass(source->p_symbolSet);
     storageOf_case_insensitive =  source->p_case_insensitive ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSymbolTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage <  rose_hash_multimap* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgNodeSet > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSymbolTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage <  rose_hash_multimap* > :: deleteMemoryPool() ;
     EasyStorage < SgNodeSet > :: deleteMemoryPool() ;
   }

void
SgSymbolTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage <  rose_hash_multimap* > :: writeToFile(out) ;
     EasyStorage < SgNodeSet > :: writeToFile(out) ;
   }


void
SgSymbolTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage <  rose_hash_multimap* > :: readFromFile(in) ;
     EasyStorage < SgNodeSet > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2043 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2056 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAttributeStorageClass::pickOutIRNodeData ( SgAttribute* pointer ) 
   { 
     SgAttribute* source = (SgAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAttributeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAttributeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAttributeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAttributeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2105 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPragmaStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2118 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPragmaStorageClass::pickOutIRNodeData ( SgPragma* pointer ) 
   { 
     SgPragma* source = (SgPragma*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_printed =  source->p_printed ;
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_associatedStatement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedStatement );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPragmaStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPragmaStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgPragmaStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgPragmaStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2177 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2190 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBitAttributeStorageClass::pickOutIRNodeData ( SgBitAttribute* pointer ) 
   { 
     SgBitAttribute* source = (SgBitAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBitAttributeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitAttributeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgBitAttributeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgBitAttributeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2240 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFuncDecl_attrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2253 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFuncDecl_attrStorageClass::pickOutIRNodeData ( SgFuncDecl_attr* pointer ) 
   { 
     SgFuncDecl_attr* source = (SgFuncDecl_attr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFuncDecl_attrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFuncDecl_attrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgFuncDecl_attrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgFuncDecl_attrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2303 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDecl_attrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2316 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClassDecl_attrStorageClass::pickOutIRNodeData ( SgClassDecl_attr* pointer ) 
   { 
     SgClassDecl_attr* source = (SgClassDecl_attr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bitflag =  source->p_bitflag ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClassDecl_attrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDecl_attrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgClassDecl_attrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgClassDecl_attrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2366 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the Sg_File_InfoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2379 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
Sg_File_InfoStorageClass::pickOutIRNodeData ( Sg_File_Info* pointer ) 
   { 
     Sg_File_Info* source = (Sg_File_Info*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file_id =  source->p_file_id ;
     storageOf_line =  source->p_line ;
     storageOf_col =  source->p_col ;
     storageOf_classificationBitField =  source->p_classificationBitField ;
     storageOf_physical_file_id =  source->p_physical_file_id ;
     storageOf_physical_line =  source->p_physical_line ;
     storageOf_source_sequence_number =  source->p_source_sequence_number ;
     storageOf_fileIDsToUnparse.storeDataInEasyStorageClass(source->p_fileIDsToUnparse);
     storageOf_fileLineNumbersToUnparse.storeDataInEasyStorageClass(source->p_fileLineNumbersToUnparse);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
Sg_File_InfoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileIdList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileLineNumberList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
Sg_File_InfoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileIdList > :: deleteMemoryPool() ;
     EasyStorage < SgFileLineNumberList > :: deleteMemoryPool() ;
   }

void
Sg_File_InfoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileIdList > :: writeToFile(out) ;
     EasyStorage < SgFileLineNumberList > :: writeToFile(out) ;
   }


void
Sg_File_InfoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileIdList > :: readFromFile(in) ;
     EasyStorage < SgFileLineNumberList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2440 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2453 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFileStorageClass::pickOutIRNodeData ( SgFile* pointer ) 
   { 
     SgFile* source = (SgFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_Jvm_only =  source->p_Jvm_only ;
     storageOf_Jovial_only =  source->p_Jovial_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_Csharp_only =  source->p_Csharp_only ;
     storageOf_Ada_only =  source->p_Ada_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_openacc =  source->p_openacc ;
     storageOf_openacc_parse_only =  source->p_openacc_parse_only ;
     storageOf_openacc_ast_only =  source->p_openacc_ast_only ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_failsafe =  source->p_failsafe ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_skip_parser =  source->p_skip_parser ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_function_calls_using_operator_syntax =  source->p_unparse_function_calls_using_operator_syntax ;
     storageOf_unparse_function_calls_using_operator_names =  source->p_unparse_function_calls_using_operator_names ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_inputLanguage =  source->p_inputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_objectFileNameWithPath.storeDataInEasyStorageClass(source->p_objectFileNameWithPath);
     storageOf_objectFileNameWithoutPath.storeDataInEasyStorageClass(source->p_objectFileNameWithoutPath);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedFrontendCommandLine.storeDataInEasyStorageClass(source->p_savedFrontendCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_translateCommentsAndDirectivesIntoAST =  source->p_translateCommentsAndDirectivesIntoAST ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesFortran2008FileExtension =  source->p_sourceFileUsesFortran2008FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesJvmFileExtension =  source->p_sourceFileUsesJvmFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_sourceFileUsesCsharpFileExtension =  source->p_sourceFileUsesCsharpFileExtension ;
     storageOf_sourceFileUsesAdaFileExtension =  source->p_sourceFileUsesAdaFileExtension ;
     storageOf_sourceFileUsesJovialFileExtension =  source->p_sourceFileUsesJovialFileExtension ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_experimental_flang_frontend =  source->p_experimental_flang_frontend ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_unparse_tokens =  source->p_unparse_tokens ;
     storageOf_unparse_tokens_testing =  source->p_unparse_tokens_testing ;
     storageOf_unparse_using_leading_and_trailing_token_mappings =  source->p_unparse_using_leading_and_trailing_token_mappings ;
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_skipAstConsistancyTests =  source->p_skipAstConsistancyTests ;
     storageOf_multifile_support =  source->p_multifile_support ;
     storageOf_optimization =  source->p_optimization ;
     storageOf_use_token_stream_to_improve_source_position_info =  source->p_use_token_stream_to_improve_source_position_info ;
     storageOf_suppress_variable_declaration_normalization =  source->p_suppress_variable_declaration_normalization ;
     storageOf_edg_il_to_graphviz =  source->p_edg_il_to_graphviz ;
     storageOf_clang_il_to_graphviz =  source->p_clang_il_to_graphviz ;
     storageOf_no_optimize_flag_for_frontend =  source->p_no_optimize_flag_for_frontend ;
     storageOf_unparse_edg_normalized_method_ROSE_1392 =  source->p_unparse_edg_normalized_method_ROSE_1392 ;
     storageOf_standard =  source->p_standard ;
     storageOf_gnu_standard =  source->p_gnu_standard ;
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_javacErrorCode =  source->p_javacErrorCode ;
     storageOf_ecjErrorCode =  source->p_ecjErrorCode ;
     storageOf_midendErrorCode =  source->p_midendErrorCode ;
     storageOf_unparserErrorCode =  source->p_unparserErrorCode ;
     storageOf_backendCompilerErrorCode =  source->p_backendCompilerErrorCode ;
     storageOf_unparsedFileFailedCompilation =  source->p_unparsedFileFailedCompilation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2641 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSourceFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2654 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSourceFileStorageClass::pickOutIRNodeData ( SgSourceFile* pointer ) 
   { 
     SgSourceFile* source = (SgSourceFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_globalScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalScope );
     SgModuleStatementPtrList::iterator i_module_list = source->p_module_list.begin() ; 
     unsigned int tempListCountmodule_list = 0; 
     SgModuleStatementPtrList::value_type *  tempListmodule_list = new SgModuleStatementPtrList::value_type[ source->p_module_list.size() ]; 
     for ( ; i_module_list != source->p_module_list.end(); ++i_module_list ) 
        {
          tempListmodule_list[tempListCountmodule_list] = *i_module_list;
          tempListCountmodule_list++; 
          (*i_module_list) = (SgModuleStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_module_list ) );
        }
     storageOf_module_list.storeDataInEasyStorageClass(source->p_module_list);
     tempListCountmodule_list = 0; 
     i_module_list = source->p_module_list.begin() ; 
     for ( ; i_module_list != source->p_module_list.end(); ++i_module_list ) 
        {
          *i_module_list = tempListmodule_list[tempListCountmodule_list] ;
          tempListCountmodule_list++; 
        }
      delete [] tempListmodule_list; 
     SgTokenPtrList::iterator i_token_list = source->p_token_list.begin() ; 
     unsigned int tempListCounttoken_list = 0; 
     SgTokenPtrList::value_type *  tempListtoken_list = new SgTokenPtrList::value_type[ source->p_token_list.size() ]; 
     for ( ; i_token_list != source->p_token_list.end(); ++i_token_list ) 
        {
          tempListtoken_list[tempListCounttoken_list] = *i_token_list;
          tempListCounttoken_list++; 
          (*i_token_list) = (SgTokenPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_token_list ) );
        }
     storageOf_token_list.storeDataInEasyStorageClass(source->p_token_list);
     tempListCounttoken_list = 0; 
     i_token_list = source->p_token_list.begin() ; 
     for ( ; i_token_list != source->p_token_list.end(); ++i_token_list ) 
        {
          *i_token_list = tempListtoken_list[tempListCounttoken_list] ;
          tempListCounttoken_list++; 
        }
      delete [] tempListtoken_list; 
     storageOf_temp_holding_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_temp_holding_scope );
     storageOf_package = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_package );
     storageOf_import_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_import_list );
     storageOf_class_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_list );
     storageOf_isHeaderFile =  source->p_isHeaderFile ;
     storageOf_isHeaderFileIncludedMoreThanOnce =  source->p_isHeaderFileIncludedMoreThanOnce ;
     storageOf_headerFileReport = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headerFileReport );
     storageOf_extraIncludeDirectorySpecifierBeforeList.storeDataInEasyStorageClass(source->p_extraIncludeDirectorySpecifierBeforeList);
     storageOf_extraIncludeDirectorySpecifierAfterList.storeDataInEasyStorageClass(source->p_extraIncludeDirectorySpecifierAfterList);
     storageOf_associated_include_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associated_include_file );
     storageOf_processedToIncludeCppDirectivesAndComments =  source->p_processedToIncludeCppDirectivesAndComments ;
     SgNodePtrList::iterator i_extra_nodes_for_namequal_init = source->p_extra_nodes_for_namequal_init.begin() ; 
     unsigned int tempListCountextra_nodes_for_namequal_init = 0; 
     SgNodePtrList::value_type *  tempListextra_nodes_for_namequal_init = new SgNodePtrList::value_type[ source->p_extra_nodes_for_namequal_init.size() ]; 
     for ( ; i_extra_nodes_for_namequal_init != source->p_extra_nodes_for_namequal_init.end(); ++i_extra_nodes_for_namequal_init ) 
        {
          tempListextra_nodes_for_namequal_init[tempListCountextra_nodes_for_namequal_init] = *i_extra_nodes_for_namequal_init;
          tempListCountextra_nodes_for_namequal_init++; 
          (*i_extra_nodes_for_namequal_init) = (SgNodePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_extra_nodes_for_namequal_init ) );
        }
     storageOf_extra_nodes_for_namequal_init.storeDataInEasyStorageClass(source->p_extra_nodes_for_namequal_init);
     tempListCountextra_nodes_for_namequal_init = 0; 
     i_extra_nodes_for_namequal_init = source->p_extra_nodes_for_namequal_init.begin() ; 
     for ( ; i_extra_nodes_for_namequal_init != source->p_extra_nodes_for_namequal_init.end(); ++i_extra_nodes_for_namequal_init ) 
        {
          *i_extra_nodes_for_namequal_init = tempListextra_nodes_for_namequal_init[tempListCountextra_nodes_for_namequal_init] ;
          tempListCountextra_nodes_for_namequal_init++; 
        }
      delete [] tempListextra_nodes_for_namequal_init; 
     storageOf_isDynamicLibrary =  source->p_isDynamicLibrary ;
     storageOf_firstStatement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstStatement );
     storageOf_lastStatement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lastStatement );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_Jvm_only =  source->p_Jvm_only ;
     storageOf_Jovial_only =  source->p_Jovial_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_Csharp_only =  source->p_Csharp_only ;
     storageOf_Ada_only =  source->p_Ada_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_openacc =  source->p_openacc ;
     storageOf_openacc_parse_only =  source->p_openacc_parse_only ;
     storageOf_openacc_ast_only =  source->p_openacc_ast_only ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_failsafe =  source->p_failsafe ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_skip_parser =  source->p_skip_parser ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_function_calls_using_operator_syntax =  source->p_unparse_function_calls_using_operator_syntax ;
     storageOf_unparse_function_calls_using_operator_names =  source->p_unparse_function_calls_using_operator_names ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_inputLanguage =  source->p_inputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_objectFileNameWithPath.storeDataInEasyStorageClass(source->p_objectFileNameWithPath);
     storageOf_objectFileNameWithoutPath.storeDataInEasyStorageClass(source->p_objectFileNameWithoutPath);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedFrontendCommandLine.storeDataInEasyStorageClass(source->p_savedFrontendCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_translateCommentsAndDirectivesIntoAST =  source->p_translateCommentsAndDirectivesIntoAST ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesFortran2008FileExtension =  source->p_sourceFileUsesFortran2008FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesJvmFileExtension =  source->p_sourceFileUsesJvmFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_sourceFileUsesCsharpFileExtension =  source->p_sourceFileUsesCsharpFileExtension ;
     storageOf_sourceFileUsesAdaFileExtension =  source->p_sourceFileUsesAdaFileExtension ;
     storageOf_sourceFileUsesJovialFileExtension =  source->p_sourceFileUsesJovialFileExtension ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_experimental_flang_frontend =  source->p_experimental_flang_frontend ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_unparse_tokens =  source->p_unparse_tokens ;
     storageOf_unparse_tokens_testing =  source->p_unparse_tokens_testing ;
     storageOf_unparse_using_leading_and_trailing_token_mappings =  source->p_unparse_using_leading_and_trailing_token_mappings ;
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_skipAstConsistancyTests =  source->p_skipAstConsistancyTests ;
     storageOf_multifile_support =  source->p_multifile_support ;
     storageOf_optimization =  source->p_optimization ;
     storageOf_use_token_stream_to_improve_source_position_info =  source->p_use_token_stream_to_improve_source_position_info ;
     storageOf_suppress_variable_declaration_normalization =  source->p_suppress_variable_declaration_normalization ;
     storageOf_edg_il_to_graphviz =  source->p_edg_il_to_graphviz ;
     storageOf_clang_il_to_graphviz =  source->p_clang_il_to_graphviz ;
     storageOf_no_optimize_flag_for_frontend =  source->p_no_optimize_flag_for_frontend ;
     storageOf_unparse_edg_normalized_method_ROSE_1392 =  source->p_unparse_edg_normalized_method_ROSE_1392 ;
     storageOf_standard =  source->p_standard ;
     storageOf_gnu_standard =  source->p_gnu_standard ;
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_javacErrorCode =  source->p_javacErrorCode ;
     storageOf_ecjErrorCode =  source->p_ecjErrorCode ;
     storageOf_midendErrorCode =  source->p_midendErrorCode ;
     storageOf_unparserErrorCode =  source->p_unparserErrorCode ;
     storageOf_backendCompilerErrorCode =  source->p_backendCompilerErrorCode ;
     storageOf_unparsedFileFailedCompilation =  source->p_unparsedFileFailedCompilation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSourceFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgModuleStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTokenPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgNodePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSourceFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgModuleStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTokenPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgNodePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSourceFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgModuleStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgTokenPtrList > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgNodePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSourceFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgModuleStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgTokenPtrList > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgNodePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 2923 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnknownFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 2936 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnknownFileStorageClass::pickOutIRNodeData ( SgUnknownFile* pointer ) 
   { 
     SgUnknownFile* source = (SgUnknownFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_globalScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalScope );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_Jvm_only =  source->p_Jvm_only ;
     storageOf_Jovial_only =  source->p_Jovial_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_Csharp_only =  source->p_Csharp_only ;
     storageOf_Ada_only =  source->p_Ada_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_openacc =  source->p_openacc ;
     storageOf_openacc_parse_only =  source->p_openacc_parse_only ;
     storageOf_openacc_ast_only =  source->p_openacc_ast_only ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_failsafe =  source->p_failsafe ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_skip_parser =  source->p_skip_parser ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_function_calls_using_operator_syntax =  source->p_unparse_function_calls_using_operator_syntax ;
     storageOf_unparse_function_calls_using_operator_names =  source->p_unparse_function_calls_using_operator_names ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_inputLanguage =  source->p_inputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_objectFileNameWithPath.storeDataInEasyStorageClass(source->p_objectFileNameWithPath);
     storageOf_objectFileNameWithoutPath.storeDataInEasyStorageClass(source->p_objectFileNameWithoutPath);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedFrontendCommandLine.storeDataInEasyStorageClass(source->p_savedFrontendCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_translateCommentsAndDirectivesIntoAST =  source->p_translateCommentsAndDirectivesIntoAST ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesFortran2008FileExtension =  source->p_sourceFileUsesFortran2008FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesJvmFileExtension =  source->p_sourceFileUsesJvmFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_sourceFileUsesCsharpFileExtension =  source->p_sourceFileUsesCsharpFileExtension ;
     storageOf_sourceFileUsesAdaFileExtension =  source->p_sourceFileUsesAdaFileExtension ;
     storageOf_sourceFileUsesJovialFileExtension =  source->p_sourceFileUsesJovialFileExtension ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_experimental_flang_frontend =  source->p_experimental_flang_frontend ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_unparse_tokens =  source->p_unparse_tokens ;
     storageOf_unparse_tokens_testing =  source->p_unparse_tokens_testing ;
     storageOf_unparse_using_leading_and_trailing_token_mappings =  source->p_unparse_using_leading_and_trailing_token_mappings ;
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_skipAstConsistancyTests =  source->p_skipAstConsistancyTests ;
     storageOf_multifile_support =  source->p_multifile_support ;
     storageOf_optimization =  source->p_optimization ;
     storageOf_use_token_stream_to_improve_source_position_info =  source->p_use_token_stream_to_improve_source_position_info ;
     storageOf_suppress_variable_declaration_normalization =  source->p_suppress_variable_declaration_normalization ;
     storageOf_edg_il_to_graphviz =  source->p_edg_il_to_graphviz ;
     storageOf_clang_il_to_graphviz =  source->p_clang_il_to_graphviz ;
     storageOf_no_optimize_flag_for_frontend =  source->p_no_optimize_flag_for_frontend ;
     storageOf_unparse_edg_normalized_method_ROSE_1392 =  source->p_unparse_edg_normalized_method_ROSE_1392 ;
     storageOf_standard =  source->p_standard ;
     storageOf_gnu_standard =  source->p_gnu_standard ;
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_javacErrorCode =  source->p_javacErrorCode ;
     storageOf_ecjErrorCode =  source->p_ecjErrorCode ;
     storageOf_midendErrorCode =  source->p_midendErrorCode ;
     storageOf_unparserErrorCode =  source->p_unparserErrorCode ;
     storageOf_backendCompilerErrorCode =  source->p_backendCompilerErrorCode ;
     storageOf_unparsedFileFailedCompilation =  source->p_unparsedFileFailedCompilation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnknownFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnknownFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnknownFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnknownFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3125 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBinaryCompositeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3138 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBinaryCompositeStorageClass::pickOutIRNodeData ( SgBinaryComposite* pointer ) 
   { 
     SgBinaryComposite* source = (SgBinaryComposite*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_genericFileList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_genericFileList );
     storageOf_interpretations = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_interpretations );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_Jvm_only =  source->p_Jvm_only ;
     storageOf_Jovial_only =  source->p_Jovial_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_Csharp_only =  source->p_Csharp_only ;
     storageOf_Ada_only =  source->p_Ada_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_openacc =  source->p_openacc ;
     storageOf_openacc_parse_only =  source->p_openacc_parse_only ;
     storageOf_openacc_ast_only =  source->p_openacc_ast_only ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_failsafe =  source->p_failsafe ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_skip_parser =  source->p_skip_parser ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_function_calls_using_operator_syntax =  source->p_unparse_function_calls_using_operator_syntax ;
     storageOf_unparse_function_calls_using_operator_names =  source->p_unparse_function_calls_using_operator_names ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_inputLanguage =  source->p_inputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_objectFileNameWithPath.storeDataInEasyStorageClass(source->p_objectFileNameWithPath);
     storageOf_objectFileNameWithoutPath.storeDataInEasyStorageClass(source->p_objectFileNameWithoutPath);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedFrontendCommandLine.storeDataInEasyStorageClass(source->p_savedFrontendCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_translateCommentsAndDirectivesIntoAST =  source->p_translateCommentsAndDirectivesIntoAST ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesFortran2008FileExtension =  source->p_sourceFileUsesFortran2008FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesJvmFileExtension =  source->p_sourceFileUsesJvmFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_sourceFileUsesCsharpFileExtension =  source->p_sourceFileUsesCsharpFileExtension ;
     storageOf_sourceFileUsesAdaFileExtension =  source->p_sourceFileUsesAdaFileExtension ;
     storageOf_sourceFileUsesJovialFileExtension =  source->p_sourceFileUsesJovialFileExtension ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_experimental_flang_frontend =  source->p_experimental_flang_frontend ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_unparse_tokens =  source->p_unparse_tokens ;
     storageOf_unparse_tokens_testing =  source->p_unparse_tokens_testing ;
     storageOf_unparse_using_leading_and_trailing_token_mappings =  source->p_unparse_using_leading_and_trailing_token_mappings ;
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_skipAstConsistancyTests =  source->p_skipAstConsistancyTests ;
     storageOf_multifile_support =  source->p_multifile_support ;
     storageOf_optimization =  source->p_optimization ;
     storageOf_use_token_stream_to_improve_source_position_info =  source->p_use_token_stream_to_improve_source_position_info ;
     storageOf_suppress_variable_declaration_normalization =  source->p_suppress_variable_declaration_normalization ;
     storageOf_edg_il_to_graphviz =  source->p_edg_il_to_graphviz ;
     storageOf_clang_il_to_graphviz =  source->p_clang_il_to_graphviz ;
     storageOf_no_optimize_flag_for_frontend =  source->p_no_optimize_flag_for_frontend ;
     storageOf_unparse_edg_normalized_method_ROSE_1392 =  source->p_unparse_edg_normalized_method_ROSE_1392 ;
     storageOf_standard =  source->p_standard ;
     storageOf_gnu_standard =  source->p_gnu_standard ;
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_javacErrorCode =  source->p_javacErrorCode ;
     storageOf_ecjErrorCode =  source->p_ecjErrorCode ;
     storageOf_midendErrorCode =  source->p_midendErrorCode ;
     storageOf_unparserErrorCode =  source->p_unparserErrorCode ;
     storageOf_backendCompilerErrorCode =  source->p_backendCompilerErrorCode ;
     storageOf_unparsedFileFailedCompilation =  source->p_unparsedFileFailedCompilation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBinaryCompositeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBinaryCompositeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBinaryCompositeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBinaryCompositeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3328 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJvmCompositeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3341 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJvmCompositeStorageClass::pickOutIRNodeData ( SgJvmComposite* pointer ) 
   { 
     SgJvmComposite* source = (SgJvmComposite*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_genericFileList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_genericFileList );
     storageOf_interpretations = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_interpretations );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_verbose =  source->p_verbose ;
     storageOf_output_warnings =  source->p_output_warnings ;
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_CoArrayFortran_only =  source->p_CoArrayFortran_only ;
     storageOf_upc_threads =  source->p_upc_threads ;
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_Jvm_only =  source->p_Jvm_only ;
     storageOf_Jovial_only =  source->p_Jovial_only ;
     storageOf_PHP_only =  source->p_PHP_only ;
     storageOf_Python_only =  source->p_Python_only ;
     storageOf_Cuda_only =  source->p_Cuda_only ;
     storageOf_OpenCL_only =  source->p_OpenCL_only ;
     storageOf_Csharp_only =  source->p_Csharp_only ;
     storageOf_Ada_only =  source->p_Ada_only ;
     storageOf_requires_C_preprocessor =  source->p_requires_C_preprocessor ;
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_inputFormat =  source->p_inputFormat ;
     storageOf_outputFormat =  source->p_outputFormat ;
     storageOf_backendCompileFormat =  source->p_backendCompileFormat ;
     storageOf_fortran_implicit_none =  source->p_fortran_implicit_none ;
     storageOf_openmp =  source->p_openmp ;
     storageOf_openmp_parse_only =  source->p_openmp_parse_only ;
     storageOf_openmp_ast_only =  source->p_openmp_ast_only ;
     storageOf_openmp_lowering =  source->p_openmp_lowering ;
     storageOf_openacc =  source->p_openacc ;
     storageOf_openacc_parse_only =  source->p_openacc_parse_only ;
     storageOf_openacc_ast_only =  source->p_openacc_ast_only ;
     storageOf_cray_pointer_support =  source->p_cray_pointer_support ;
     storageOf_failsafe =  source->p_failsafe ;
     storageOf_output_parser_actions =  source->p_output_parser_actions ;
     storageOf_exit_after_parser =  source->p_exit_after_parser ;
     storageOf_skip_syntax_check =  source->p_skip_syntax_check ;
     storageOf_skip_parser =  source->p_skip_parser ;
     storageOf_relax_syntax_check =  source->p_relax_syntax_check ;
     storageOf_skip_translation_from_edg_ast_to_rose_ast =  source->p_skip_translation_from_edg_ast_to_rose_ast ;
     storageOf_skip_transformation =  source->p_skip_transformation ;
     storageOf_skip_unparse =  source->p_skip_unparse ;
     storageOf_skipfinalCompileStep =  source->p_skipfinalCompileStep ;
     storageOf_unparse_includes =  source->p_unparse_includes ;
     storageOf_unparse_line_directives =  source->p_unparse_line_directives ;
     storageOf_unparse_function_calls_using_operator_syntax =  source->p_unparse_function_calls_using_operator_syntax ;
     storageOf_unparse_function_calls_using_operator_names =  source->p_unparse_function_calls_using_operator_names ;
     storageOf_unparse_instruction_addresses =  source->p_unparse_instruction_addresses ;
     storageOf_unparse_raw_memory_contents =  source->p_unparse_raw_memory_contents ;
     storageOf_unparse_binary_file_format =  source->p_unparse_binary_file_format ;
     storageOf_outputLanguage =  source->p_outputLanguage ;
     storageOf_inputLanguage =  source->p_inputLanguage ;
     storageOf_sourceFileNameWithPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithPath);
     storageOf_sourceFileNameWithoutPath.storeDataInEasyStorageClass(source->p_sourceFileNameWithoutPath);
     storageOf_unparse_output_filename.storeDataInEasyStorageClass(source->p_unparse_output_filename);
     storageOf_objectFileNameWithPath.storeDataInEasyStorageClass(source->p_objectFileNameWithPath);
     storageOf_objectFileNameWithoutPath.storeDataInEasyStorageClass(source->p_objectFileNameWithoutPath);
     storageOf_useBackendOnly =  source->p_useBackendOnly ;
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_savedFrontendCommandLine.storeDataInEasyStorageClass(source->p_savedFrontendCommandLine);
     storageOf_no_implicit_templates =  source->p_no_implicit_templates ;
     storageOf_no_implicit_inline_templates =  source->p_no_implicit_inline_templates ;
     storageOf_skip_commentsAndDirectives =  source->p_skip_commentsAndDirectives ;
     storageOf_collectAllCommentsAndDirectives =  source->p_collectAllCommentsAndDirectives ;
     storageOf_translateCommentsAndDirectivesIntoAST =  source->p_translateCommentsAndDirectivesIntoAST ;
     storageOf_unparseHeaderFiles =  source->p_unparseHeaderFiles ;
     storageOf_preprocessorDirectivesAndCommentsList.storeDataInEasyStorageClass(source->p_preprocessorDirectivesAndCommentsList);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_KCC_frontend =  source->p_KCC_frontend ;
     storageOf_new_frontend =  source->p_new_frontend ;
     storageOf_disable_edg_backend =  source->p_disable_edg_backend ;
     storageOf_disable_sage_backend =  source->p_disable_sage_backend ;
     storageOf_testingLevel =  source->p_testingLevel ;
     storageOf_preinit_il =  source->p_preinit_il ;
     storageOf_enable_cp_backend =  source->p_enable_cp_backend ;
     storageOf_markGeneratedFiles =  source->p_markGeneratedFiles ;
     storageOf_negative_test =  source->p_negative_test ;
     storageOf_strict_language_handling =  source->p_strict_language_handling ;
     storageOf_wave =  source->p_wave ;
     storageOf_embedColorCodesInGeneratedCode =  source->p_embedColorCodesInGeneratedCode ;
     storageOf_generateSourcePositionCodes =  source->p_generateSourcePositionCodes ;
     storageOf_sourceFileUsesCppFileExtension =  source->p_sourceFileUsesCppFileExtension ;
     storageOf_sourceFileUsesFortranFileExtension =  source->p_sourceFileUsesFortranFileExtension ;
     storageOf_sourceFileUsesFortran77FileExtension =  source->p_sourceFileUsesFortran77FileExtension ;
     storageOf_sourceFileUsesFortran90FileExtension =  source->p_sourceFileUsesFortran90FileExtension ;
     storageOf_sourceFileUsesFortran95FileExtension =  source->p_sourceFileUsesFortran95FileExtension ;
     storageOf_sourceFileUsesFortran2003FileExtension =  source->p_sourceFileUsesFortran2003FileExtension ;
     storageOf_sourceFileUsesFortran2008FileExtension =  source->p_sourceFileUsesFortran2008FileExtension ;
     storageOf_sourceFileUsesCoArrayFortranFileExtension =  source->p_sourceFileUsesCoArrayFortranFileExtension ;
     storageOf_sourceFileUsesPHPFileExtension =  source->p_sourceFileUsesPHPFileExtension ;
     storageOf_sourceFileUsesPythonFileExtension =  source->p_sourceFileUsesPythonFileExtension ;
     storageOf_sourceFileUsesJavaFileExtension =  source->p_sourceFileUsesJavaFileExtension ;
     storageOf_sourceFileUsesJvmFileExtension =  source->p_sourceFileUsesJvmFileExtension ;
     storageOf_sourceFileUsesBinaryFileExtension =  source->p_sourceFileUsesBinaryFileExtension ;
     storageOf_sourceFileTypeIsUnknown =  source->p_sourceFileTypeIsUnknown ;
     storageOf_sourceFileUsesCsharpFileExtension =  source->p_sourceFileUsesCsharpFileExtension ;
     storageOf_sourceFileUsesAdaFileExtension =  source->p_sourceFileUsesAdaFileExtension ;
     storageOf_sourceFileUsesJovialFileExtension =  source->p_sourceFileUsesJovialFileExtension ;
     storageOf_detect_dangling_pointers =  source->p_detect_dangling_pointers ;
     storageOf_experimental_flang_frontend =  source->p_experimental_flang_frontend ;
     storageOf_read_executable_file_format_only =  source->p_read_executable_file_format_only ;
     storageOf_visualize_executable_file_format_skip_symbols =  source->p_visualize_executable_file_format_skip_symbols ;
     storageOf_visualize_dwarf_only =  source->p_visualize_dwarf_only ;
     storageOf_read_instructions_only =  source->p_read_instructions_only ;
     storageOf_libraryArchiveObjectFileNameList.storeDataInEasyStorageClass(source->p_libraryArchiveObjectFileNameList);
     storageOf_isLibraryArchive =  source->p_isLibraryArchive ;
     storageOf_isObjectFile =  source->p_isObjectFile ;
     storageOf_unparse_tokens =  source->p_unparse_tokens ;
     storageOf_unparse_tokens_testing =  source->p_unparse_tokens_testing ;
     storageOf_unparse_using_leading_and_trailing_token_mappings =  source->p_unparse_using_leading_and_trailing_token_mappings ;
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_skipAstConsistancyTests =  source->p_skipAstConsistancyTests ;
     storageOf_multifile_support =  source->p_multifile_support ;
     storageOf_optimization =  source->p_optimization ;
     storageOf_use_token_stream_to_improve_source_position_info =  source->p_use_token_stream_to_improve_source_position_info ;
     storageOf_suppress_variable_declaration_normalization =  source->p_suppress_variable_declaration_normalization ;
     storageOf_edg_il_to_graphviz =  source->p_edg_il_to_graphviz ;
     storageOf_clang_il_to_graphviz =  source->p_clang_il_to_graphviz ;
     storageOf_no_optimize_flag_for_frontend =  source->p_no_optimize_flag_for_frontend ;
     storageOf_unparse_edg_normalized_method_ROSE_1392 =  source->p_unparse_edg_normalized_method_ROSE_1392 ;
     storageOf_standard =  source->p_standard ;
     storageOf_gnu_standard =  source->p_gnu_standard ;
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_javacErrorCode =  source->p_javacErrorCode ;
     storageOf_ecjErrorCode =  source->p_ecjErrorCode ;
     storageOf_midendErrorCode =  source->p_midendErrorCode ;
     storageOf_unparserErrorCode =  source->p_unparserErrorCode ;
     storageOf_backendCompilerErrorCode =  source->p_backendCompilerErrorCode ;
     storageOf_unparsedFileFailedCompilation =  source->p_unparsedFileFailedCompilation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJvmCompositeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJvmCompositeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < ROSEAttributesListContainerPtr > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJvmCompositeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJvmCompositeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < ROSEAttributesListContainerPtr > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3531 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3544 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgProjectStorageClass::pickOutIRNodeData ( SgProject* pointer ) 
   { 
     SgProject* source = (SgProject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_fileList_ptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fileList_ptr );
     storageOf_originalCommandLineArgumentList.storeDataInEasyStorageClass(source->p_originalCommandLineArgumentList);
     storageOf_frontendErrorCode =  source->p_frontendErrorCode ;
     storageOf_javacErrorCode =  source->p_javacErrorCode ;
     storageOf_ecjErrorCode =  source->p_ecjErrorCode ;
     storageOf_midendErrorCode =  source->p_midendErrorCode ;
     storageOf_backendErrorCode =  source->p_backendErrorCode ;
     storageOf_keep_going =  source->p_keep_going ;
     storageOf_unparser__clobber_input_file =  source->p_unparser__clobber_input_file ;
     storageOf_outputFileName.storeDataInEasyStorageClass(source->p_outputFileName);
     storageOf_sourceFileNameList.storeDataInEasyStorageClass(source->p_sourceFileNameList);
     storageOf_objectFileNameList.storeDataInEasyStorageClass(source->p_objectFileNameList);
     storageOf_libraryFileList.storeDataInEasyStorageClass(source->p_libraryFileList);
     storageOf_librarySpecifierList.storeDataInEasyStorageClass(source->p_librarySpecifierList);
     storageOf_libraryDirectorySpecifierList.storeDataInEasyStorageClass(source->p_libraryDirectorySpecifierList);
     storageOf_includeDirectorySpecifierList.storeDataInEasyStorageClass(source->p_includeDirectorySpecifierList);
     storageOf_macroSpecifierList.storeDataInEasyStorageClass(source->p_macroSpecifierList);
     storageOf_preincludeFileList.storeDataInEasyStorageClass(source->p_preincludeFileList);
     storageOf_preincludeDirectoryList.storeDataInEasyStorageClass(source->p_preincludeDirectoryList);
     storageOf_compileOnly =  source->p_compileOnly ;
     storageOf_wave =  source->p_wave ;
     storageOf_prelink =  source->p_prelink ;
     storageOf_template_instantiation_mode =  source->p_template_instantiation_mode ;
     storageOf_ast_merge =  source->p_ast_merge ;
     storageOf_projectSpecificDatabaseFile.storeDataInEasyStorageClass(source->p_projectSpecificDatabaseFile);
     storageOf_C_PreprocessorOnly =  source->p_C_PreprocessorOnly ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_compilationPerformanceFile.storeDataInEasyStorageClass(source->p_compilationPerformanceFile);
     storageOf_includePathList.storeDataInEasyStorageClass(source->p_includePathList);
     storageOf_excludePathList.storeDataInEasyStorageClass(source->p_excludePathList);
     storageOf_includeFileList.storeDataInEasyStorageClass(source->p_includeFileList);
     storageOf_excludeFileList.storeDataInEasyStorageClass(source->p_excludeFileList);
     storageOf_binary_only =  source->p_binary_only ;
     storageOf_dataBaseFilename.storeDataInEasyStorageClass(source->p_dataBaseFilename);
     storageOf_directoryList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_directoryList );
     storageOf_C_only =  source->p_C_only ;
     storageOf_Cxx_only =  source->p_Cxx_only ;
     storageOf_C11_only =  source->p_C11_only ;
     storageOf_Cxx0x_only =  source->p_Cxx0x_only ;
     storageOf_Cxx11_only =  source->p_Cxx11_only ;
     storageOf_C14_only =  source->p_C14_only ;
     storageOf_Cxx14_only =  source->p_Cxx14_only ;
     storageOf_Fortran_only =  source->p_Fortran_only ;
     storageOf_Fortran_ofp_jvm_options.storeDataInEasyStorageClass(source->p_Fortran_ofp_jvm_options);
     storageOf_Java_only =  source->p_Java_only ;
     storageOf_Jvm_only =  source->p_Jvm_only ;
     storageOf_Jovial_only =  source->p_Jovial_only ;
     storageOf_Ada_only =  source->p_Ada_only ;
     storageOf_openmp_linking =  source->p_openmp_linking ;
     storageOf_Java_ecj_jvm_options.storeDataInEasyStorageClass(source->p_Java_ecj_jvm_options);
     storageOf_Java_batch_mode =  source->p_Java_batch_mode ;
     storageOf_Java_classpath.storeDataInEasyStorageClass(source->p_Java_classpath);
     storageOf_Java_sourcepath.storeDataInEasyStorageClass(source->p_Java_sourcepath);
     storageOf_Java_destdir.storeDataInEasyStorageClass(source->p_Java_destdir);
     storageOf_Java_source_destdir.storeDataInEasyStorageClass(source->p_Java_source_destdir);
     storageOf_Java_s.storeDataInEasyStorageClass(source->p_Java_s);
     storageOf_Java_source.storeDataInEasyStorageClass(source->p_Java_source);
     storageOf_Java_target.storeDataInEasyStorageClass(source->p_Java_target);
     storageOf_Java_encoding.storeDataInEasyStorageClass(source->p_Java_encoding);
     storageOf_Java_g.storeDataInEasyStorageClass(source->p_Java_g);
     storageOf_Java_nowarn =  source->p_Java_nowarn ;
     storageOf_Java_verbose =  source->p_Java_verbose ;
     storageOf_Java_deprecation =  source->p_Java_deprecation ;
     storageOf_Java_bootclasspath.storeDataInEasyStorageClass(source->p_Java_bootclasspath);
     storageOf_addCppDirectivesToAST =  source->p_addCppDirectivesToAST ;
     storageOf_includingPreprocessingInfosMap.storeDataInEasyStorageClass(source->p_includingPreprocessingInfosMap);
     storageOf_quotedIncludesSearchPaths.storeDataInEasyStorageClass(source->p_quotedIncludesSearchPaths);
     storageOf_bracketedIncludesSearchPaths.storeDataInEasyStorageClass(source->p_bracketedIncludesSearchPaths);
     storageOf_unparseHeaderFilesRootFolder.storeDataInEasyStorageClass(source->p_unparseHeaderFilesRootFolder);
     storageOf_frontendConstantFolding =  source->p_frontendConstantFolding ;
     storageOf_globalScopeAcrossFiles = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalScopeAcrossFiles );
     storageOf_unparse_in_same_directory_as_input_file =  source->p_unparse_in_same_directory_as_input_file ;
     storageOf_stop_after_compilation_do_not_assemble_file =  source->p_stop_after_compilation_do_not_assemble_file ;
     storageOf_gnuOptionForUndefinedSymbol.storeDataInEasyStorageClass(source->p_gnuOptionForUndefinedSymbol);
     storageOf_mode_32_bit =  source->p_mode_32_bit ;
     storageOf_noclobber_output_file =  source->p_noclobber_output_file ;
     storageOf_noclobber_if_different_output_file =  source->p_noclobber_if_different_output_file ;
     storageOf_suppressConstantFoldingPostProcessing =  source->p_suppressConstantFoldingPostProcessing ;
     storageOf_suppressNameQualificationAcrossWholeTranslationUnit =  source->p_suppressNameQualificationAcrossWholeTranslationUnit ;
     storageOf_appendPID =  source->p_appendPID ;
     storageOf_reportOnHeaderFileUnparsing =  source->p_reportOnHeaderFileUnparsing ;
     storageOf_applicationRootDirectory.storeDataInEasyStorageClass(source->p_applicationRootDirectory);
     storageOf_usingApplicationRootDirectory =  source->p_usingApplicationRootDirectory ;
     storageOf_usingDeferredTransformations =  source->p_usingDeferredTransformations ;
     storageOf_astfile_out.storeDataInEasyStorageClass(source->p_astfile_out);
     storageOf_astfiles_in.storeDataInEasyStorageClass(source->p_astfiles_in);
     storageOf_extraIncludeDirectorySpecifierBeforeList.storeDataInEasyStorageClass(source->p_extraIncludeDirectorySpecifierBeforeList);
     storageOf_extraIncludeDirectorySpecifierAfterList.storeDataInEasyStorageClass(source->p_extraIncludeDirectorySpecifierAfterList);
     storageOf_skip_post_processing =  source->p_skip_post_processing ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgProjectStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::list<std::string> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProjectStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::list<std::string> > :: deleteMemoryPool() ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: deleteMemoryPool() ;
   }

void
SgProjectStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::list<std::string> > :: writeToFile(out) ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: writeToFile(out) ;
   }


void
SgProjectStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::list<std::string> > :: readFromFile(in) ;
     EasyStorage < std::map<std::string, std::set<PreprocessingInfo*> > > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3697 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOptionsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3710 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOptionsStorageClass::pickOutIRNodeData ( SgOptions* pointer ) 
   { 
     SgOptions* source = (SgOptions*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_debug_level =  source->p_debug_level ;
     storageOf_logging_level =  source->p_logging_level ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3734 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnparse_InfoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3747 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnparse_InfoStorageClass::pickOutIRNodeData ( SgUnparse_Info* pointer ) 
   { 
     SgUnparse_Info* source = (SgUnparse_Info*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_unparse_attribute.storeDataInEasyStorageClass(source->p_unparse_attribute);
     storageOf_access_attribute =  source->p_access_attribute ;
     storageOf_nested_expression =  source->p_nested_expression ;
     storageOf_operator_name.storeDataInEasyStorageClass(source->p_operator_name);
     storageOf_var_name.pickOutIRNodeData( &(source->p_var_name) );
     storageOf_declstatement_ptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declstatement_ptr );
     storageOf_declaration_of_context = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration_of_context );
     storageOf_current_context = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_context );
     storageOf_array_index_list.pickOutIRNodeData( &(source->p_array_index_list) );
     storageOf_current_namespace = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_namespace );
     storageOf_outputCodeGenerationFormatDelimiters =  source->p_outputCodeGenerationFormatDelimiters ;
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_current_function_call = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_function_call );
     storageOf_current_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_scope );
     storageOf_reference_node_for_qualification = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_reference_node_for_qualification );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_nestingLevel =  source->p_nestingLevel ;
     storageOf_language =  source->p_language ;
     storageOf_current_source_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_current_source_file );
     storageOf_use_generated_name_for_template_arguments =  source->p_use_generated_name_for_template_arguments ;
     storageOf_user_defined_literal =  source->p_user_defined_literal ;
     storageOf_declstatement_associated_with_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declstatement_associated_with_type );
     storageOf_context_for_added_parentheses =  source->p_context_for_added_parentheses ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnparse_InfoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnparse_InfoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
   }

void
SgUnparse_InfoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
   }


void
SgUnparse_InfoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3849 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBaseClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3862 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBaseClassStorageClass::pickOutIRNodeData ( SgBaseClass* pointer ) 
   { 
     SgBaseClass* source = (SgBaseClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_class = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class );
     storageOf_isDirectBaseClass =  source->p_isDirectBaseClass ;
     storageOf_baseClassModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseClassModifier );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3890 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpBaseClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3903 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExpBaseClassStorageClass::pickOutIRNodeData ( SgExpBaseClass* pointer ) 
   { 
     SgExpBaseClass* source = (SgExpBaseClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_class_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class_exp );
     storageOf_base_class = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class );
     storageOf_isDirectBaseClass =  source->p_isDirectBaseClass ;
     storageOf_baseClassModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseClassModifier );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3932 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNonrealBaseClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3945 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNonrealBaseClassStorageClass::pickOutIRNodeData ( SgNonrealBaseClass* pointer ) 
   { 
     SgNonrealBaseClass* source = (SgNonrealBaseClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_class_nonreal = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class_nonreal );
     storageOf_base_class = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_class );
     storageOf_isDirectBaseClass =  source->p_isDirectBaseClass ;
     storageOf_baseClassModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseClassModifier );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 3974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefSeqStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 3987 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefSeqStorageClass::pickOutIRNodeData ( SgTypedefSeq* pointer ) 
   { 
     SgTypedefSeq* source = (SgTypedefSeq*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTypePtrList::iterator i_typedefs = source->p_typedefs.begin() ; 
     unsigned int tempListCounttypedefs = 0; 
     SgTypePtrList::value_type *  tempListtypedefs = new SgTypePtrList::value_type[ source->p_typedefs.size() ]; 
     for ( ; i_typedefs != source->p_typedefs.end(); ++i_typedefs ) 
        {
          tempListtypedefs[tempListCounttypedefs] = *i_typedefs;
          tempListCounttypedefs++; 
          (*i_typedefs) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_typedefs ) );
        }
     storageOf_typedefs.storeDataInEasyStorageClass(source->p_typedefs);
     tempListCounttypedefs = 0; 
     i_typedefs = source->p_typedefs.begin() ; 
     for ( ; i_typedefs != source->p_typedefs.end(); ++i_typedefs ) 
        {
          *i_typedefs = tempListtypedefs[tempListCounttypedefs] ;
          tempListCounttypedefs++; 
        }
      delete [] tempListtypedefs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypedefSeqStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefSeqStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
   }

void
SgTypedefSeqStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
   }


void
SgTypedefSeqStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4053 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4066 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateParameterStorageClass::pickOutIRNodeData ( SgTemplateParameter* pointer ) 
   { 
     SgTemplateParameter* source = (SgTemplateParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parameterType =  source->p_parameterType ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_defaultTypeParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultTypeParameter );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_defaultExpressionParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultExpressionParameter );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     storageOf_defaultTemplateDeclarationParameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_defaultTemplateDeclarationParameter );
     storageOf_initializedName = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializedName );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4096 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateArgumentStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4109 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateArgumentStorageClass::pickOutIRNodeData ( SgTemplateArgument* pointer ) 
   { 
     SgTemplateArgument* source = (SgTemplateArgument*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_argumentType =  source->p_argumentType ;
     storageOf_isArrayBoundUnknownType =  source->p_isArrayBoundUnknownType ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_unparsable_type_alias = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unparsable_type_alias );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     storageOf_initializedName = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializedName );
     storageOf_explicitlySpecified =  source->p_explicitlySpecified ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_name_qualification_length_for_type =  source->p_name_qualification_length_for_type ;
     storageOf_type_elaboration_required_for_type =  source->p_type_elaboration_required_for_type ;
     storageOf_global_qualification_required_for_type =  source->p_global_qualification_required_for_type ;
     storageOf_previous_instance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_previous_instance );
     storageOf_next_instance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_next_instance );
     storageOf_is_pack_element =  source->p_is_pack_element ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4149 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4162 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDirectoryStorageClass::pickOutIRNodeData ( SgDirectory* pointer ) 
   { 
     SgDirectory* source = (SgDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_fileList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fileList );
     storageOf_directoryList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_directoryList );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDirectoryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectoryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDirectoryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDirectoryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4218 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFileListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4231 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFileListStorageClass::pickOutIRNodeData ( SgFileList* pointer ) 
   { 
     SgFileList* source = (SgFileList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgFilePtrList::iterator i_listOfFiles = source->p_listOfFiles.begin() ; 
     unsigned int tempListCountlistOfFiles = 0; 
     SgFilePtrList::value_type *  tempListlistOfFiles = new SgFilePtrList::value_type[ source->p_listOfFiles.size() ]; 
     for ( ; i_listOfFiles != source->p_listOfFiles.end(); ++i_listOfFiles ) 
        {
          tempListlistOfFiles[tempListCountlistOfFiles] = *i_listOfFiles;
          tempListCountlistOfFiles++; 
          (*i_listOfFiles) = (SgFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_listOfFiles ) );
        }
     storageOf_listOfFiles.storeDataInEasyStorageClass(source->p_listOfFiles);
     tempListCountlistOfFiles = 0; 
     i_listOfFiles = source->p_listOfFiles.begin() ; 
     for ( ; i_listOfFiles != source->p_listOfFiles.end(); ++i_listOfFiles ) 
        {
          *i_listOfFiles = tempListlistOfFiles[tempListCountlistOfFiles] ;
          tempListCountlistOfFiles++; 
        }
      delete [] tempListlistOfFiles; 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFileListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFileListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFilePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFileListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFilePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFileListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFilePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4302 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectoryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4315 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDirectoryListStorageClass::pickOutIRNodeData ( SgDirectoryList* pointer ) 
   { 
     SgDirectoryList* source = (SgDirectoryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDirectoryPtrList::iterator i_listOfDirectories = source->p_listOfDirectories.begin() ; 
     unsigned int tempListCountlistOfDirectories = 0; 
     SgDirectoryPtrList::value_type *  tempListlistOfDirectories = new SgDirectoryPtrList::value_type[ source->p_listOfDirectories.size() ]; 
     for ( ; i_listOfDirectories != source->p_listOfDirectories.end(); ++i_listOfDirectories ) 
        {
          tempListlistOfDirectories[tempListCountlistOfDirectories] = *i_listOfDirectories;
          tempListCountlistOfDirectories++; 
          (*i_listOfDirectories) = (SgDirectoryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_listOfDirectories ) );
        }
     storageOf_listOfDirectories.storeDataInEasyStorageClass(source->p_listOfDirectories);
     tempListCountlistOfDirectories = 0; 
     i_listOfDirectories = source->p_listOfDirectories.begin() ; 
     for ( ; i_listOfDirectories != source->p_listOfDirectories.end(); ++i_listOfDirectories ) 
        {
          *i_listOfDirectories = tempListlistOfDirectories[tempListCountlistOfDirectories] ;
          tempListCountlistOfDirectories++; 
        }
      delete [] tempListlistOfDirectories; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDirectoryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDirectoryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectoryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDirectoryPtrList > :: deleteMemoryPool() ;
   }

void
SgDirectoryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDirectoryPtrList > :: writeToFile(out) ;
   }


void
SgDirectoryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDirectoryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4381 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterTypeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4394 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterTypeListStorageClass::pickOutIRNodeData ( SgFunctionParameterTypeList* pointer ) 
   { 
     SgFunctionParameterTypeList* source = (SgFunctionParameterTypeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTypePtrList::iterator i_arguments = source->p_arguments.begin() ; 
     unsigned int tempListCountarguments = 0; 
     SgTypePtrList::value_type *  tempListarguments = new SgTypePtrList::value_type[ source->p_arguments.size() ]; 
     for ( ; i_arguments != source->p_arguments.end(); ++i_arguments ) 
        {
          tempListarguments[tempListCountarguments] = *i_arguments;
          tempListCountarguments++; 
          (*i_arguments) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_arguments ) );
        }
     storageOf_arguments.storeDataInEasyStorageClass(source->p_arguments);
     tempListCountarguments = 0; 
     i_arguments = source->p_arguments.begin() ; 
     for ( ; i_arguments != source->p_arguments.end(); ++i_arguments ) 
        {
          *i_arguments = tempListarguments[tempListCountarguments] ;
          tempListCountarguments++; 
        }
      delete [] tempListarguments; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionParameterTypeListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterTypeListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterTypeListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
   }


void
SgFunctionParameterTypeListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4460 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgQualifiedNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4473 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgQualifiedNameStorageClass::pickOutIRNodeData ( SgQualifiedName* pointer ) 
   { 
     SgQualifiedName* source = (SgQualifiedName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4496 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateArgumentListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4509 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateArgumentListStorageClass::pickOutIRNodeData ( SgTemplateArgumentList* pointer ) 
   { 
     SgTemplateArgumentList* source = (SgTemplateArgumentList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTemplateArgumentPtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListargs = new SgTemplateArgumentPtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateArgumentListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateArgumentListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
   }

void
SgTemplateArgumentListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
   }


void
SgTemplateArgumentListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4575 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateParameterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4588 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateParameterListStorageClass::pickOutIRNodeData ( SgTemplateParameterList* pointer ) 
   { 
     SgTemplateParameterList* source = (SgTemplateParameterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgTemplateParameterPtrList::value_type *  tempListargs = new SgTemplateParameterPtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateParameterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateParameterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
   }

void
SgTemplateParameterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
   }


void
SgTemplateParameterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4654 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4667 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGraphStorageClass::pickOutIRNodeData ( SgGraph* pointer ) 
   { 
     SgGraph* source = (SgGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 4865 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncidenceDirectedGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 4878 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIncidenceDirectedGraphStorageClass::pickOutIRNodeData ( SgIncidenceDirectedGraph* pointer ) 
   { 
     SgIncidenceDirectedGraph* source = (SgIncidenceDirectedGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIncidenceDirectedGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncidenceDirectedGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIncidenceDirectedGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIncidenceDirectedGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5114 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5127 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBidirectionalGraphStorageClass::pickOutIRNodeData ( SgBidirectionalGraph* pointer ) 
   { 
     SgBidirectionalGraph* source = (SgBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5363 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringKeyedBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5376 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStringKeyedBidirectionalGraphStorageClass::pickOutIRNodeData ( SgStringKeyedBidirectionalGraph* pointer ) 
   { 
     SgStringKeyedBidirectionalGraph* source = (SgStringKeyedBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgStringKeyedBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgStringKeyedBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5612 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntKeyedBidirectionalGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5625 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIntKeyedBidirectionalGraphStorageClass::pickOutIRNodeData ( SgIntKeyedBidirectionalGraph* pointer ) 
   { 
     SgIntKeyedBidirectionalGraph* source = (SgIntKeyedBidirectionalGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesOut = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesOut.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesOut[tempListCountnode_index_to_edge_multimap_edgesOut] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesOut.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesOut);
     tempListCountnode_index_to_edge_multimap_edgesOut = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesOut.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesOut.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesOut [ tempListCountnode_index_to_edge_multimap_edgesOut ]; 
          tempListCountnode_index_to_edge_multimap_edgesOut++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesOut; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap_edgesIn = new SgGraphEdge* [ source->p_node_index_to_edge_multimap_edgesIn.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap_edgesIn[tempListCountnode_index_to_edge_multimap_edgesIn] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap_edgesIn.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap_edgesIn);
     tempListCountnode_index_to_edge_multimap_edgesIn = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap_edgesIn.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap_edgesIn.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap_edgesIn [ tempListCountnode_index_to_edge_multimap_edgesIn ]; 
          tempListCountnode_index_to_edge_multimap_edgesIn++; 
        }
      delete [] tempListnode_index_to_edge_multimap_edgesIn; 
    }
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIntKeyedBidirectionalGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIntKeyedBidirectionalGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 5861 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncidenceUndirectedGraphStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 5874 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIncidenceUndirectedGraphStorageClass::pickOutIRNodeData ( SgIncidenceUndirectedGraph* pointer ) 
   { 
     SgIncidenceUndirectedGraph* source = (SgIncidenceUndirectedGraph*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     rose_graph_integer_node_hash_map::iterator integer_node_it; 
     unsigned int tempListCountnode_index_to_node_map = 0; 
     SgGraphNode** tempListnode_index_to_node_map = new SgGraphNode* [ source->p_node_index_to_node_map.size() ]; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it)
        {
          tempListnode_index_to_node_map[tempListCountnode_index_to_node_map] = integer_node_it->second;
          tempListCountnode_index_to_node_map++; 
          integer_node_it->second = (SgGraphNode*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_node_it->second) ); 
        }
     storageOf_node_index_to_node_map.storeDataInEasyStorageClass(source->p_node_index_to_node_map);
     tempListCountnode_index_to_node_map = 0; 
     for (integer_node_it = source->p_node_index_to_node_map.begin(); integer_node_it != source->p_node_index_to_node_map.end(); ++integer_node_it) 
        {
          integer_node_it->second = tempListnode_index_to_node_map [ tempListCountnode_index_to_node_map ]; 
          tempListCountnode_index_to_node_map++; 
        }
      delete [] tempListnode_index_to_node_map; 
     rose_graph_integer_edge_hash_map::iterator integer_edge_it; 
     unsigned int tempListCountedge_index_to_edge_map = 0; 
     SgGraphEdge** tempListedge_index_to_edge_map = new SgGraphEdge* [ source->p_edge_index_to_edge_map.size() ]; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it)
        {
          tempListedge_index_to_edge_map[tempListCountedge_index_to_edge_map] = integer_edge_it->second;
          tempListCountedge_index_to_edge_map++; 
          integer_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it->second) ); 
        }
     storageOf_edge_index_to_edge_map.storeDataInEasyStorageClass(source->p_edge_index_to_edge_map);
     tempListCountedge_index_to_edge_map = 0; 
     for (integer_edge_it = source->p_edge_index_to_edge_map.begin(); integer_edge_it != source->p_edge_index_to_edge_map.end(); ++integer_edge_it) 
        {
          integer_edge_it->second = tempListedge_index_to_edge_map [ tempListCountedge_index_to_edge_map ]; 
          tempListCountedge_index_to_edge_map++; 
        }
      delete [] tempListedge_index_to_edge_map; 
     rose_graph_integerpair_edge_hash_multimap::iterator integerpair_edge_it; 
     unsigned int tempListCountnode_index_pair_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_pair_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_pair_to_edge_multimap.size() ]; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it)
        {
          tempListnode_index_pair_to_edge_multimap[tempListCountnode_index_pair_to_edge_multimap] = integerpair_edge_it->second;
          tempListCountnode_index_pair_to_edge_multimap++; 
          integerpair_edge_it->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integerpair_edge_it->second) ); 
        }
     storageOf_node_index_pair_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_pair_to_edge_multimap);
     tempListCountnode_index_pair_to_edge_multimap = 0; 
     for (integerpair_edge_it = source->p_node_index_pair_to_edge_multimap.begin(); integerpair_edge_it != source->p_node_index_pair_to_edge_multimap.end(); ++integerpair_edge_it) 
        {
          integerpair_edge_it->second = tempListnode_index_pair_to_edge_multimap [ tempListCountnode_index_pair_to_edge_multimap ]; 
          tempListCountnode_index_pair_to_edge_multimap++; 
        }
      delete [] tempListnode_index_pair_to_edge_multimap; 
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_node_index_multimap = 0; 
     int* tempListstring_to_node_index_multimap = new int [ source->p_string_to_node_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_node_index_multimap[tempListCountstring_to_node_index_multimap] = string_integer_it->second;
          tempListCountstring_to_node_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_node_index_multimap.storeDataInEasyStorageClass(source->p_string_to_node_index_multimap);
     tempListCountstring_to_node_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_node_index_multimap.begin(); string_integer_it != source->p_string_to_node_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_node_index_multimap [ tempListCountstring_to_node_index_multimap ]; 
          tempListCountstring_to_node_index_multimap++; 
        }
      delete [] tempListstring_to_node_index_multimap; 
    }
   {
     rose_graph_string_integer_hash_multimap::iterator string_integer_it; 
     unsigned int tempListCountstring_to_edge_index_multimap = 0; 
     int* tempListstring_to_edge_index_multimap = new int [ source->p_string_to_edge_index_multimap.size() ]; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it)
        {
          tempListstring_to_edge_index_multimap[tempListCountstring_to_edge_index_multimap] = string_integer_it->second;
          tempListCountstring_to_edge_index_multimap++; 
          string_integer_it->second = 0; printf ("Unimplemented support for rose_graph_string_integer_hash_multimap: Fixme! \n"); ASSERT_require(false); 
        }
     storageOf_string_to_edge_index_multimap.storeDataInEasyStorageClass(source->p_string_to_edge_index_multimap);
     tempListCountstring_to_edge_index_multimap = 0; 
     for (string_integer_it = source->p_string_to_edge_index_multimap.begin(); string_integer_it != source->p_string_to_edge_index_multimap.end(); ++string_integer_it) 
        {
          string_integer_it->second = tempListstring_to_edge_index_multimap [ tempListCountstring_to_edge_index_multimap ]; 
          tempListCountstring_to_edge_index_multimap++; 
        }
      delete [] tempListstring_to_edge_index_multimap; 
    }
   {
     rose_graph_integer_edge_hash_multimap::iterator integer_edge_it2; 
     unsigned int tempListCountnode_index_to_edge_multimap = 0; 
     SgGraphEdge** tempListnode_index_to_edge_multimap = new SgGraphEdge* [ source->p_node_index_to_edge_multimap.size() ]; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2)
        {
          tempListnode_index_to_edge_multimap[tempListCountnode_index_to_edge_multimap] = integer_edge_it2->second;
          tempListCountnode_index_to_edge_multimap++; 
          integer_edge_it2->second = (SgGraphEdge*)(AST_FILE_IO::getGlobalIndexFromSgClassPointer(integer_edge_it2->second) ); 
        }
     storageOf_node_index_to_edge_multimap.storeDataInEasyStorageClass(source->p_node_index_to_edge_multimap);
     tempListCountnode_index_to_edge_multimap = 0; 
     for (integer_edge_it2 = source->p_node_index_to_edge_multimap.begin(); integer_edge_it2 != source->p_node_index_to_edge_multimap.end(); ++integer_edge_it2) 
        {
          integer_edge_it2->second = tempListnode_index_to_edge_multimap [ tempListCountnode_index_to_edge_multimap ]; 
          tempListCountnode_index_to_edge_multimap++; 
        }
      delete [] tempListnode_index_to_edge_multimap; 
    }
     storageOf_index =  source->p_index ;
     storageOf_boost_edges.storeDataInEasyStorageClass(source->p_boost_edges);
     storageOf_boost_edge_weights.storeDataInEasyStorageClass(source->p_boost_edge_weights);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIncidenceUndirectedGraphStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBoostEdgeWeightList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncidenceUndirectedGraphStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_node_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeList > :: deleteMemoryPool() ;
     EasyStorage < SgBoostEdgeWeightList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgIncidenceUndirectedGraphStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: writeToFile(out) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: writeToFile(out) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeList > :: writeToFile(out) ;
     EasyStorage < SgBoostEdgeWeightList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgIncidenceUndirectedGraphStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_node_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_map > :: readFromFile(in) ;
     EasyStorage < rose_graph_integerpair_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_string_integer_hash_multimap > :: readFromFile(in) ;
     EasyStorage < rose_graph_integer_edge_hash_multimap > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeList > :: readFromFile(in) ;
     EasyStorage < SgBoostEdgeWeightList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6072 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6085 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGraphNodeStorageClass::pickOutIRNodeData ( SgGraphNode* pointer ) 
   { 
     SgGraphNode* source = (SgGraphNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_SgNode = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_SgNode );
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgGraphNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6146 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6159 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGraphEdgeStorageClass::pickOutIRNodeData ( SgGraphEdge* pointer ) 
   { 
     SgGraphEdge* source = (SgGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6221 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDirectedGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6234 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDirectedGraphEdgeStorageClass::pickOutIRNodeData ( SgDirectedGraphEdge* pointer ) 
   { 
     SgDirectedGraphEdge* source = (SgDirectedGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDirectedGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDirectedGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgDirectedGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgDirectedGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6296 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUndirectedGraphEdgeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6309 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUndirectedGraphEdgeStorageClass::pickOutIRNodeData ( SgUndirectedGraphEdge* pointer ) 
   { 
     SgUndirectedGraphEdge* source = (SgUndirectedGraphEdge*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_node_A = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_A );
     storageOf_node_B = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_node_B );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_index =  source->p_index ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_properties.storeDataInEasyStorageClass(source->p_properties);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUndirectedGraphEdgeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<int, std::string> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUndirectedGraphEdgeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
     EasyStorage < std::map<int, std::string> > :: deleteMemoryPool() ;
   }

void
SgUndirectedGraphEdgeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
     EasyStorage < std::map<int, std::string> > :: writeToFile(out) ;
   }


void
SgUndirectedGraphEdgeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
     EasyStorage < std::map<int, std::string> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6371 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphNodeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6384 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGraphNodeListStorageClass::pickOutIRNodeData ( SgGraphNodeList* pointer ) 
   { 
     SgGraphNodeList* source = (SgGraphNodeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6406 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGraphEdgeListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6419 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGraphEdgeListStorageClass::pickOutIRNodeData ( SgGraphEdgeList* pointer ) 
   { 
     SgGraphEdgeList* source = (SgGraphEdgeList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6441 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6454 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeTableStorageClass::pickOutIRNodeData ( SgTypeTable* pointer ) 
   { 
     SgTypeTable* source = (SgTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6477 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNameGroupStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6490 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNameGroupStorageClass::pickOutIRNodeData ( SgNameGroup* pointer ) 
   { 
     SgNameGroup* source = (SgNameGroup*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_group_name.storeDataInEasyStorageClass(source->p_group_name);
     storageOf_name_list.storeDataInEasyStorageClass(source->p_name_list);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNameGroupStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNameGroupStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
   }

void
SgNameGroupStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
   }


void
SgNameGroupStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6544 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDimensionObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6557 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDimensionObjectStorageClass::pickOutIRNodeData ( SgDimensionObject* pointer ) 
   { 
     SgDimensionObject* source = (SgDimensionObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_array = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_array );
     storageOf_shape = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_shape );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6581 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6594 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFormatItemStorageClass::pickOutIRNodeData ( SgFormatItem* pointer ) 
   { 
     SgFormatItem* source = (SgFormatItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_repeat_specification =  source->p_repeat_specification ;
     storageOf_data = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_data );
     storageOf_format_item_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format_item_list );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6619 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatItemListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6632 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFormatItemListStorageClass::pickOutIRNodeData ( SgFormatItemList* pointer ) 
   { 
     SgFormatItemList* source = (SgFormatItemList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgFormatItemPtrList::iterator i_format_item_list = source->p_format_item_list.begin() ; 
     unsigned int tempListCountformat_item_list = 0; 
     SgFormatItemPtrList::value_type *  tempListformat_item_list = new SgFormatItemPtrList::value_type[ source->p_format_item_list.size() ]; 
     for ( ; i_format_item_list != source->p_format_item_list.end(); ++i_format_item_list ) 
        {
          tempListformat_item_list[tempListCountformat_item_list] = *i_format_item_list;
          tempListCountformat_item_list++; 
          (*i_format_item_list) = (SgFormatItemPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_format_item_list ) );
        }
     storageOf_format_item_list.storeDataInEasyStorageClass(source->p_format_item_list);
     tempListCountformat_item_list = 0; 
     i_format_item_list = source->p_format_item_list.begin() ; 
     for ( ; i_format_item_list != source->p_format_item_list.end(); ++i_format_item_list ) 
        {
          *i_format_item_list = tempListformat_item_list[tempListCountformat_item_list] ;
          tempListCountformat_item_list++; 
        }
      delete [] tempListformat_item_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFormatItemListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFormatItemPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFormatItemListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFormatItemPtrList > :: deleteMemoryPool() ;
   }

void
SgFormatItemListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFormatItemPtrList > :: writeToFile(out) ;
   }


void
SgFormatItemListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFormatItemPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6698 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementGroupStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6711 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementGroupStorageClass::pickOutIRNodeData ( SgDataStatementGroup* pointer ) 
   { 
     SgDataStatementGroup* source = (SgDataStatementGroup*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDataStatementObjectPtrList::iterator i_object_list = source->p_object_list.begin() ; 
     unsigned int tempListCountobject_list = 0; 
     SgDataStatementObjectPtrList::value_type *  tempListobject_list = new SgDataStatementObjectPtrList::value_type[ source->p_object_list.size() ]; 
     for ( ; i_object_list != source->p_object_list.end(); ++i_object_list ) 
        {
          tempListobject_list[tempListCountobject_list] = *i_object_list;
          tempListCountobject_list++; 
          (*i_object_list) = (SgDataStatementObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_object_list ) );
        }
     storageOf_object_list.storeDataInEasyStorageClass(source->p_object_list);
     tempListCountobject_list = 0; 
     i_object_list = source->p_object_list.begin() ; 
     for ( ; i_object_list != source->p_object_list.end(); ++i_object_list ) 
        {
          *i_object_list = tempListobject_list[tempListCountobject_list] ;
          tempListCountobject_list++; 
        }
      delete [] tempListobject_list; 
     SgDataStatementValuePtrList::iterator i_value_list = source->p_value_list.begin() ; 
     unsigned int tempListCountvalue_list = 0; 
     SgDataStatementValuePtrList::value_type *  tempListvalue_list = new SgDataStatementValuePtrList::value_type[ source->p_value_list.size() ]; 
     for ( ; i_value_list != source->p_value_list.end(); ++i_value_list ) 
        {
          tempListvalue_list[tempListCountvalue_list] = *i_value_list;
          tempListCountvalue_list++; 
          (*i_value_list) = (SgDataStatementValuePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_value_list ) );
        }
     storageOf_value_list.storeDataInEasyStorageClass(source->p_value_list);
     tempListCountvalue_list = 0; 
     i_value_list = source->p_value_list.begin() ; 
     for ( ; i_value_list != source->p_value_list.end(); ++i_value_list ) 
        {
          *i_value_list = tempListvalue_list[tempListCountvalue_list] ;
          tempListCountvalue_list++; 
        }
      delete [] tempListvalue_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDataStatementGroupStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDataStatementObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDataStatementValuePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDataStatementGroupStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDataStatementObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgDataStatementValuePtrList > :: deleteMemoryPool() ;
   }

void
SgDataStatementGroupStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDataStatementObjectPtrList > :: writeToFile(out) ;
     EasyStorage < SgDataStatementValuePtrList > :: writeToFile(out) ;
   }


void
SgDataStatementGroupStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDataStatementObjectPtrList > :: readFromFile(in) ;
     EasyStorage < SgDataStatementValuePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6799 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6812 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementObjectStorageClass::pickOutIRNodeData ( SgDataStatementObject* pointer ) 
   { 
     SgDataStatementObject* source = (SgDataStatementObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variableReference_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variableReference_list );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6835 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncludeFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6848 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIncludeFileStorageClass::pickOutIRNodeData ( SgIncludeFile* pointer ) 
   { 
     SgIncludeFile* source = (SgIncludeFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_filename.pickOutIRNodeData( &(source->p_filename) );
     storageOf_source_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_file );
     SgIncludeFilePtrList::iterator i_include_file_list = source->p_include_file_list.begin() ; 
     unsigned int tempListCountinclude_file_list = 0; 
     SgIncludeFilePtrList::value_type *  tempListinclude_file_list = new SgIncludeFilePtrList::value_type[ source->p_include_file_list.size() ]; 
     for ( ; i_include_file_list != source->p_include_file_list.end(); ++i_include_file_list ) 
        {
          tempListinclude_file_list[tempListCountinclude_file_list] = *i_include_file_list;
          tempListCountinclude_file_list++; 
          (*i_include_file_list) = (SgIncludeFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_include_file_list ) );
        }
     storageOf_include_file_list.storeDataInEasyStorageClass(source->p_include_file_list);
     tempListCountinclude_file_list = 0; 
     i_include_file_list = source->p_include_file_list.begin() ; 
     for ( ; i_include_file_list != source->p_include_file_list.end(); ++i_include_file_list ) 
        {
          *i_include_file_list = tempListinclude_file_list[tempListCountinclude_file_list] ;
          tempListCountinclude_file_list++; 
        }
      delete [] tempListinclude_file_list; 
     storageOf_first_source_sequence_number =  source->p_first_source_sequence_number ;
     storageOf_last_source_sequence_number =  source->p_last_source_sequence_number ;
     storageOf_isIncludedMoreThanOnce =  source->p_isIncludedMoreThanOnce ;
     storageOf_isPrimaryUse =  source->p_isPrimaryUse ;
     storageOf_file_hash.storeDataInEasyStorageClass(source->p_file_hash);
     storageOf_name_used_in_include_directive.pickOutIRNodeData( &(source->p_name_used_in_include_directive) );
     storageOf_source_file_of_translation_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_file_of_translation_unit );
     storageOf_including_source_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_including_source_file );
     storageOf_parent_include_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_include_file );
     storageOf_isSystemInclude =  source->p_isSystemInclude ;
     storageOf_isPreinclude =  source->p_isPreinclude ;
     storageOf_requires_explict_path_for_unparsed_headers =  source->p_requires_explict_path_for_unparsed_headers ;
     storageOf_can_be_supported_using_token_based_unparsing =  source->p_can_be_supported_using_token_based_unparsing ;
     storageOf_directory_prefix.pickOutIRNodeData( &(source->p_directory_prefix) );
     storageOf_name_without_path.pickOutIRNodeData( &(source->p_name_without_path) );
     storageOf_applicationRootDirectory.pickOutIRNodeData( &(source->p_applicationRootDirectory) );
     storageOf_will_be_unparsed =  source->p_will_be_unparsed ;
     storageOf_isRoseSystemInclude =  source->p_isRoseSystemInclude ;
     storageOf_from_system_include_dir =  source->p_from_system_include_dir ;
     storageOf_preinclude_macros_only =  source->p_preinclude_macros_only ;
     storageOf_isApplicationFile =  source->p_isApplicationFile ;
     storageOf_isRootSourceFile =  source->p_isRootSourceFile ;
     storageOf_firstStatement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstStatement );
     storageOf_lastStatement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lastStatement );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIncludeFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgIncludeFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncludeFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgIncludeFilePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgIncludeFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgIncludeFilePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgIncludeFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgIncludeFilePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6948 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDataStatementValueStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 6961 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDataStatementValueStorageClass::pickOutIRNodeData ( SgDataStatementValue* pointer ) 
   { 
     SgDataStatementValue* source = (SgDataStatementValue*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_data_initialization_format =  source->p_data_initialization_format ;
     storageOf_initializer_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializer_list );
     storageOf_repeat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_repeat_expression );
     storageOf_constant_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constant_expression );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 6987 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaImportStatementListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7000 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaImportStatementListStorageClass::pickOutIRNodeData ( SgJavaImportStatementList* pointer ) 
   { 
     SgJavaImportStatementList* source = (SgJavaImportStatementList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgJavaImportStatementPtrList::iterator i_java_import_list = source->p_java_import_list.begin() ; 
     unsigned int tempListCountjava_import_list = 0; 
     SgJavaImportStatementPtrList::value_type *  tempListjava_import_list = new SgJavaImportStatementPtrList::value_type[ source->p_java_import_list.size() ]; 
     for ( ; i_java_import_list != source->p_java_import_list.end(); ++i_java_import_list ) 
        {
          tempListjava_import_list[tempListCountjava_import_list] = *i_java_import_list;
          tempListCountjava_import_list++; 
          (*i_java_import_list) = (SgJavaImportStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_java_import_list ) );
        }
     storageOf_java_import_list.storeDataInEasyStorageClass(source->p_java_import_list);
     tempListCountjava_import_list = 0; 
     i_java_import_list = source->p_java_import_list.begin() ; 
     for ( ; i_java_import_list != source->p_java_import_list.end(); ++i_java_import_list ) 
        {
          *i_java_import_list = tempListjava_import_list[tempListCountjava_import_list] ;
          tempListCountjava_import_list++; 
        }
      delete [] tempListjava_import_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaImportStatementListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgJavaImportStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaImportStatementListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgJavaImportStatementPtrList > :: deleteMemoryPool() ;
   }

void
SgJavaImportStatementListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgJavaImportStatementPtrList > :: writeToFile(out) ;
   }


void
SgJavaImportStatementListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgJavaImportStatementPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7066 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaClassDeclarationListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7079 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaClassDeclarationListStorageClass::pickOutIRNodeData ( SgJavaClassDeclarationList* pointer ) 
   { 
     SgJavaClassDeclarationList* source = (SgJavaClassDeclarationList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgClassDeclarationPtrList::iterator i_java_class_list = source->p_java_class_list.begin() ; 
     unsigned int tempListCountjava_class_list = 0; 
     SgClassDeclarationPtrList::value_type *  tempListjava_class_list = new SgClassDeclarationPtrList::value_type[ source->p_java_class_list.size() ]; 
     for ( ; i_java_class_list != source->p_java_class_list.end(); ++i_java_class_list ) 
        {
          tempListjava_class_list[tempListCountjava_class_list] = *i_java_class_list;
          tempListCountjava_class_list++; 
          (*i_java_class_list) = (SgClassDeclarationPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_java_class_list ) );
        }
     storageOf_java_class_list.storeDataInEasyStorageClass(source->p_java_class_list);
     tempListCountjava_class_list = 0; 
     i_java_class_list = source->p_java_class_list.begin() ; 
     for ( ; i_java_class_list != source->p_java_class_list.end(); ++i_java_class_list ) 
        {
          *i_java_class_list = tempListjava_class_list[tempListCountjava_class_list] ;
          tempListCountjava_class_list++; 
        }
      delete [] tempListjava_class_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaClassDeclarationListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgClassDeclarationPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaClassDeclarationListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgClassDeclarationPtrList > :: deleteMemoryPool() ;
   }

void
SgJavaClassDeclarationListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgClassDeclarationPtrList > :: writeToFile(out) ;
   }


void
SgJavaClassDeclarationListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgClassDeclarationPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7145 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgHeaderFileReportStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7158 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgHeaderFileReportStorageClass::pickOutIRNodeData ( SgHeaderFileReport* pointer ) 
   { 
     SgHeaderFileReport* source = (SgHeaderFileReport*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_source_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_file );
     SgSourceFilePtrList::iterator i_include_file_list = source->p_include_file_list.begin() ; 
     unsigned int tempListCountinclude_file_list = 0; 
     SgSourceFilePtrList::value_type *  tempListinclude_file_list = new SgSourceFilePtrList::value_type[ source->p_include_file_list.size() ]; 
     for ( ; i_include_file_list != source->p_include_file_list.end(); ++i_include_file_list ) 
        {
          tempListinclude_file_list[tempListCountinclude_file_list] = *i_include_file_list;
          tempListCountinclude_file_list++; 
          (*i_include_file_list) = (SgSourceFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_include_file_list ) );
        }
     storageOf_include_file_list.storeDataInEasyStorageClass(source->p_include_file_list);
     tempListCountinclude_file_list = 0; 
     i_include_file_list = source->p_include_file_list.begin() ; 
     for ( ; i_include_file_list != source->p_include_file_list.end(); ++i_include_file_list ) 
        {
          *i_include_file_list = tempListinclude_file_list[tempListCountinclude_file_list] ;
          tempListCountinclude_file_list++; 
        }
      delete [] tempListinclude_file_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgHeaderFileReportStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgSourceFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgHeaderFileReportStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgSourceFilePtrList > :: deleteMemoryPool() ;
   }

void
SgHeaderFileReportStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgSourceFilePtrList > :: writeToFile(out) ;
   }


void
SgHeaderFileReportStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgSourceFilePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7225 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7238 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeStorageClass::pickOutIRNodeData ( SgType* pointer ) 
   { 
     SgType* source = (SgType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7298 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnknownStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7311 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnknownStorageClass::pickOutIRNodeData ( SgTypeUnknown* pointer ) 
   { 
     SgTypeUnknown* source = (SgTypeUnknown*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type_name.storeDataInEasyStorageClass(source->p_type_name);
     storageOf_has_type_name =  source->p_has_type_name ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeUnknownStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnknownStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnknownStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnknownStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7377 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7390 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCharStorageClass::pickOutIRNodeData ( SgTypeChar* pointer ) 
   { 
     SgTypeChar* source = (SgTypeChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7450 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7463 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedCharStorageClass::pickOutIRNodeData ( SgTypeSignedChar* pointer ) 
   { 
     SgTypeSignedChar* source = (SgTypeSignedChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeSignedCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7523 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedCharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7536 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedCharStorageClass::pickOutIRNodeData ( SgTypeUnsignedChar* pointer ) 
   { 
     SgTypeUnsignedChar* source = (SgTypeUnsignedChar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeUnsignedCharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedCharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedCharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedCharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7596 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7609 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeShortStorageClass::pickOutIRNodeData ( SgTypeShort* pointer ) 
   { 
     SgTypeShort* source = (SgTypeShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7669 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7682 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedShortStorageClass::pickOutIRNodeData ( SgTypeSignedShort* pointer ) 
   { 
     SgTypeSignedShort* source = (SgTypeSignedShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeSignedShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7742 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedShortStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7755 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedShortStorageClass::pickOutIRNodeData ( SgTypeUnsignedShort* pointer ) 
   { 
     SgTypeUnsignedShort* source = (SgTypeUnsignedShort*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeUnsignedShortStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedShortStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedShortStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedShortStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7815 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7828 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeIntStorageClass::pickOutIRNodeData ( SgTypeInt* pointer ) 
   { 
     SgTypeInt* source = (SgTypeInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_field_size =  source->p_field_size ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7889 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7902 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedIntStorageClass::pickOutIRNodeData ( SgTypeSignedInt* pointer ) 
   { 
     SgTypeSignedInt* source = (SgTypeSignedInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeSignedIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 7962 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedIntStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 7975 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedIntStorageClass::pickOutIRNodeData ( SgTypeUnsignedInt* pointer ) 
   { 
     SgTypeUnsignedInt* source = (SgTypeUnsignedInt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeUnsignedIntStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedIntStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedIntStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedIntStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8035 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8048 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongStorageClass::pickOutIRNodeData ( SgTypeLong* pointer ) 
   { 
     SgTypeLong* source = (SgTypeLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8108 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8121 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedLongStorageClass::pickOutIRNodeData ( SgTypeSignedLong* pointer ) 
   { 
     SgTypeSignedLong* source = (SgTypeSignedLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeSignedLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8181 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8194 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedLongStorageClass::pickOutIRNodeData ( SgTypeUnsignedLong* pointer ) 
   { 
     SgTypeUnsignedLong* source = (SgTypeUnsignedLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeUnsignedLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8254 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeVoidStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8267 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeVoidStorageClass::pickOutIRNodeData ( SgTypeVoid* pointer ) 
   { 
     SgTypeVoid* source = (SgTypeVoid*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeVoidStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeVoidStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeVoidStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeVoidStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8327 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeGlobalVoidStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8340 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeGlobalVoidStorageClass::pickOutIRNodeData ( SgTypeGlobalVoid* pointer ) 
   { 
     SgTypeGlobalVoid* source = (SgTypeGlobalVoid*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeGlobalVoidStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeGlobalVoidStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeGlobalVoidStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeGlobalVoidStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8400 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeWcharStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8413 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeWcharStorageClass::pickOutIRNodeData ( SgTypeWchar* pointer ) 
   { 
     SgTypeWchar* source = (SgTypeWchar*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeWcharStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeWcharStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeWcharStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeWcharStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8473 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeFloatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8486 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeFloatStorageClass::pickOutIRNodeData ( SgTypeFloat* pointer ) 
   { 
     SgTypeFloat* source = (SgTypeFloat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeFloatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeFloatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeFloatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeFloatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8546 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeDoubleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8559 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeDoubleStorageClass::pickOutIRNodeData ( SgTypeDouble* pointer ) 
   { 
     SgTypeDouble* source = (SgTypeDouble*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeDoubleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeDoubleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeDoubleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeDoubleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8619 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8632 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongLongStorageClass::pickOutIRNodeData ( SgTypeLongLong* pointer ) 
   { 
     SgTypeLongLong* source = (SgTypeLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8692 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSignedLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8705 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSignedLongLongStorageClass::pickOutIRNodeData ( SgTypeSignedLongLong* pointer ) 
   { 
     SgTypeSignedLongLong* source = (SgTypeSignedLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeSignedLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSignedLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSignedLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSignedLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8765 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsignedLongLongStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8778 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsignedLongLongStorageClass::pickOutIRNodeData ( SgTypeUnsignedLongLong* pointer ) 
   { 
     SgTypeUnsignedLongLong* source = (SgTypeUnsignedLongLong*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeUnsignedLongLongStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsignedLongLongStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsignedLongLongStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsignedLongLongStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8838 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSigned128bitIntegerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8851 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSigned128bitIntegerStorageClass::pickOutIRNodeData ( SgTypeSigned128bitInteger* pointer ) 
   { 
     SgTypeSigned128bitInteger* source = (SgTypeSigned128bitInteger*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeSigned128bitIntegerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSigned128bitIntegerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSigned128bitIntegerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSigned128bitIntegerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8911 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeUnsigned128bitIntegerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8924 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeUnsigned128bitIntegerStorageClass::pickOutIRNodeData ( SgTypeUnsigned128bitInteger* pointer ) 
   { 
     SgTypeUnsigned128bitInteger* source = (SgTypeUnsigned128bitInteger*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeUnsigned128bitIntegerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeUnsigned128bitIntegerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeUnsigned128bitIntegerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeUnsigned128bitIntegerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 8984 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeFloat80StorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 8997 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeFloat80StorageClass::pickOutIRNodeData ( SgTypeFloat80* pointer ) 
   { 
     SgTypeFloat80* source = (SgTypeFloat80*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeFloat80StorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeFloat80StorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeFloat80StorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeFloat80StorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9057 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLongDoubleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9070 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLongDoubleStorageClass::pickOutIRNodeData ( SgTypeLongDouble* pointer ) 
   { 
     SgTypeLongDouble* source = (SgTypeLongDouble*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeLongDoubleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLongDoubleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLongDoubleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLongDoubleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9130 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9143 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeStringStorageClass::pickOutIRNodeData ( SgTypeString* pointer ) 
   { 
     SgTypeString* source = (SgTypeString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lengthExpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lengthExpression );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9204 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeBoolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9217 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeBoolStorageClass::pickOutIRNodeData ( SgTypeBool* pointer ) 
   { 
     SgTypeBool* source = (SgTypeBool*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeBoolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeBoolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeBoolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeBoolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9277 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9290 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPointerTypeStorageClass::pickOutIRNodeData ( SgPointerType* pointer ) 
   { 
     SgPointerType* source = (SgPointerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPointerTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9351 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerMemberTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9364 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPointerMemberTypeStorageClass::pickOutIRNodeData ( SgPointerMemberType* pointer ) 
   { 
     SgPointerMemberType* source = (SgPointerMemberType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPointerMemberTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerMemberTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerMemberTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerMemberTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9426 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReferenceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9439 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgReferenceTypeStorageClass::pickOutIRNodeData ( SgReferenceType* pointer ) 
   { 
     SgReferenceType* source = (SgReferenceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgReferenceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReferenceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReferenceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReferenceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9500 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9513 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNamedTypeStorageClass::pickOutIRNodeData ( SgNamedType* pointer ) 
   { 
     SgNamedType* source = (SgNamedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNamedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9576 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9589 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClassTypeStorageClass::pickOutIRNodeData ( SgClassType* pointer ) 
   { 
     SgClassType* source = (SgClassType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_packed =  source->p_packed ;
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClassTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9653 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaParameterTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9666 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaParameterTypeStorageClass::pickOutIRNodeData ( SgJavaParameterType* pointer ) 
   { 
     SgJavaParameterType* source = (SgJavaParameterType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_packed =  source->p_packed ;
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaParameterTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaParameterTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaParameterTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaParameterTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9730 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialTableTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9743 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialTableTypeStorageClass::pickOutIRNodeData ( SgJovialTableType* pointer ) 
   { 
     SgJovialTableType* source = (SgJovialTableType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_dim_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dim_info );
     storageOf_rank =  source->p_rank ;
     storageOf_structure_specifier =  source->p_structure_specifier ;
     storageOf_bits_per_entry =  source->p_bits_per_entry ;
     storageOf_packed =  source->p_packed ;
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialTableTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialTableTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialTableTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialTableTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9812 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9825 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEnumTypeStorageClass::pickOutIRNodeData ( SgEnumType* pointer ) 
   { 
     SgEnumType* source = (SgEnumType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEnumTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9888 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9901 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefTypeStorageClass::pickOutIRNodeData ( SgTypedefType* pointer ) 
   { 
     SgTypedefType* source = (SgTypedefType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypedefTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 9965 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNonrealTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 9978 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNonrealTypeStorageClass::pickOutIRNodeData ( SgNonrealType* pointer ) 
   { 
     SgNonrealType* source = (SgNonrealType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNonrealTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNonrealTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNonrealTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNonrealTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10041 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaParameterizedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10054 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaParameterizedTypeStorageClass::pickOutIRNodeData ( SgJavaParameterizedType* pointer ) 
   { 
     SgJavaParameterizedType* source = (SgJavaParameterizedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_raw_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_raw_type );
     storageOf_type_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_list );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaParameterizedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaParameterizedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaParameterizedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaParameterizedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10119 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaQualifiedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10132 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaQualifiedTypeStorageClass::pickOutIRNodeData ( SgJavaQualifiedType* pointer ) 
   { 
     SgJavaQualifiedType* source = (SgJavaQualifiedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_type );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaQualifiedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaQualifiedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaQualifiedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaQualifiedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10197 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaWildcardTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10210 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaWildcardTypeStorageClass::pickOutIRNodeData ( SgJavaWildcardType* pointer ) 
   { 
     SgJavaWildcardType* source = (SgJavaWildcardType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bound_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound_type );
     storageOf_is_unbound =  source->p_is_unbound ;
     storageOf_has_extends =  source->p_has_extends ;
     storageOf_has_super =  source->p_has_super ;
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaWildcardTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaWildcardTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaWildcardTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaWildcardTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10277 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10290 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskTypeStorageClass::pickOutIRNodeData ( SgAdaTaskType* pointer ) 
   { 
     SgAdaTaskType* source = (SgAdaTaskType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10353 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10366 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedTypeStorageClass::pickOutIRNodeData ( SgAdaProtectedType* pointer ) 
   { 
     SgAdaProtectedType* source = (SgAdaProtectedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10429 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaFormalTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10442 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaFormalTypeStorageClass::pickOutIRNodeData ( SgAdaFormalType* pointer ) 
   { 
     SgAdaFormalType* source = (SgAdaFormalType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_is_private =  source->p_is_private ;
     storageOf_formal_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_formal_type );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaFormalTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaFormalTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaFormalTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaFormalTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10507 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDiscriminatedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10520 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDiscriminatedTypeStorageClass::pickOutIRNodeData ( SgAdaDiscriminatedType* pointer ) 
   { 
     SgAdaDiscriminatedType* source = (SgAdaDiscriminatedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDiscriminatedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDiscriminatedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDiscriminatedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDiscriminatedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10583 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10596 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgScopedTypeStorageClass::pickOutIRNodeData ( SgScopedType* pointer ) 
   { 
     SgScopedType* source = (SgScopedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_autonomous_declaration =  source->p_autonomous_declaration ;
     storageOf_is_from_template_parameter =  source->p_is_from_template_parameter ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgScopedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10659 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModifierTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10672 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgModifierTypeStorageClass::pickOutIRNodeData ( SgModifierType* pointer ) 
   { 
     SgModifierType* source = (SgModifierType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_typeModifier.pickOutIRNodeData( &(source->p_typeModifier) );
     storageOf_frontend_type_reference.storeDataInEasyStorageClass(source->p_frontend_type_reference);
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgModifierTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgTypeModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < char* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModifierTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgTypeModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < char* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModifierTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgTypeModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < char* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModifierTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgTypeModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < char* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10743 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10756 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeStorageClass::pickOutIRNodeData ( SgFunctionType* pointer ) 
   { 
     SgFunctionType* source = (SgFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10820 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10833 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionTypeStorageClass::pickOutIRNodeData ( SgMemberFunctionType* pointer ) 
   { 
     SgMemberFunctionType* source = (SgMemberFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMemberFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10899 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPartialFunctionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10912 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPartialFunctionTypeStorageClass::pickOutIRNodeData ( SgPartialFunctionType* pointer ) 
   { 
     SgPartialFunctionType* source = (SgPartialFunctionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPartialFunctionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPartialFunctionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPartialFunctionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPartialFunctionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 10978 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPartialFunctionModifierTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 10991 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPartialFunctionModifierTypeStorageClass::pickOutIRNodeData ( SgPartialFunctionModifierType* pointer ) 
   { 
     SgPartialFunctionModifierType* source = (SgPartialFunctionModifierType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_mfunc_specifier =  source->p_mfunc_specifier ;
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_has_ellipses =  source->p_has_ellipses ;
     storageOf_orig_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_orig_return_type );
     storageOf_argument_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_argument_list );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPartialFunctionModifierTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPartialFunctionModifierTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPartialFunctionModifierTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPartialFunctionModifierTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11057 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrayTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11070 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgArrayTypeStorageClass::pickOutIRNodeData ( SgArrayType* pointer ) 
   { 
     SgArrayType* source = (SgArrayType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_index );
     storageOf_dim_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dim_info );
     storageOf_rank =  source->p_rank ;
     storageOf_number_of_elements =  source->p_number_of_elements ;
     storageOf_is_variable_length_array =  source->p_is_variable_length_array ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgArrayTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrayTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrayTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrayTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11136 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeEllipseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11149 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeEllipseStorageClass::pickOutIRNodeData ( SgTypeEllipse* pointer ) 
   { 
     SgTypeEllipse* source = (SgTypeEllipse*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeEllipseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeEllipseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeEllipseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeEllipseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11209 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11222 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateTypeStorageClass::pickOutIRNodeData ( SgTemplateType* pointer ) 
   { 
     SgTemplateType* source = (SgTemplateType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_template_parameter_position =  source->p_template_parameter_position ;
     storageOf_template_parameter_depth =  source->p_template_parameter_depth ;
     storageOf_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_type );
     storageOf_parent_class_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_class_type );
     storageOf_template_parameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_template_parameter );
     SgTemplateArgumentPtrList::iterator i_tpl_args = source->p_tpl_args.begin() ; 
     unsigned int tempListCounttpl_args = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtpl_args = new SgTemplateArgumentPtrList::value_type[ source->p_tpl_args.size() ]; 
     for ( ; i_tpl_args != source->p_tpl_args.end(); ++i_tpl_args ) 
        {
          tempListtpl_args[tempListCounttpl_args] = *i_tpl_args;
          tempListCounttpl_args++; 
          (*i_tpl_args) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_tpl_args ) );
        }
     storageOf_tpl_args.storeDataInEasyStorageClass(source->p_tpl_args);
     tempListCounttpl_args = 0; 
     i_tpl_args = source->p_tpl_args.begin() ; 
     for ( ; i_tpl_args != source->p_tpl_args.end(); ++i_tpl_args ) 
        {
          *i_tpl_args = tempListtpl_args[tempListCounttpl_args] ;
          tempListCounttpl_args++; 
        }
      delete [] tempListtpl_args; 
     SgTemplateArgumentPtrList::iterator i_part_spec_tpl_args = source->p_part_spec_tpl_args.begin() ; 
     unsigned int tempListCountpart_spec_tpl_args = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListpart_spec_tpl_args = new SgTemplateArgumentPtrList::value_type[ source->p_part_spec_tpl_args.size() ]; 
     for ( ; i_part_spec_tpl_args != source->p_part_spec_tpl_args.end(); ++i_part_spec_tpl_args ) 
        {
          tempListpart_spec_tpl_args[tempListCountpart_spec_tpl_args] = *i_part_spec_tpl_args;
          tempListCountpart_spec_tpl_args++; 
          (*i_part_spec_tpl_args) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_part_spec_tpl_args ) );
        }
     storageOf_part_spec_tpl_args.storeDataInEasyStorageClass(source->p_part_spec_tpl_args);
     tempListCountpart_spec_tpl_args = 0; 
     i_part_spec_tpl_args = source->p_part_spec_tpl_args.begin() ; 
     for ( ; i_part_spec_tpl_args != source->p_part_spec_tpl_args.end(); ++i_part_spec_tpl_args ) 
        {
          *i_part_spec_tpl_args = tempListpart_spec_tpl_args[tempListCountpart_spec_tpl_args] ;
          tempListCountpart_spec_tpl_args++; 
        }
      delete [] tempListpart_spec_tpl_args; 
     storageOf_packed =  source->p_packed ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11333 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgQualifiedNameTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11346 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgQualifiedNameTypeStorageClass::pickOutIRNodeData ( SgQualifiedNameType* pointer ) 
   { 
     SgQualifiedNameType* source = (SgQualifiedNameType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgQualifiedNameTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgQualifiedNameTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgQualifiedNameTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgQualifiedNameTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11429 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeComplexStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11442 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeComplexStorageClass::pickOutIRNodeData ( SgTypeComplex* pointer ) 
   { 
     SgTypeComplex* source = (SgTypeComplex*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeComplexStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeComplexStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeComplexStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeComplexStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11503 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeImaginaryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11516 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeImaginaryStorageClass::pickOutIRNodeData ( SgTypeImaginary* pointer ) 
   { 
     SgTypeImaginary* source = (SgTypeImaginary*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeImaginaryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeImaginaryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeImaginaryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeImaginaryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11577 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeDefaultStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11590 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeDefaultStorageClass::pickOutIRNodeData ( SgTypeDefault* pointer ) 
   { 
     SgTypeDefault* source = (SgTypeDefault*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeDefaultStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeDefaultStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeDefaultStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeDefaultStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11655 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCAFTeamStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11668 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCAFTeamStorageClass::pickOutIRNodeData ( SgTypeCAFTeam* pointer ) 
   { 
     SgTypeCAFTeam* source = (SgTypeCAFTeam*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeCAFTeamStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCAFTeamStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCAFTeamStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCAFTeamStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11728 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeCrayPointerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11741 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeCrayPointerStorageClass::pickOutIRNodeData ( SgTypeCrayPointer* pointer ) 
   { 
     SgTypeCrayPointer* source = (SgTypeCrayPointer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeCrayPointerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeCrayPointerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeCrayPointerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeCrayPointerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11801 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11814 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeLabelStorageClass::pickOutIRNodeData ( SgTypeLabel* pointer ) 
   { 
     SgTypeLabel* source = (SgTypeLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11879 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaUnionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11892 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaUnionTypeStorageClass::pickOutIRNodeData ( SgJavaUnionType* pointer ) 
   { 
     SgJavaUnionType* source = (SgJavaUnionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTypePtrList::iterator i_type_list = source->p_type_list.begin() ; 
     unsigned int tempListCounttype_list = 0; 
     SgTypePtrList::value_type *  tempListtype_list = new SgTypePtrList::value_type[ source->p_type_list.size() ]; 
     for ( ; i_type_list != source->p_type_list.end(); ++i_type_list ) 
        {
          tempListtype_list[tempListCounttype_list] = *i_type_list;
          tempListCounttype_list++; 
          (*i_type_list) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_type_list ) );
        }
     storageOf_type_list.storeDataInEasyStorageClass(source->p_type_list);
     tempListCounttype_list = 0; 
     i_type_list = source->p_type_list.begin() ; 
     for ( ; i_type_list != source->p_type_list.end(); ++i_type_list ) 
        {
          *i_type_list = tempListtype_list[tempListCounttype_list] ;
          tempListCounttype_list++; 
        }
      delete [] tempListtype_list; 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaUnionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaUnionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaUnionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaUnionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 11974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRvalueReferenceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 11987 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRvalueReferenceTypeStorageClass::pickOutIRNodeData ( SgRvalueReferenceType* pointer ) 
   { 
     SgRvalueReferenceType* source = (SgRvalueReferenceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRvalueReferenceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRvalueReferenceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRvalueReferenceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRvalueReferenceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12048 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeNullptrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12061 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeNullptrStorageClass::pickOutIRNodeData ( SgTypeNullptr* pointer ) 
   { 
     SgTypeNullptr* source = (SgTypeNullptr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeNullptrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeNullptrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeNullptrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeNullptrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12121 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12134 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDeclTypeStorageClass::pickOutIRNodeData ( SgDeclType* pointer ) 
   { 
     SgDeclType* source = (SgDeclType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_expression );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDeclTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeclTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeclTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12196 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeOfTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12209 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeOfTypeStorageClass::pickOutIRNodeData ( SgTypeOfType* pointer ) 
   { 
     SgTypeOfType* source = (SgTypeOfType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_expression );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeOfTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeOfTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeOfTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeOfTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12271 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeMatrixStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12284 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeMatrixStorageClass::pickOutIRNodeData ( SgTypeMatrix* pointer ) 
   { 
     SgTypeMatrix* source = (SgTypeMatrix*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeMatrixStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeMatrixStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeMatrixStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeMatrixStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12345 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeTupleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12358 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeTupleStorageClass::pickOutIRNodeData ( SgTypeTuple* pointer ) 
   { 
     SgTypeTuple* source = (SgTypeTuple*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTypePtrList::iterator i_types = source->p_types.begin() ; 
     unsigned int tempListCounttypes = 0; 
     SgTypePtrList::value_type *  tempListtypes = new SgTypePtrList::value_type[ source->p_types.size() ]; 
     for ( ; i_types != source->p_types.end(); ++i_types ) 
        {
          tempListtypes[tempListCounttypes] = *i_types;
          tempListCounttypes++; 
          (*i_types) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_types ) );
        }
     storageOf_types.storeDataInEasyStorageClass(source->p_types);
     tempListCounttypes = 0; 
     i_types = source->p_types.begin() ; 
     for ( ; i_types != source->p_types.end(); ++i_types ) 
        {
          *i_types = tempListtypes[tempListCounttypes] ;
          tempListCounttypes++; 
        }
      delete [] tempListtypes; 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeTupleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeTupleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeTupleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeTupleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12440 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeChar16StorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12453 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeChar16StorageClass::pickOutIRNodeData ( SgTypeChar16* pointer ) 
   { 
     SgTypeChar16* source = (SgTypeChar16*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeChar16StorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeChar16StorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeChar16StorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeChar16StorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12513 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeChar32StorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12526 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeChar32StorageClass::pickOutIRNodeData ( SgTypeChar32* pointer ) 
   { 
     SgTypeChar32* source = (SgTypeChar32*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeChar32StorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeChar32StorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeChar32StorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeChar32StorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12586 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeFloat128StorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12599 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeFloat128StorageClass::pickOutIRNodeData ( SgTypeFloat128* pointer ) 
   { 
     SgTypeFloat128* source = (SgTypeFloat128*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeFloat128StorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeFloat128StorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeFloat128StorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeFloat128StorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12659 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeFixedStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12672 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeFixedStorageClass::pickOutIRNodeData ( SgTypeFixed* pointer ) 
   { 
     SgTypeFixed* source = (SgTypeFixed*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_scale = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scale );
     storageOf_fraction = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fraction );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeFixedStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeFixedStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeFixedStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeFixedStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12734 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAutoTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12747 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAutoTypeStorageClass::pickOutIRNodeData ( SgAutoType* pointer ) 
   { 
     SgAutoType* source = (SgAutoType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAutoTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAutoTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAutoTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAutoTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12807 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaAccessTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12820 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaAccessTypeStorageClass::pickOutIRNodeData ( SgAdaAccessType* pointer ) 
   { 
     SgAdaAccessType* source = (SgAdaAccessType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_is_general_access =  source->p_is_general_access ;
     storageOf_is_anonymous =  source->p_is_anonymous ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaAccessTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaAccessTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaAccessTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaAccessTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12883 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaSubtypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12896 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaSubtypeStorageClass::pickOutIRNodeData ( SgAdaSubtype* pointer ) 
   { 
     SgAdaSubtype* source = (SgAdaSubtype*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_constraint = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constraint );
     storageOf_fromRootType =  source->p_fromRootType ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaSubtypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaSubtypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaSubtypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaSubtypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 12959 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDiscreteTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 12972 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDiscreteTypeStorageClass::pickOutIRNodeData ( SgAdaDiscreteType* pointer ) 
   { 
     SgAdaDiscreteType* source = (SgAdaDiscreteType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDiscreteTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDiscreteTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDiscreteTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDiscreteTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13032 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaModularTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13045 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaModularTypeStorageClass::pickOutIRNodeData ( SgAdaModularType* pointer ) 
   { 
     SgAdaModularType* source = (SgAdaModularType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_modexpr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modexpr );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaModularTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaModularTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaModularTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaModularTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13106 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDerivedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13119 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDerivedTypeStorageClass::pickOutIRNodeData ( SgAdaDerivedType* pointer ) 
   { 
     SgAdaDerivedType* source = (SgAdaDerivedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDerivedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDerivedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDerivedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDerivedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13180 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaSubroutineTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13193 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaSubroutineTypeStorageClass::pickOutIRNodeData ( SgAdaSubroutineType* pointer ) 
   { 
     SgAdaSubroutineType* source = (SgAdaSubroutineType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_return_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_return_type );
     storageOf_is_protected =  source->p_is_protected ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaSubroutineTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaSubroutineTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaSubroutineTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaSubroutineTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13257 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialBitTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13270 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialBitTypeStorageClass::pickOutIRNodeData ( SgJovialBitType* pointer ) 
   { 
     SgJovialBitType* source = (SgJovialBitType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialBitTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialBitTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialBitTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialBitTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13331 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRangeTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13344 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRangeTypeStorageClass::pickOutIRNodeData ( SgRangeType* pointer ) 
   { 
     SgRangeType* source = (SgRangeType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_substitutedForTemplateParam =  source->p_substitutedForTemplateParam ;
     storageOf_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ref_to );
     storageOf_ptr_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ptr_to );
     storageOf_modifiers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_modifiers );
     storageOf_typedefs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typedefs );
     storageOf_rvalue_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvalue_ref_to );
     storageOf_decltype_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decltype_ref_to );
     storageOf_typeof_ref_to = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeof_ref_to );
     storageOf_type_kind = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_kind );
     storageOf_hasTypeKindStar =  source->p_hasTypeKindStar ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRangeTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRangeTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRangeTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRangeTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13405 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLocatedNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13418 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLocatedNodeStorageClass::pickOutIRNodeData ( SgLocatedNode* pointer ) 
   { 
     SgLocatedNode* source = (SgLocatedNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLocatedNodeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLocatedNodeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLocatedNodeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLocatedNodeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13475 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTokenStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13488 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTokenStorageClass::pickOutIRNodeData ( SgToken* pointer ) 
   { 
     SgToken* source = (SgToken*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lexeme_string.storeDataInEasyStorageClass(source->p_lexeme_string);
     storageOf_classification_code =  source->p_classification_code ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTokenStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTokenStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTokenStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTokenStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13551 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLocatedNodeSupportStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13564 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLocatedNodeSupportStorageClass::pickOutIRNodeData ( SgLocatedNodeSupport* pointer ) 
   { 
     SgLocatedNodeSupport* source = (SgLocatedNodeSupport*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLocatedNodeSupportStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLocatedNodeSupportStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLocatedNodeSupportStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLocatedNodeSupportStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13621 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonBlockObjectStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13634 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCommonBlockObjectStorageClass::pickOutIRNodeData ( SgCommonBlockObject* pointer ) 
   { 
     SgCommonBlockObject* source = (SgCommonBlockObject*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_block_name.storeDataInEasyStorageClass(source->p_block_name);
     storageOf_variable_reference_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable_reference_list );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCommonBlockObjectStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonBlockObjectStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonBlockObjectStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonBlockObjectStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13697 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInitializedNameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13710 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgInitializedNameStorageClass::pickOutIRNodeData ( SgInitializedName* pointer ) 
   { 
     SgInitializedName* source = (SgInitializedName*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_microsoft_uuid_string.storeDataInEasyStorageClass(source->p_microsoft_uuid_string);
     storageOf_typeptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_typeptr );
     storageOf_initptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initptr );
     storageOf_prev_decl_item = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_prev_decl_item );
     storageOf_is_initializer =  source->p_is_initializer ;
     storageOf_declptr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declptr );
     storageOf_storageModifier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_storageModifier );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_preinitialization =  source->p_preinitialization ;
     storageOf_isCoArray =  source->p_isCoArray ;
     storageOf_register_name_code =  source->p_register_name_code ;
     storageOf_excess_specifier =  source->p_excess_specifier ;
     storageOf_register_name_string.storeDataInEasyStorageClass(source->p_register_name_string);
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_shapeDeferred =  source->p_shapeDeferred ;
     storageOf_initializationDeferred =  source->p_initializationDeferred ;
     storageOf_gnu_attribute_modifierVector.storeDataInEasyStorageClass(source->p_gnu_attribute_modifierVector);
     storageOf_gnu_attribute_initialization_priority =  source->p_gnu_attribute_initialization_priority ;
     storageOf_gnu_attribute_named_weak_reference.storeDataInEasyStorageClass(source->p_gnu_attribute_named_weak_reference);
     storageOf_gnu_attribute_named_alias.storeDataInEasyStorageClass(source->p_gnu_attribute_named_alias);
     storageOf_gnu_attribute_cleanup_function.storeDataInEasyStorageClass(source->p_gnu_attribute_cleanup_function);
     storageOf_gnu_attribute_section_name.storeDataInEasyStorageClass(source->p_gnu_attribute_section_name);
     storageOf_gnu_attribute_alignment =  source->p_gnu_attribute_alignment ;
     storageOf_gnu_attribute_visability =  source->p_gnu_attribute_visability ;
     storageOf_protected_declaration =  source->p_protected_declaration ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_type =  source->p_name_qualification_length_for_type ;
     storageOf_type_elaboration_required_for_type =  source->p_type_elaboration_required_for_type ;
     storageOf_global_qualification_required_for_type =  source->p_global_qualification_required_for_type ;
     storageOf_hasArrayTypeWithEmptyBracketSyntax =  source->p_hasArrayTypeWithEmptyBracketSyntax ;
     storageOf_using_C11_Alignas_keyword =  source->p_using_C11_Alignas_keyword ;
     storageOf_constant_or_type_argument_for_Alignas_keyword = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constant_or_type_argument_for_Alignas_keyword );
     storageOf_using_auto_keyword =  source->p_using_auto_keyword ;
     storageOf_auto_decltype = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_auto_decltype );
     storageOf_using_device_keyword =  source->p_using_device_keyword ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_using_assignment_copy_constructor_syntax =  source->p_using_assignment_copy_constructor_syntax ;
     storageOf_needs_definitions =  source->p_needs_definitions ;
     storageOf_is_parameter_pack =  source->p_is_parameter_pack ;
     storageOf_is_pack_element =  source->p_is_pack_element ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgInitializedNameStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInitializedNameStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgBitVector > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInitializedNameStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgBitVector > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInitializedNameStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgBitVector > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13822 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13835 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceBodyStorageClass::pickOutIRNodeData ( SgInterfaceBody* pointer ) 
   { 
     SgInterfaceBody* source = (SgInterfaceBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_function_name.pickOutIRNodeData( &(source->p_function_name) );
     storageOf_functionDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionDeclaration );
     storageOf_use_function_name =  source->p_use_function_name ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgInterfaceBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13899 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgHeaderFileBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13912 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgHeaderFileBodyStorageClass::pickOutIRNodeData ( SgHeaderFileBody* pointer ) 
   { 
     SgHeaderFileBody* source = (SgHeaderFileBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_include_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_include_file );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgHeaderFileBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgHeaderFileBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgHeaderFileBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgHeaderFileBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 13970 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRenamePairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 13983 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRenamePairStorageClass::pickOutIRNodeData ( SgRenamePair* pointer ) 
   { 
     SgRenamePair* source = (SgRenamePair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_local_name.pickOutIRNodeData( &(source->p_local_name) );
     storageOf_use_name.pickOutIRNodeData( &(source->p_use_name) );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRenamePairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRenamePairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRenamePairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRenamePairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14046 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaMemberValuePairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14059 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaMemberValuePairStorageClass::pickOutIRNodeData ( SgJavaMemberValuePair* pointer ) 
   { 
     SgJavaMemberValuePair* source = (SgJavaMemberValuePair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaMemberValuePairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaMemberValuePairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaMemberValuePairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaMemberValuePairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14122 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14135 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpClauseStorageClass::pickOutIRNodeData ( SgOmpClause* pointer ) 
   { 
     SgOmpClause* source = (SgOmpClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14192 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpNowaitClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14205 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpNowaitClauseStorageClass::pickOutIRNodeData ( SgOmpNowaitClause* pointer ) 
   { 
     SgOmpNowaitClause* source = (SgOmpNowaitClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpNowaitClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpNowaitClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpNowaitClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpNowaitClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14262 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpBeginClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14275 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpBeginClauseStorageClass::pickOutIRNodeData ( SgOmpBeginClause* pointer ) 
   { 
     SgOmpBeginClause* source = (SgOmpBeginClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpBeginClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpBeginClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpBeginClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpBeginClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14332 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpEndClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14345 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpEndClauseStorageClass::pickOutIRNodeData ( SgOmpEndClause* pointer ) 
   { 
     SgOmpEndClause* source = (SgOmpEndClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpEndClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpEndClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpEndClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpEndClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14402 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpUntiedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14415 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpUntiedClauseStorageClass::pickOutIRNodeData ( SgOmpUntiedClause* pointer ) 
   { 
     SgOmpUntiedClause* source = (SgOmpUntiedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpUntiedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpUntiedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpUntiedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpUntiedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14472 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDefaultClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14485 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDefaultClauseStorageClass::pickOutIRNodeData ( SgOmpDefaultClause* pointer ) 
   { 
     SgOmpDefaultClause* source = (SgOmpDefaultClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_data_sharing =  source->p_data_sharing ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpDefaultClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDefaultClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDefaultClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDefaultClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14543 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpAtomicClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14556 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpAtomicClauseStorageClass::pickOutIRNodeData ( SgOmpAtomicClause* pointer ) 
   { 
     SgOmpAtomicClause* source = (SgOmpAtomicClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_atomicity =  source->p_atomicity ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpAtomicClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpAtomicClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpAtomicClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpAtomicClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14614 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpProcBindClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14627 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpProcBindClauseStorageClass::pickOutIRNodeData ( SgOmpProcBindClause* pointer ) 
   { 
     SgOmpProcBindClause* source = (SgOmpProcBindClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_policy =  source->p_policy ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpProcBindClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpProcBindClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpProcBindClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpProcBindClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14685 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpExpressionClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14698 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpExpressionClauseStorageClass::pickOutIRNodeData ( SgOmpExpressionClause* pointer ) 
   { 
     SgOmpExpressionClause* source = (SgOmpExpressionClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpExpressionClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpExpressionClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpExpressionClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpExpressionClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14756 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpOrderedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14769 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpOrderedClauseStorageClass::pickOutIRNodeData ( SgOmpOrderedClause* pointer ) 
   { 
     SgOmpOrderedClause* source = (SgOmpOrderedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpOrderedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpOrderedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpOrderedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpOrderedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14827 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCollapseClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14840 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCollapseClauseStorageClass::pickOutIRNodeData ( SgOmpCollapseClause* pointer ) 
   { 
     SgOmpCollapseClause* source = (SgOmpCollapseClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpCollapseClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCollapseClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCollapseClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCollapseClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14898 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpIfClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14911 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpIfClauseStorageClass::pickOutIRNodeData ( SgOmpIfClause* pointer ) 
   { 
     SgOmpIfClause* source = (SgOmpIfClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpIfClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpIfClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpIfClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpIfClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 14969 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpNumThreadsClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 14982 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpNumThreadsClauseStorageClass::pickOutIRNodeData ( SgOmpNumThreadsClause* pointer ) 
   { 
     SgOmpNumThreadsClause* source = (SgOmpNumThreadsClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpNumThreadsClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpNumThreadsClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpNumThreadsClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpNumThreadsClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15040 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDeviceClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15053 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDeviceClauseStorageClass::pickOutIRNodeData ( SgOmpDeviceClause* pointer ) 
   { 
     SgOmpDeviceClause* source = (SgOmpDeviceClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpDeviceClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDeviceClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDeviceClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDeviceClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15111 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSafelenClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15124 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSafelenClauseStorageClass::pickOutIRNodeData ( SgOmpSafelenClause* pointer ) 
   { 
     SgOmpSafelenClause* source = (SgOmpSafelenClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpSafelenClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSafelenClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSafelenClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSafelenClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15182 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSimdlenClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15195 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSimdlenClauseStorageClass::pickOutIRNodeData ( SgOmpSimdlenClause* pointer ) 
   { 
     SgOmpSimdlenClause* source = (SgOmpSimdlenClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpSimdlenClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSimdlenClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSimdlenClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSimdlenClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15253 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpFinalClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15266 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpFinalClauseStorageClass::pickOutIRNodeData ( SgOmpFinalClause* pointer ) 
   { 
     SgOmpFinalClause* source = (SgOmpFinalClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpFinalClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpFinalClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpFinalClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpFinalClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15324 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpPriorityClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15337 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpPriorityClauseStorageClass::pickOutIRNodeData ( SgOmpPriorityClause* pointer ) 
   { 
     SgOmpPriorityClause* source = (SgOmpPriorityClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpPriorityClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpPriorityClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpPriorityClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpPriorityClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15395 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpInbranchClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15408 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpInbranchClauseStorageClass::pickOutIRNodeData ( SgOmpInbranchClause* pointer ) 
   { 
     SgOmpInbranchClause* source = (SgOmpInbranchClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpInbranchClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpInbranchClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpInbranchClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpInbranchClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15465 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpNotinbranchClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15478 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpNotinbranchClauseStorageClass::pickOutIRNodeData ( SgOmpNotinbranchClause* pointer ) 
   { 
     SgOmpNotinbranchClause* source = (SgOmpNotinbranchClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpNotinbranchClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpNotinbranchClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpNotinbranchClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpNotinbranchClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15535 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpVariablesClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15548 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpVariablesClauseStorageClass::pickOutIRNodeData ( SgOmpVariablesClause* pointer ) 
   { 
     SgOmpVariablesClause* source = (SgOmpVariablesClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpVariablesClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpVariablesClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpVariablesClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpVariablesClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15606 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCopyprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15619 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCopyprivateClauseStorageClass::pickOutIRNodeData ( SgOmpCopyprivateClause* pointer ) 
   { 
     SgOmpCopyprivateClause* source = (SgOmpCopyprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpCopyprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCopyprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCopyprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCopyprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15677 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpPrivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15690 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpPrivateClauseStorageClass::pickOutIRNodeData ( SgOmpPrivateClause* pointer ) 
   { 
     SgOmpPrivateClause* source = (SgOmpPrivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpPrivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpPrivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpPrivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpPrivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15748 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpFirstprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15761 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpFirstprivateClauseStorageClass::pickOutIRNodeData ( SgOmpFirstprivateClause* pointer ) 
   { 
     SgOmpFirstprivateClause* source = (SgOmpFirstprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpFirstprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpFirstprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpFirstprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpFirstprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15819 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSharedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15832 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSharedClauseStorageClass::pickOutIRNodeData ( SgOmpSharedClause* pointer ) 
   { 
     SgOmpSharedClause* source = (SgOmpSharedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpSharedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSharedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSharedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSharedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15890 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCopyinClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15903 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCopyinClauseStorageClass::pickOutIRNodeData ( SgOmpCopyinClause* pointer ) 
   { 
     SgOmpCopyinClause* source = (SgOmpCopyinClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpCopyinClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCopyinClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCopyinClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCopyinClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 15961 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpLastprivateClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 15974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpLastprivateClauseStorageClass::pickOutIRNodeData ( SgOmpLastprivateClause* pointer ) 
   { 
     SgOmpLastprivateClause* source = (SgOmpLastprivateClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpLastprivateClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpLastprivateClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpLastprivateClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpLastprivateClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16032 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpReductionClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16045 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpReductionClauseStorageClass::pickOutIRNodeData ( SgOmpReductionClause* pointer ) 
   { 
     SgOmpReductionClause* source = (SgOmpReductionClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operation =  source->p_operation ;
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpReductionClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpReductionClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpReductionClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpReductionClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16104 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpMapClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16117 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpMapClauseStorageClass::pickOutIRNodeData ( SgOmpMapClause* pointer ) 
   { 
     SgOmpMapClause* source = (SgOmpMapClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operation =  source->p_operation ;
     storageOf_array_dimensions.storeDataInEasyStorageClass(source->p_array_dimensions);
     storageOf_dist_data_policies.storeDataInEasyStorageClass(source->p_dist_data_policies);
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpMapClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > > > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpMapClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: deleteMemoryPool() ;
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > > > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpMapClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: writeToFile(out) ;
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > > > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpMapClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: readFromFile(in) ;
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgOmpClause::omp_map_dist_data_enum, SgExpression*> > > > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpUniformClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16199 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpUniformClauseStorageClass::pickOutIRNodeData ( SgOmpUniformClause* pointer ) 
   { 
     SgOmpUniformClause* source = (SgOmpUniformClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpUniformClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpUniformClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpUniformClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpUniformClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16257 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpAlignedClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16270 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpAlignedClauseStorageClass::pickOutIRNodeData ( SgOmpAlignedClause* pointer ) 
   { 
     SgOmpAlignedClause* source = (SgOmpAlignedClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_alignment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_alignment );
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpAlignedClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpAlignedClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpAlignedClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpAlignedClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16329 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpLinearClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16342 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpLinearClauseStorageClass::pickOutIRNodeData ( SgOmpLinearClause* pointer ) 
   { 
     SgOmpLinearClause* source = (SgOmpLinearClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_step = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_step );
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpLinearClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpLinearClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpLinearClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpLinearClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16401 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDependClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16414 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDependClauseStorageClass::pickOutIRNodeData ( SgOmpDependClause* pointer ) 
   { 
     SgOmpDependClause* source = (SgOmpDependClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_dependence_type =  source->p_dependence_type ;
     storageOf_array_dimensions.storeDataInEasyStorageClass(source->p_array_dimensions);
     storageOf_variables = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variables );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpDependClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDependClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDependClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDependClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::map<SgSymbol*,  std::vector < std::pair <SgExpression*, SgExpression*> > > > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16478 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpScheduleClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16491 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpScheduleClauseStorageClass::pickOutIRNodeData ( SgOmpScheduleClause* pointer ) 
   { 
     SgOmpScheduleClause* source = (SgOmpScheduleClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_chunk_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_chunk_size );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpScheduleClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpScheduleClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpScheduleClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpScheduleClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16550 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpMergeableClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16563 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpMergeableClauseStorageClass::pickOutIRNodeData ( SgOmpMergeableClause* pointer ) 
   { 
     SgOmpMergeableClause* source = (SgOmpMergeableClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpMergeableClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpMergeableClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpMergeableClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpMergeableClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16620 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLambdaCaptureStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16633 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLambdaCaptureStorageClass::pickOutIRNodeData ( SgLambdaCapture* pointer ) 
   { 
     SgLambdaCapture* source = (SgLambdaCapture*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_capture_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_capture_variable );
     storageOf_source_closure_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_closure_variable );
     storageOf_closure_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_closure_variable );
     storageOf_capture_by_reference =  source->p_capture_by_reference ;
     storageOf_implicit =  source->p_implicit ;
     storageOf_pack_expansion =  source->p_pack_expansion ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLambdaCaptureStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLambdaCaptureStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLambdaCaptureStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLambdaCaptureStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16696 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLambdaCaptureListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16709 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLambdaCaptureListStorageClass::pickOutIRNodeData ( SgLambdaCaptureList* pointer ) 
   { 
     SgLambdaCaptureList* source = (SgLambdaCaptureList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgLambdaCapturePtrList::iterator i_capture_list = source->p_capture_list.begin() ; 
     unsigned int tempListCountcapture_list = 0; 
     SgLambdaCapturePtrList::value_type *  tempListcapture_list = new SgLambdaCapturePtrList::value_type[ source->p_capture_list.size() ]; 
     for ( ; i_capture_list != source->p_capture_list.end(); ++i_capture_list ) 
        {
          tempListcapture_list[tempListCountcapture_list] = *i_capture_list;
          tempListCountcapture_list++; 
          (*i_capture_list) = (SgLambdaCapturePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_capture_list ) );
        }
     storageOf_capture_list.storeDataInEasyStorageClass(source->p_capture_list);
     tempListCountcapture_list = 0; 
     i_capture_list = source->p_capture_list.begin() ; 
     for ( ; i_capture_list != source->p_capture_list.end(); ++i_capture_list ) 
        {
          *i_capture_list = tempListcapture_list[tempListCountcapture_list] ;
          tempListCountcapture_list++; 
        }
      delete [] tempListcapture_list; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLambdaCaptureListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgLambdaCapturePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLambdaCaptureListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgLambdaCapturePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLambdaCaptureListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgLambdaCapturePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLambdaCaptureListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgLambdaCapturePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16788 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTypeConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16801 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTypeConstraintStorageClass::pickOutIRNodeData ( SgAdaTypeConstraint* pointer ) 
   { 
     SgAdaTypeConstraint* source = (SgAdaTypeConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTypeConstraintStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTypeConstraintStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTypeConstraintStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTypeConstraintStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16858 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaRangeConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16871 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaRangeConstraintStorageClass::pickOutIRNodeData ( SgAdaRangeConstraint* pointer ) 
   { 
     SgAdaRangeConstraint* source = (SgAdaRangeConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_range = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_range );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaRangeConstraintStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaRangeConstraintStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaRangeConstraintStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaRangeConstraintStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 16929 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaIndexConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 16942 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaIndexConstraintStorageClass::pickOutIRNodeData ( SgAdaIndexConstraint* pointer ) 
   { 
     SgAdaIndexConstraint* source = (SgAdaIndexConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_indexRanges = source->p_indexRanges.begin() ; 
     unsigned int tempListCountindexRanges = 0; 
     SgExpressionPtrList::value_type *  tempListindexRanges = new SgExpressionPtrList::value_type[ source->p_indexRanges.size() ]; 
     for ( ; i_indexRanges != source->p_indexRanges.end(); ++i_indexRanges ) 
        {
          tempListindexRanges[tempListCountindexRanges] = *i_indexRanges;
          tempListCountindexRanges++; 
          (*i_indexRanges) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_indexRanges ) );
        }
     storageOf_indexRanges.storeDataInEasyStorageClass(source->p_indexRanges);
     tempListCountindexRanges = 0; 
     i_indexRanges = source->p_indexRanges.begin() ; 
     for ( ; i_indexRanges != source->p_indexRanges.end(); ++i_indexRanges ) 
        {
          *i_indexRanges = tempListindexRanges[tempListCountindexRanges] ;
          tempListCountindexRanges++; 
        }
      delete [] tempListindexRanges; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaIndexConstraintStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaIndexConstraintStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaIndexConstraintStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaIndexConstraintStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17021 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDigitsConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17034 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDigitsConstraintStorageClass::pickOutIRNodeData ( SgAdaDigitsConstraint* pointer ) 
   { 
     SgAdaDigitsConstraint* source = (SgAdaDigitsConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_digits = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_digits );
     storageOf_subConstraint = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_subConstraint );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDigitsConstraintStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDigitsConstraintStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDigitsConstraintStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDigitsConstraintStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17093 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDeltaConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17106 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDeltaConstraintStorageClass::pickOutIRNodeData ( SgAdaDeltaConstraint* pointer ) 
   { 
     SgAdaDeltaConstraint* source = (SgAdaDeltaConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_delta = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delta );
     storageOf_subConstraint = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_subConstraint );
     storageOf_isDecimal =  source->p_isDecimal ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDeltaConstraintStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDeltaConstraintStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDeltaConstraintStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDeltaConstraintStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17166 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDiscriminantConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17179 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDiscriminantConstraintStorageClass::pickOutIRNodeData ( SgAdaDiscriminantConstraint* pointer ) 
   { 
     SgAdaDiscriminantConstraint* source = (SgAdaDiscriminantConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_discriminants = source->p_discriminants.begin() ; 
     unsigned int tempListCountdiscriminants = 0; 
     SgExpressionPtrList::value_type *  tempListdiscriminants = new SgExpressionPtrList::value_type[ source->p_discriminants.size() ]; 
     for ( ; i_discriminants != source->p_discriminants.end(); ++i_discriminants ) 
        {
          tempListdiscriminants[tempListCountdiscriminants] = *i_discriminants;
          tempListCountdiscriminants++; 
          (*i_discriminants) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_discriminants ) );
        }
     storageOf_discriminants.storeDataInEasyStorageClass(source->p_discriminants);
     tempListCountdiscriminants = 0; 
     i_discriminants = source->p_discriminants.begin() ; 
     for ( ; i_discriminants != source->p_discriminants.end(); ++i_discriminants ) 
        {
          *i_discriminants = tempListdiscriminants[tempListCountdiscriminants] ;
          tempListCountdiscriminants++; 
        }
      delete [] tempListdiscriminants; 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDiscriminantConstraintStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDiscriminantConstraintStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDiscriminantConstraintStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDiscriminantConstraintStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17258 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaNullConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17271 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaNullConstraintStorageClass::pickOutIRNodeData ( SgAdaNullConstraint* pointer ) 
   { 
     SgAdaNullConstraint* source = (SgAdaNullConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaNullConstraintStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaNullConstraintStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaNullConstraintStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaNullConstraintStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17328 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17341 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStatementStorageClass::pickOutIRNodeData ( SgStatement* pointer ) 
   { 
     SgStatement* source = (SgStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17400 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopeStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17413 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgScopeStatementStorageClass::pickOutIRNodeData ( SgScopeStatement* pointer ) 
   { 
     SgScopeStatement* source = (SgScopeStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgScopeStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopeStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopeStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopeStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17482 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGlobalStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17495 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGlobalStorageClass::pickOutIRNodeData ( SgGlobal* pointer ) 
   { 
     SgGlobal* source = (SgGlobal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgGlobalStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGlobalStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGlobalStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGlobalStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17586 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBasicBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17599 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBasicBlockStorageClass::pickOutIRNodeData ( SgBasicBlock* pointer ) 
   { 
     SgBasicBlock* source = (SgBasicBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgStatementPtrList::iterator i_statements = source->p_statements.begin() ; 
     unsigned int tempListCountstatements = 0; 
     SgStatementPtrList::value_type *  tempListstatements = new SgStatementPtrList::value_type[ source->p_statements.size() ]; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          tempListstatements[tempListCountstatements] = *i_statements;
          tempListCountstatements++; 
          (*i_statements) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statements ) );
        }
     storageOf_statements.storeDataInEasyStorageClass(source->p_statements);
     tempListCountstatements = 0; 
     i_statements = source->p_statements.begin() ; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          *i_statements = tempListstatements[tempListCountstatements] ;
          tempListCountstatements++; 
        }
      delete [] tempListstatements; 
     storageOf_asm_function_body.storeDataInEasyStorageClass(source->p_asm_function_body);
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBasicBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBasicBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBasicBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBasicBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17696 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17709 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIfStmtStorageClass::pickOutIRNodeData ( SgIfStmt* pointer ) 
   { 
     SgIfStmt* source = (SgIfStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_conditional = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional );
     storageOf_true_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_true_body );
     storageOf_false_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_false_body );
     storageOf_is_if_constexpr_statement =  source->p_is_if_constexpr_statement ;
     storageOf_if_constexpr_value_known =  source->p_if_constexpr_value_known ;
     storageOf_if_constexpr_value =  source->p_if_constexpr_value ;
     storageOf_else_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_use_then_keyword =  source->p_use_then_keyword ;
     storageOf_is_else_if_statement =  source->p_is_else_if_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIfStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17794 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17807 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgForStatementStorageClass::pickOutIRNodeData ( SgForStatement* pointer ) 
   { 
     SgForStatement* source = (SgForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_for_init_stmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_for_init_stmt );
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_else_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_body );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17886 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17899 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionDefinitionStorageClass::pickOutIRNodeData ( SgFunctionDefinition* pointer ) 
   { 
     SgFunctionDefinition* source = (SgFunctionDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_scope_number_list.storeDataInEasyStorageClass(source->p_scope_number_list);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::map<SgNode*,int> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::map<SgNode*,int> > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::map<SgNode*,int> > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::map<SgNode*,int> > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 17974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateFunctionDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 17987 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateFunctionDefinitionStorageClass::pickOutIRNodeData ( SgTemplateFunctionDefinition* pointer ) 
   { 
     SgTemplateFunctionDefinition* source = (SgTemplateFunctionDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_scope_number_list.storeDataInEasyStorageClass(source->p_scope_number_list);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateFunctionDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::map<SgNode*,int> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateFunctionDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::map<SgNode*,int> > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateFunctionDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::map<SgNode*,int> > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateFunctionDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::map<SgNode*,int> > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18062 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18075 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClassDefinitionStorageClass::pickOutIRNodeData ( SgClassDefinition* pointer ) 
   { 
     SgClassDefinition* source = (SgClassDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClassDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18192 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDefnStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18205 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDefnStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDefn* pointer ) 
   { 
     SgTemplateInstantiationDefn* source = (SgTemplateInstantiationDefn*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateInstantiationDefnStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDefnStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDefnStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDefnStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18322 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateClassDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18335 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateClassDefinitionStorageClass::pickOutIRNodeData ( SgTemplateClassDefinition* pointer ) 
   { 
     SgTemplateClassDefinition* source = (SgTemplateClassDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_members = source->p_members.begin() ; 
     unsigned int tempListCountmembers = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListmembers = new SgDeclarationStatementPtrList::value_type[ source->p_members.size() ]; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          tempListmembers[tempListCountmembers] = *i_members;
          tempListCountmembers++; 
          (*i_members) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_members ) );
        }
     storageOf_members.storeDataInEasyStorageClass(source->p_members);
     tempListCountmembers = 0; 
     i_members = source->p_members.begin() ; 
     for ( ; i_members != source->p_members.end(); ++i_members ) 
        {
          *i_members = tempListmembers[tempListCountmembers] ;
          tempListCountmembers++; 
        }
      delete [] tempListmembers; 
     SgBaseClassPtrList::iterator i_inheritances = source->p_inheritances.begin() ; 
     unsigned int tempListCountinheritances = 0; 
     SgBaseClassPtrList::value_type *  tempListinheritances = new SgBaseClassPtrList::value_type[ source->p_inheritances.size() ]; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          tempListinheritances[tempListCountinheritances] = *i_inheritances;
          tempListCountinheritances++; 
          (*i_inheritances) = (SgBaseClassPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_inheritances ) );
        }
     storageOf_inheritances.storeDataInEasyStorageClass(source->p_inheritances);
     tempListCountinheritances = 0; 
     i_inheritances = source->p_inheritances.begin() ; 
     for ( ; i_inheritances != source->p_inheritances.end(); ++i_inheritances ) 
        {
          *i_inheritances = tempListinheritances[tempListCountinheritances] ;
          tempListCountinheritances++; 
        }
      delete [] tempListinheritances; 
     storageOf_packingAlignment =  source->p_packingAlignment ;
     storageOf_isSequence =  source->p_isSequence ;
     storageOf_isPrivate =  source->p_isPrivate ;
     storageOf_isAbstract =  source->p_isAbstract ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateClassDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgBaseClassPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateClassDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgBaseClassPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateClassDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgBaseClassPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateClassDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgBaseClassPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18452 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWhileStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18465 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWhileStmtStorageClass::pickOutIRNodeData ( SgWhileStmt* pointer ) 
   { 
     SgWhileStmt* source = (SgWhileStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_else_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWhileStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWhileStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWhileStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWhileStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18544 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDoWhileStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18557 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDoWhileStmtStorageClass::pickOutIRNodeData ( SgDoWhileStmt* pointer ) 
   { 
     SgDoWhileStmt* source = (SgDoWhileStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDoWhileStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDoWhileStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDoWhileStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDoWhileStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18628 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSwitchStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18641 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSwitchStatementStorageClass::pickOutIRNodeData ( SgSwitchStatement* pointer ) 
   { 
     SgSwitchStatement* source = (SgSwitchStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_item_selector = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_item_selector );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSwitchStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSwitchStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSwitchStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSwitchStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18718 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCatchOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18731 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCatchOptionStmtStorageClass::pickOutIRNodeData ( SgCatchOptionStmt* pointer ) 
   { 
     SgCatchOptionStmt* source = (SgCatchOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_trystmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_trystmt );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCatchOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCatchOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCatchOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCatchOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18803 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceDefinitionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18816 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceDefinitionStatementStorageClass::pickOutIRNodeData ( SgNamespaceDefinitionStatement* pointer ) 
   { 
     SgNamespaceDefinitionStatement* source = (SgNamespaceDefinitionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_previousNamespaceDefinition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_previousNamespaceDefinition );
     storageOf_nextNamespaceDefinition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nextNamespaceDefinition );
     storageOf_global_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_global_definition );
     storageOf_isUnionOfReentrantNamespaceDefinitions =  source->p_isUnionOfReentrantNamespaceDefinitions ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNamespaceDefinitionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceDefinitionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceDefinitionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceDefinitionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18912 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBlockDataStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 18925 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBlockDataStatementStorageClass::pickOutIRNodeData ( SgBlockDataStatement* pointer ) 
   { 
     SgBlockDataStatement* source = (SgBlockDataStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBlockDataStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBlockDataStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBlockDataStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBlockDataStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 18995 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssociateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19008 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAssociateStatementStorageClass::pickOutIRNodeData ( SgAssociateStatement* pointer ) 
   { 
     SgAssociateStatement* source = (SgAssociateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_associates = source->p_associates.begin() ; 
     unsigned int tempListCountassociates = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListassociates = new SgDeclarationStatementPtrList::value_type[ source->p_associates.size() ]; 
     for ( ; i_associates != source->p_associates.end(); ++i_associates ) 
        {
          tempListassociates[tempListCountassociates] = *i_associates;
          tempListCountassociates++; 
          (*i_associates) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_associates ) );
        }
     storageOf_associates.storeDataInEasyStorageClass(source->p_associates);
     tempListCountassociates = 0; 
     i_associates = source->p_associates.begin() ; 
     for ( ; i_associates != source->p_associates.end(); ++i_associates ) 
        {
          *i_associates = tempListassociates[tempListCountassociates] ;
          tempListCountassociates++; 
        }
      delete [] tempListassociates; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAssociateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssociateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssociateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssociateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19100 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19113 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFortranDoStorageClass::pickOutIRNodeData ( SgFortranDo* pointer ) 
   { 
     SgFortranDo* source = (SgFortranDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initialization );
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_old_style =  source->p_old_style ;
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFortranDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19194 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranNonblockedDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19207 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFortranNonblockedDoStorageClass::pickOutIRNodeData ( SgFortranNonblockedDo* pointer ) 
   { 
     SgFortranNonblockedDo* source = (SgFortranNonblockedDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_end_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_statement );
     storageOf_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initialization );
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_old_style =  source->p_old_style ;
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFortranNonblockedDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranNonblockedDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranNonblockedDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranNonblockedDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19289 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForAllStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19302 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgForAllStatementStorageClass::pickOutIRNodeData ( SgForAllStatement* pointer ) 
   { 
     SgForAllStatement* source = (SgForAllStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_forall_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_forall_header );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_forall_statement_kind =  source->p_forall_statement_kind ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgForAllStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForAllStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForAllStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForAllStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19381 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcForAllStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19394 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcForAllStatementStorageClass::pickOutIRNodeData ( SgUpcForAllStatement* pointer ) 
   { 
     SgUpcForAllStatement* source = (SgUpcForAllStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_for_init_stmt = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_for_init_stmt );
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_affinity = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_affinity );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcForAllStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcForAllStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcForAllStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcForAllStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19468 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCAFWithTeamStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19481 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCAFWithTeamStatementStorageClass::pickOutIRNodeData ( SgCAFWithTeamStatement* pointer ) 
   { 
     SgCAFWithTeamStatement* source = (SgCAFWithTeamStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_teamId = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamId );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_endHasTeamId =  source->p_endHasTeamId ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCAFWithTeamStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCAFWithTeamStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCAFWithTeamStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCAFWithTeamStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19553 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaForEachStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19566 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaForEachStatementStorageClass::pickOutIRNodeData ( SgJavaForEachStatement* pointer ) 
   { 
     SgJavaForEachStatement* source = (SgJavaForEachStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_collection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_collection );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaForEachStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaForEachStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaForEachStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaForEachStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19638 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaLabelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19651 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaLabelStatementStorageClass::pickOutIRNodeData ( SgJavaLabelStatement* pointer ) 
   { 
     SgJavaLabelStatement* source = (SgJavaLabelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_label.pickOutIRNodeData( &(source->p_label) );
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaLabelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaLabelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaLabelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaLabelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19726 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMatlabForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19739 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMatlabForStatementStorageClass::pickOutIRNodeData ( SgMatlabForStatement* pointer ) 
   { 
     SgMatlabForStatement* source = (SgMatlabForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_index );
     storageOf_range = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_range );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMatlabForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMatlabForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMatlabForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMatlabForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19811 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterScopeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19824 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterScopeStorageClass::pickOutIRNodeData ( SgFunctionParameterScope* pointer ) 
   { 
     SgFunctionParameterScope* source = (SgFunctionParameterScope*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionParameterScopeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterScopeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterScopeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionParameterScopeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19915 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclarationScopeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 19928 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDeclarationScopeStorageClass::pickOutIRNodeData ( SgDeclarationScope* pointer ) 
   { 
     SgDeclarationScope* source = (SgDeclarationScope*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDeclarationScopeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclarationScopeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeclarationScopeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeclarationScopeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 19997 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRangeBasedForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20010 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRangeBasedForStatementStorageClass::pickOutIRNodeData ( SgRangeBasedForStatement* pointer ) 
   { 
     SgRangeBasedForStatement* source = (SgRangeBasedForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_iterator_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iterator_declaration );
     storageOf_range_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_range_declaration );
     storageOf_begin_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_begin_declaration );
     storageOf_end_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_declaration );
     storageOf_not_equal_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_not_equal_expression );
     storageOf_increment_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment_expression );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRangeBasedForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRangeBasedForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRangeBasedForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRangeBasedForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20086 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialForThenStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20099 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialForThenStatementStorageClass::pickOutIRNodeData ( SgJovialForThenStatement* pointer ) 
   { 
     SgJovialForThenStatement* source = (SgJovialForThenStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initialization );
     storageOf_while_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_while_expression );
     storageOf_by_or_then_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_by_or_then_expression );
     storageOf_loop_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop_body );
     storageOf_loop_statement_type =  source->p_loop_statement_type ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialForThenStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialForThenStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialForThenStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialForThenStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20173 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaAcceptStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaAcceptStmtStorageClass::pickOutIRNodeData ( SgAdaAcceptStmt* pointer ) 
   { 
     SgAdaAcceptStmt* source = (SgAdaAcceptStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterScope );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entry );
     storageOf_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_index );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaAcceptStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaAcceptStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaAcceptStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaAcceptStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20260 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaPackageSpecStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20273 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaPackageSpecStorageClass::pickOutIRNodeData ( SgAdaPackageSpec* pointer ) 
   { 
     SgAdaPackageSpec* source = (SgAdaPackageSpec*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_hasPrivate =  source->p_hasPrivate ;
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaPackageSpecStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaPackageSpecStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaPackageSpecStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaPackageSpecStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20365 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaPackageBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20378 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaPackageBodyStorageClass::pickOutIRNodeData ( SgAdaPackageBody* pointer ) 
   { 
     SgAdaPackageBody* source = (SgAdaPackageBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgStatementPtrList::iterator i_statements = source->p_statements.begin() ; 
     unsigned int tempListCountstatements = 0; 
     SgStatementPtrList::value_type *  tempListstatements = new SgStatementPtrList::value_type[ source->p_statements.size() ]; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          tempListstatements[tempListCountstatements] = *i_statements;
          tempListCountstatements++; 
          (*i_statements) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statements ) );
        }
     storageOf_statements.storeDataInEasyStorageClass(source->p_statements);
     tempListCountstatements = 0; 
     i_statements = source->p_statements.begin() ; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          *i_statements = tempListstatements[tempListCountstatements] ;
          tempListCountstatements++; 
        }
      delete [] tempListstatements; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaPackageBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaPackageBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaPackageBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaPackageBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20469 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskSpecStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20482 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskSpecStorageClass::pickOutIRNodeData ( SgAdaTaskSpec* pointer ) 
   { 
     SgAdaTaskSpec* source = (SgAdaTaskSpec*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_hasPrivate =  source->p_hasPrivate ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskSpecStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskSpecStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskSpecStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskSpecStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20575 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20588 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskBodyStorageClass::pickOutIRNodeData ( SgAdaTaskBody* pointer ) 
   { 
     SgAdaTaskBody* source = (SgAdaTaskBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_spec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_spec );
     SgStatementPtrList::iterator i_statements = source->p_statements.begin() ; 
     unsigned int tempListCountstatements = 0; 
     SgStatementPtrList::value_type *  tempListstatements = new SgStatementPtrList::value_type[ source->p_statements.size() ]; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          tempListstatements[tempListCountstatements] = *i_statements;
          tempListCountstatements++; 
          (*i_statements) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statements ) );
        }
     storageOf_statements.storeDataInEasyStorageClass(source->p_statements);
     tempListCountstatements = 0; 
     i_statements = source->p_statements.begin() ; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          *i_statements = tempListstatements[tempListCountstatements] ;
          tempListCountstatements++; 
        }
      delete [] tempListstatements; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20680 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedBodyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20693 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedBodyStorageClass::pickOutIRNodeData ( SgAdaProtectedBody* pointer ) 
   { 
     SgAdaProtectedBody* source = (SgAdaProtectedBody*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_spec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_spec );
     SgStatementPtrList::iterator i_statements = source->p_statements.begin() ; 
     unsigned int tempListCountstatements = 0; 
     SgStatementPtrList::value_type *  tempListstatements = new SgStatementPtrList::value_type[ source->p_statements.size() ]; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          tempListstatements[tempListCountstatements] = *i_statements;
          tempListCountstatements++; 
          (*i_statements) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statements ) );
        }
     storageOf_statements.storeDataInEasyStorageClass(source->p_statements);
     tempListCountstatements = 0; 
     i_statements = source->p_statements.begin() ; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          *i_statements = tempListstatements[tempListCountstatements] ;
          tempListCountstatements++; 
        }
      delete [] tempListstatements; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedBodyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedBodyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedBodyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedBodyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20785 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedSpecStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20798 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedSpecStorageClass::pickOutIRNodeData ( SgAdaProtectedSpec* pointer ) 
   { 
     SgAdaProtectedSpec* source = (SgAdaProtectedSpec*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_hasPrivate =  source->p_hasPrivate ;
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedSpecStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedSpecStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedSpecStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedSpecStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20891 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaGenericDefnStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 20904 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaGenericDefnStorageClass::pickOutIRNodeData ( SgAdaGenericDefn* pointer ) 
   { 
     SgAdaGenericDefn* source = (SgAdaGenericDefn*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_declarations = source->p_declarations.begin() ; 
     unsigned int tempListCountdeclarations = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListdeclarations = new SgDeclarationStatementPtrList::value_type[ source->p_declarations.size() ]; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          tempListdeclarations[tempListCountdeclarations] = *i_declarations;
          tempListCountdeclarations++; 
          (*i_declarations) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_declarations ) );
        }
     storageOf_declarations.storeDataInEasyStorageClass(source->p_declarations);
     tempListCountdeclarations = 0; 
     i_declarations = source->p_declarations.begin() ; 
     for ( ; i_declarations != source->p_declarations.end(); ++i_declarations ) 
        {
          *i_declarations = tempListdeclarations[tempListCountdeclarations] ;
          tempListCountdeclarations++; 
        }
      delete [] tempListdeclarations; 
     storageOf_symbol_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_table );
     storageOf_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_table );
     storageOf_type_elaboration_list.storeDataInEasyStorageClass(source->p_type_elaboration_list);
     storageOf_hidden_type_list.storeDataInEasyStorageClass(source->p_hidden_type_list);
     storageOf_hidden_declaration_list.storeDataInEasyStorageClass(source->p_hidden_declaration_list);
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaGenericDefnStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::set<SgSymbol*> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaGenericDefnStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::set<SgSymbol*> > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaGenericDefnStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::set<SgSymbol*> > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaGenericDefnStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::set<SgSymbol*> > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 20995 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21008 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeTableStorageClass::pickOutIRNodeData ( SgFunctionTypeTable* pointer ) 
   { 
     SgFunctionTypeTable* source = (SgFunctionTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_function_type_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type_table );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionTypeTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21068 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21081 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDeclarationStatementStorageClass::pickOutIRNodeData ( SgDeclarationStatement* pointer ) 
   { 
     SgDeclarationStatement* source = (SgDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21183 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21196 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterListStorageClass::pickOutIRNodeData ( SgFunctionParameterList* pointer ) 
   { 
     SgFunctionParameterList* source = (SgFunctionParameterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgInitializedNamePtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgInitializedNamePtrList::value_type *  tempListargs = new SgInitializedNamePtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionParameterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionParameterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21320 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21333 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVariableDeclarationStorageClass::pickOutIRNodeData ( SgVariableDeclaration* pointer ) 
   { 
     SgVariableDeclaration* source = (SgVariableDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_baseTypeDefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseTypeDefiningDeclaration );
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_variableDeclarationContainsBaseTypeDefiningDeclaration =  source->p_variableDeclarationContainsBaseTypeDefiningDeclaration ;
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_initialization_priority =  source->p_gnu_extension_initialization_priority ;
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_gnu_extension_declaration_attribute =  source->p_gnu_extension_declaration_attribute ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAssociatedWithDeclarationList =  source->p_isAssociatedWithDeclarationList ;
     storageOf_isFirstDeclarationOfDeclarationList =  source->p_isFirstDeclarationOfDeclarationList ;
     storageOf_is_thread_local =  source->p_is_thread_local ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_builtFromUseOnly =  source->p_builtFromUseOnly ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVariableDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21474 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateVariableDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21487 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateVariableDeclarationStorageClass::pickOutIRNodeData ( SgTemplateVariableDeclaration* pointer ) 
   { 
     SgTemplateVariableDeclaration* source = (SgTemplateVariableDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     SgTemplateArgumentPtrList::iterator i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     unsigned int tempListCounttemplateSpecializationArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateSpecializationArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateSpecializationArguments.size() ]; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] = *i_templateSpecializationArguments;
          tempListCounttemplateSpecializationArguments++; 
          (*i_templateSpecializationArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateSpecializationArguments ) );
        }
     storageOf_templateSpecializationArguments.storeDataInEasyStorageClass(source->p_templateSpecializationArguments);
     tempListCounttemplateSpecializationArguments = 0; 
     i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          *i_templateSpecializationArguments = tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] ;
          tempListCounttemplateSpecializationArguments++; 
        }
      delete [] tempListtemplateSpecializationArguments; 
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_nonreal_decl_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_decl_scope );
     storageOf_baseTypeDefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseTypeDefiningDeclaration );
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_variableDeclarationContainsBaseTypeDefiningDeclaration =  source->p_variableDeclarationContainsBaseTypeDefiningDeclaration ;
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_initialization_priority =  source->p_gnu_extension_initialization_priority ;
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_gnu_extension_declaration_attribute =  source->p_gnu_extension_declaration_attribute ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAssociatedWithDeclarationList =  source->p_isAssociatedWithDeclarationList ;
     storageOf_isFirstDeclarationOfDeclarationList =  source->p_isFirstDeclarationOfDeclarationList ;
     storageOf_is_thread_local =  source->p_is_thread_local ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_builtFromUseOnly =  source->p_builtFromUseOnly ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateVariableDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateVariableDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateVariableDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateVariableDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21678 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateVariableInstantiationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21691 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateVariableInstantiationStorageClass::pickOutIRNodeData ( SgTemplateVariableInstantiation* pointer ) 
   { 
     SgTemplateVariableInstantiation* source = (SgTemplateVariableInstantiation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateHeader.pickOutIRNodeData( &(source->p_templateHeader) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_baseTypeDefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseTypeDefiningDeclaration );
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_variableDeclarationContainsBaseTypeDefiningDeclaration =  source->p_variableDeclarationContainsBaseTypeDefiningDeclaration ;
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_initialization_priority =  source->p_gnu_extension_initialization_priority ;
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_gnu_extension_declaration_attribute =  source->p_gnu_extension_declaration_attribute ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAssociatedWithDeclarationList =  source->p_isAssociatedWithDeclarationList ;
     storageOf_isFirstDeclarationOfDeclarationList =  source->p_isFirstDeclarationOfDeclarationList ;
     storageOf_is_thread_local =  source->p_is_thread_local ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_builtFromUseOnly =  source->p_builtFromUseOnly ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateVariableInstantiationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateVariableInstantiationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateVariableInstantiationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateVariableInstantiationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21861 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableDefinitionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21874 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVariableDefinitionStorageClass::pickOutIRNodeData ( SgVariableDefinition* pointer ) 
   { 
     SgVariableDefinition* source = (SgVariableDefinition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_vardefn = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_vardefn );
     storageOf_bitfield = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bitfield );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVariableDefinitionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableDefinitionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableDefinitionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableDefinitionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 21978 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 21991 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageDeclarationStatementStorageClass::pickOutIRNodeData ( SgClinkageDeclarationStatement* pointer ) 
   { 
     SgClinkageDeclarationStatement* source = (SgClinkageDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClinkageDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22094 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageStartStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22107 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageStartStatementStorageClass::pickOutIRNodeData ( SgClinkageStartStatement* pointer ) 
   { 
     SgClinkageStartStatement* source = (SgClinkageStartStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClinkageStartStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageStartStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageStartStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageStartStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22210 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClinkageEndStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22223 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClinkageEndStatementStorageClass::pickOutIRNodeData ( SgClinkageEndStatement* pointer ) 
   { 
     SgClinkageEndStatement* source = (SgClinkageEndStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_languageSpecifier.storeDataInEasyStorageClass(source->p_languageSpecifier);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClinkageEndStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClinkageEndStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClinkageEndStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClinkageEndStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22326 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22339 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEnumDeclarationStorageClass::pickOutIRNodeData ( SgEnumDeclaration* pointer ) 
   { 
     SgEnumDeclaration* source = (SgEnumDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_embedded =  source->p_embedded ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     SgInitializedNamePtrList::iterator i_enumerators = source->p_enumerators.begin() ; 
     unsigned int tempListCountenumerators = 0; 
     SgInitializedNamePtrList::value_type *  tempListenumerators = new SgInitializedNamePtrList::value_type[ source->p_enumerators.size() ]; 
     for ( ; i_enumerators != source->p_enumerators.end(); ++i_enumerators ) 
        {
          tempListenumerators[tempListCountenumerators] = *i_enumerators;
          tempListCountenumerators++; 
          (*i_enumerators) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_enumerators ) );
        }
     storageOf_enumerators.storeDataInEasyStorageClass(source->p_enumerators);
     tempListCountenumerators = 0; 
     i_enumerators = source->p_enumerators.begin() ; 
     for ( ; i_enumerators != source->p_enumerators.end(); ++i_enumerators ) 
        {
          *i_enumerators = tempListenumerators[tempListCountenumerators] ;
          tempListCountenumerators++; 
        }
      delete [] tempListenumerators; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_field_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_field_type );
     storageOf_isScopedEnum =  source->p_isScopedEnum ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEnumDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22479 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22492 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStmtStorageClass::pickOutIRNodeData ( SgAsmStmt* pointer ) 
   { 
     SgAsmStmt* source = (SgAsmStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_assemblyCode.storeDataInEasyStorageClass(source->p_assemblyCode);
     storageOf_useGnuExtendedFormat =  source->p_useGnuExtendedFormat ;
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_clobberRegisterList.storeDataInEasyStorageClass(source->p_clobberRegisterList);
     storageOf_isVolatile =  source->p_isVolatile ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < SgAsmStmt::AsmRegisterNameList > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22624 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAttributeSpecificationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22637 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAttributeSpecificationStatementStorageClass::pickOutIRNodeData ( SgAttributeSpecificationStatement* pointer ) 
   { 
     SgAttributeSpecificationStatement* source = (SgAttributeSpecificationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name_list.storeDataInEasyStorageClass(source->p_name_list);
     storageOf_attribute_kind =  source->p_attribute_kind ;
     storageOf_intent =  source->p_intent ;
     storageOf_parameter_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameter_list );
     SgDataStatementGroupPtrList::iterator i_data_statement_group_list = source->p_data_statement_group_list.begin() ; 
     unsigned int tempListCountdata_statement_group_list = 0; 
     SgDataStatementGroupPtrList::value_type *  tempListdata_statement_group_list = new SgDataStatementGroupPtrList::value_type[ source->p_data_statement_group_list.size() ]; 
     for ( ; i_data_statement_group_list != source->p_data_statement_group_list.end(); ++i_data_statement_group_list ) 
        {
          tempListdata_statement_group_list[tempListCountdata_statement_group_list] = *i_data_statement_group_list;
          tempListCountdata_statement_group_list++; 
          (*i_data_statement_group_list) = (SgDataStatementGroupPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_data_statement_group_list ) );
        }
     storageOf_data_statement_group_list.storeDataInEasyStorageClass(source->p_data_statement_group_list);
     tempListCountdata_statement_group_list = 0; 
     i_data_statement_group_list = source->p_data_statement_group_list.begin() ; 
     for ( ; i_data_statement_group_list != source->p_data_statement_group_list.end(); ++i_data_statement_group_list ) 
        {
          *i_data_statement_group_list = tempListdata_statement_group_list[tempListCountdata_statement_group_list] ;
          tempListCountdata_statement_group_list++; 
        }
      delete [] tempListdata_statement_group_list; 
     storageOf_bind_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bind_list );
     SgDimensionObjectPtrList::iterator i_dimension_object_list = source->p_dimension_object_list.begin() ; 
     unsigned int tempListCountdimension_object_list = 0; 
     SgDimensionObjectPtrList::value_type *  tempListdimension_object_list = new SgDimensionObjectPtrList::value_type[ source->p_dimension_object_list.size() ]; 
     for ( ; i_dimension_object_list != source->p_dimension_object_list.end(); ++i_dimension_object_list ) 
        {
          tempListdimension_object_list[tempListCountdimension_object_list] = *i_dimension_object_list;
          tempListCountdimension_object_list++; 
          (*i_dimension_object_list) = (SgDimensionObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dimension_object_list ) );
        }
     storageOf_dimension_object_list.storeDataInEasyStorageClass(source->p_dimension_object_list);
     tempListCountdimension_object_list = 0; 
     i_dimension_object_list = source->p_dimension_object_list.begin() ; 
     for ( ; i_dimension_object_list != source->p_dimension_object_list.end(); ++i_dimension_object_list ) 
        {
          *i_dimension_object_list = tempListdimension_object_list[tempListCountdimension_object_list] ;
          tempListCountdimension_object_list++; 
        }
      delete [] tempListdimension_object_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAttributeSpecificationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDataStatementGroupPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgDimensionObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAttributeSpecificationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgDataStatementGroupPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgDimensionObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAttributeSpecificationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgDataStatementGroupPtrList > :: writeToFile(out) ;
     EasyStorage < SgDimensionObjectPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAttributeSpecificationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgDataStatementGroupPtrList > :: readFromFile(in) ;
     EasyStorage < SgDimensionObjectPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22792 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFormatStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22805 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFormatStatementStorageClass::pickOutIRNodeData ( SgFormatStatement* pointer ) 
   { 
     SgFormatStatement* source = (SgFormatStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_format_item_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format_item_list );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFormatStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFormatStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFormatStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFormatStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 22908 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 22921 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateDeclarationStorageClass::pickOutIRNodeData ( SgTemplateDeclaration* pointer ) 
   { 
     SgTemplateDeclaration* source = (SgTemplateDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_template_kind =  source->p_template_kind ;
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_nonreal_decl_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_decl_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23054 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23067 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDirectiveStatementStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDirectiveStatement* pointer ) 
   { 
     SgTemplateInstantiationDirectiveStatement* source = (SgTemplateInstantiationDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_do_not_instantiate =  source->p_do_not_instantiate ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23171 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23184 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUseStatementStorageClass::pickOutIRNodeData ( SgUseStatement* pointer ) 
   { 
     SgUseStatement* source = (SgUseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_only_option =  source->p_only_option ;
     storageOf_module_nature.storeDataInEasyStorageClass(source->p_module_nature);
     SgRenamePairPtrList::iterator i_rename_list = source->p_rename_list.begin() ; 
     unsigned int tempListCountrename_list = 0; 
     SgRenamePairPtrList::value_type *  tempListrename_list = new SgRenamePairPtrList::value_type[ source->p_rename_list.size() ]; 
     for ( ; i_rename_list != source->p_rename_list.end(); ++i_rename_list ) 
        {
          tempListrename_list[tempListCountrename_list] = *i_rename_list;
          tempListCountrename_list++; 
          (*i_rename_list) = (SgRenamePairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_rename_list ) );
        }
     storageOf_rename_list.storeDataInEasyStorageClass(source->p_rename_list);
     tempListCountrename_list = 0; 
     i_rename_list = source->p_rename_list.begin() ; 
     for ( ; i_rename_list != source->p_rename_list.end(); ++i_rename_list ) 
        {
          *i_rename_list = tempListrename_list[tempListCountrename_list] ;
          tempListCountrename_list++; 
        }
      delete [] tempListrename_list; 
     storageOf_module = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_module );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRenamePairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgRenamePairPtrList > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgRenamePairPtrList > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgRenamePairPtrList > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23316 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgParameterStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23329 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgParameterStatementStorageClass::pickOutIRNodeData ( SgParameterStatement* pointer ) 
   { 
     SgParameterStatement* source = (SgParameterStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgParameterStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgParameterStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgParameterStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgParameterStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23431 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23444 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceDeclarationStatementStorageClass::pickOutIRNodeData ( SgNamespaceDeclarationStatement* pointer ) 
   { 
     SgNamespaceDeclarationStatement* source = (SgNamespaceDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_isUnnamedNamespace =  source->p_isUnnamedNamespace ;
     storageOf_isInlinedNamespace =  source->p_isInlinedNamespace ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNamespaceDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23554 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEquivalenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23567 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEquivalenceStatementStorageClass::pickOutIRNodeData ( SgEquivalenceStatement* pointer ) 
   { 
     SgEquivalenceStatement* source = (SgEquivalenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_equivalence_set_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_equivalence_set_list );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEquivalenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEquivalenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEquivalenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEquivalenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23670 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23683 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceStatementStorageClass::pickOutIRNodeData ( SgInterfaceStatement* pointer ) 
   { 
     SgInterfaceStatement* source = (SgInterfaceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_generic_spec =  source->p_generic_spec ;
     SgInterfaceBodyPtrList::iterator i_interface_body_list = source->p_interface_body_list.begin() ; 
     unsigned int tempListCountinterface_body_list = 0; 
     SgInterfaceBodyPtrList::value_type *  tempListinterface_body_list = new SgInterfaceBodyPtrList::value_type[ source->p_interface_body_list.size() ]; 
     for ( ; i_interface_body_list != source->p_interface_body_list.end(); ++i_interface_body_list ) 
        {
          tempListinterface_body_list[tempListCountinterface_body_list] = *i_interface_body_list;
          tempListCountinterface_body_list++; 
          (*i_interface_body_list) = (SgInterfaceBodyPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_interface_body_list ) );
        }
     storageOf_interface_body_list.storeDataInEasyStorageClass(source->p_interface_body_list);
     tempListCountinterface_body_list = 0; 
     i_interface_body_list = source->p_interface_body_list.begin() ; 
     for ( ; i_interface_body_list != source->p_interface_body_list.end(); ++i_interface_body_list ) 
        {
          *i_interface_body_list = tempListinterface_body_list[tempListCountinterface_body_list] ;
          tempListCountinterface_body_list++; 
        }
      delete [] tempListinterface_body_list; 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgInterfaceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgInterfaceBodyPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgInterfaceBodyPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgInterfaceBodyPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgInterfaceBodyPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23814 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceAliasDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23827 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceAliasDeclarationStatementStorageClass::pickOutIRNodeData ( SgNamespaceAliasDeclarationStatement* pointer ) 
   { 
     SgNamespaceAliasDeclarationStatement* source = (SgNamespaceAliasDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_is_alias_for_another_namespace_alias =  source->p_is_alias_for_another_namespace_alias ;
     storageOf_namespaceAliasDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceAliasDeclaration );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceAliasDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceAliasDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 23940 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 23953 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCommonBlockStorageClass::pickOutIRNodeData ( SgCommonBlock* pointer ) 
   { 
     SgCommonBlock* source = (SgCommonBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgCommonBlockObjectPtrList::iterator i_block_list = source->p_block_list.begin() ; 
     unsigned int tempListCountblock_list = 0; 
     SgCommonBlockObjectPtrList::value_type *  tempListblock_list = new SgCommonBlockObjectPtrList::value_type[ source->p_block_list.size() ]; 
     for ( ; i_block_list != source->p_block_list.end(); ++i_block_list ) 
        {
          tempListblock_list[tempListCountblock_list] = *i_block_list;
          tempListCountblock_list++; 
          (*i_block_list) = (SgCommonBlockObjectPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_block_list ) );
        }
     storageOf_block_list.storeDataInEasyStorageClass(source->p_block_list);
     tempListCountblock_list = 0; 
     i_block_list = source->p_block_list.begin() ; 
     for ( ; i_block_list != source->p_block_list.end(); ++i_block_list ) 
        {
          *i_block_list = tempListblock_list[tempListCountblock_list] ;
          tempListCountblock_list++; 
        }
      delete [] tempListblock_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCommonBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCommonBlockObjectPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCommonBlockObjectPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCommonBlockObjectPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCommonBlockObjectPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24077 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24090 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefDeclarationStorageClass::pickOutIRNodeData ( SgTypedefDeclaration* pointer ) 
   { 
     SgTypedefDeclaration* source = (SgTypedefDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_typedefBaseTypeContainsDefiningDeclaration =  source->p_typedefBaseTypeContainsDefiningDeclaration ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_name_qualification_length_for_base_type =  source->p_name_qualification_length_for_base_type ;
     storageOf_type_elaboration_required_for_base_type =  source->p_type_elaboration_required_for_base_type ;
     storageOf_global_qualification_required_for_base_type =  source->p_global_qualification_required_for_base_type ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isAssociatedWithDeclarationList =  source->p_isAssociatedWithDeclarationList ;
     storageOf_isFirstDeclarationOfDeclarationList =  source->p_isFirstDeclarationOfDeclarationList ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypedefDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24213 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateTypedefDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24226 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateTypedefDeclarationStorageClass::pickOutIRNodeData ( SgTemplateTypedefDeclaration* pointer ) 
   { 
     SgTemplateTypedefDeclaration* source = (SgTemplateTypedefDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     SgTemplateArgumentPtrList::iterator i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     unsigned int tempListCounttemplateSpecializationArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateSpecializationArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateSpecializationArguments.size() ]; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] = *i_templateSpecializationArguments;
          tempListCounttemplateSpecializationArguments++; 
          (*i_templateSpecializationArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateSpecializationArguments ) );
        }
     storageOf_templateSpecializationArguments.storeDataInEasyStorageClass(source->p_templateSpecializationArguments);
     tempListCounttemplateSpecializationArguments = 0; 
     i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          *i_templateSpecializationArguments = tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] ;
          tempListCounttemplateSpecializationArguments++; 
        }
      delete [] tempListtemplateSpecializationArguments; 
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_nonreal_decl_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_decl_scope );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_typedefBaseTypeContainsDefiningDeclaration =  source->p_typedefBaseTypeContainsDefiningDeclaration ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_name_qualification_length_for_base_type =  source->p_name_qualification_length_for_base_type ;
     storageOf_type_elaboration_required_for_base_type =  source->p_type_elaboration_required_for_base_type ;
     storageOf_global_qualification_required_for_base_type =  source->p_global_qualification_required_for_base_type ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isAssociatedWithDeclarationList =  source->p_isAssociatedWithDeclarationList ;
     storageOf_isFirstDeclarationOfDeclarationList =  source->p_isFirstDeclarationOfDeclarationList ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateTypedefDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateTypedefDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateTypedefDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateTypedefDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24395 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationTypedefDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24408 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationTypedefDeclarationStorageClass::pickOutIRNodeData ( SgTemplateInstantiationTypedefDeclaration* pointer ) 
   { 
     SgTemplateInstantiationTypedefDeclaration* source = (SgTemplateInstantiationTypedefDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateHeader.pickOutIRNodeData( &(source->p_templateHeader) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_base_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_base_type );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_parent_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent_scope );
     storageOf_typedefBaseTypeContainsDefiningDeclaration =  source->p_typedefBaseTypeContainsDefiningDeclaration ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_name_qualification_length_for_base_type =  source->p_name_qualification_length_for_base_type ;
     storageOf_type_elaboration_required_for_base_type =  source->p_type_elaboration_required_for_base_type ;
     storageOf_global_qualification_required_for_base_type =  source->p_global_qualification_required_for_base_type ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isAssociatedWithDeclarationList =  source->p_isAssociatedWithDeclarationList ;
     storageOf_isFirstDeclarationOfDeclarationList =  source->p_isFirstDeclarationOfDeclarationList ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateInstantiationTypedefDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationTypedefDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationTypedefDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationTypedefDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24557 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementFunctionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24570 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStatementFunctionStatementStorageClass::pickOutIRNodeData ( SgStatementFunctionStatement* pointer ) 
   { 
     SgStatementFunctionStatement* source = (SgStatementFunctionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStatementFunctionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementFunctionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementFunctionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementFunctionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24674 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCtorInitializerListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24687 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCtorInitializerListStorageClass::pickOutIRNodeData ( SgCtorInitializerList* pointer ) 
   { 
     SgCtorInitializerList* source = (SgCtorInitializerList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgInitializedNamePtrList::iterator i_ctors = source->p_ctors.begin() ; 
     unsigned int tempListCountctors = 0; 
     SgInitializedNamePtrList::value_type *  tempListctors = new SgInitializedNamePtrList::value_type[ source->p_ctors.size() ]; 
     for ( ; i_ctors != source->p_ctors.end(); ++i_ctors ) 
        {
          tempListctors[tempListCountctors] = *i_ctors;
          tempListCountctors++; 
          (*i_ctors) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_ctors ) );
        }
     storageOf_ctors.storeDataInEasyStorageClass(source->p_ctors);
     tempListCountctors = 0; 
     i_ctors = source->p_ctors.begin() ; 
     for ( ; i_ctors != source->p_ctors.end(); ++i_ctors ) 
        {
          *i_ctors = tempListctors[tempListCountctors] ;
          tempListCountctors++; 
        }
      delete [] tempListctors; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCtorInitializerListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCtorInitializerListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCtorInitializerListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCtorInitializerListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24811 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPragmaDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24824 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPragmaDeclarationStorageClass::pickOutIRNodeData ( SgPragmaDeclaration* pointer ) 
   { 
     SgPragmaDeclaration* source = (SgPragmaDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_pragma = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pragma );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPragmaDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPragmaDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPragmaDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPragmaDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 24927 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUsingDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 24940 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUsingDirectiveStatementStorageClass::pickOutIRNodeData ( SgUsingDirectiveStatement* pointer ) 
   { 
     SgUsingDirectiveStatement* source = (SgUsingDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_namespaceDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namespaceDeclaration );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUsingDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUsingDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUsingDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUsingDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25046 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25059 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClassDeclarationStorageClass::pickOutIRNodeData ( SgClassDeclaration* pointer ) 
   { 
     SgClassDeclaration* source = (SgClassDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_annotation_interface =  source->p_explicit_annotation_interface ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_explicit_enum =  source->p_explicit_enum ;
     storageOf_explicit_anonymous =  source->p_explicit_anonymous ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isRepresentingTemplateParameterInTemplateDeclaration =  source->p_isRepresentingTemplateParameterInTemplateDeclaration ;
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClassDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25185 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateClassDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25198 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateClassDeclarationStorageClass::pickOutIRNodeData ( SgTemplateClassDeclaration* pointer ) 
   { 
     SgTemplateClassDeclaration* source = (SgTemplateClassDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     SgTemplateArgumentPtrList::iterator i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     unsigned int tempListCounttemplateSpecializationArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateSpecializationArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateSpecializationArguments.size() ]; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] = *i_templateSpecializationArguments;
          tempListCounttemplateSpecializationArguments++; 
          (*i_templateSpecializationArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateSpecializationArguments ) );
        }
     storageOf_templateSpecializationArguments.storeDataInEasyStorageClass(source->p_templateSpecializationArguments);
     tempListCounttemplateSpecializationArguments = 0; 
     i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          *i_templateSpecializationArguments = tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] ;
          tempListCounttemplateSpecializationArguments++; 
        }
      delete [] tempListtemplateSpecializationArguments; 
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_nonreal_decl_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_decl_scope );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_annotation_interface =  source->p_explicit_annotation_interface ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_explicit_enum =  source->p_explicit_enum ;
     storageOf_explicit_anonymous =  source->p_explicit_anonymous ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isRepresentingTemplateParameterInTemplateDeclaration =  source->p_isRepresentingTemplateParameterInTemplateDeclaration ;
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateClassDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateClassDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateClassDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateClassDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25371 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25384 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationDecl* pointer ) 
   { 
     SgTemplateInstantiationDecl* source = (SgTemplateInstantiationDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateHeader.pickOutIRNodeData( &(source->p_templateHeader) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_annotation_interface =  source->p_explicit_annotation_interface ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_explicit_enum =  source->p_explicit_enum ;
     storageOf_explicit_anonymous =  source->p_explicit_anonymous ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isRepresentingTemplateParameterInTemplateDeclaration =  source->p_isRepresentingTemplateParameterInTemplateDeclaration ;
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateInstantiationDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25536 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDerivedTypeStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25549 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDerivedTypeStatementStorageClass::pickOutIRNodeData ( SgDerivedTypeStatement* pointer ) 
   { 
     SgDerivedTypeStatement* source = (SgDerivedTypeStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_annotation_interface =  source->p_explicit_annotation_interface ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_explicit_enum =  source->p_explicit_enum ;
     storageOf_explicit_anonymous =  source->p_explicit_anonymous ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isRepresentingTemplateParameterInTemplateDeclaration =  source->p_isRepresentingTemplateParameterInTemplateDeclaration ;
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDerivedTypeStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDerivedTypeStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDerivedTypeStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDerivedTypeStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25676 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModuleStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25689 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgModuleStatementStorageClass::pickOutIRNodeData ( SgModuleStatement* pointer ) 
   { 
     SgModuleStatement* source = (SgModuleStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_annotation_interface =  source->p_explicit_annotation_interface ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_explicit_enum =  source->p_explicit_enum ;
     storageOf_explicit_anonymous =  source->p_explicit_anonymous ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isRepresentingTemplateParameterInTemplateDeclaration =  source->p_isRepresentingTemplateParameterInTemplateDeclaration ;
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgModuleStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModuleStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModuleStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModuleStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25816 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaPackageDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25829 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaPackageDeclarationStorageClass::pickOutIRNodeData ( SgJavaPackageDeclaration* pointer ) 
   { 
     SgJavaPackageDeclaration* source = (SgJavaPackageDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_annotation_interface =  source->p_explicit_annotation_interface ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_explicit_enum =  source->p_explicit_enum ;
     storageOf_explicit_anonymous =  source->p_explicit_anonymous ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isRepresentingTemplateParameterInTemplateDeclaration =  source->p_isRepresentingTemplateParameterInTemplateDeclaration ;
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaPackageDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaPackageDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaPackageDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaPackageDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 25955 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialTableStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 25968 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialTableStatementStorageClass::pickOutIRNodeData ( SgJovialTableStatement* pointer ) 
   { 
     SgJovialTableStatement* source = (SgJovialTableStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_table_entry_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_table_entry_size );
     storageOf_has_table_entry_size =  source->p_has_table_entry_size ;
     storageOf_words_per_entry =  source->p_words_per_entry ;
     storageOf_like_table_name.storeDataInEasyStorageClass(source->p_like_table_name);
     storageOf_has_like_option =  source->p_has_like_option ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_class_type =  source->p_class_type ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_from_template =  source->p_from_template ;
     storageOf_fixupScope =  source->p_fixupScope ;
     storageOf_isUnNamed =  source->p_isUnNamed ;
     storageOf_explicit_annotation_interface =  source->p_explicit_annotation_interface ;
     storageOf_explicit_interface =  source->p_explicit_interface ;
     storageOf_explicit_enum =  source->p_explicit_enum ;
     storageOf_explicit_anonymous =  source->p_explicit_anonymous ;
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_isAutonomousDeclaration =  source->p_isAutonomousDeclaration ;
     storageOf_isRepresentingTemplateParameterInTemplateDeclaration =  source->p_isRepresentingTemplateParameterInTemplateDeclaration ;
     storageOf_adaParentType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaParentType );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialTableStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialTableStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialTableStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialTableStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26099 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImplicitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26112 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgImplicitStatementStorageClass::pickOutIRNodeData ( SgImplicitStatement* pointer ) 
   { 
     SgImplicitStatement* source = (SgImplicitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_implicit_none =  source->p_implicit_none ;
     storageOf_implicit_spec =  source->p_implicit_spec ;
     SgInitializedNamePtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgInitializedNamePtrList::value_type *  tempListvariables = new SgInitializedNamePtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgImplicitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImplicitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImplicitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImplicitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26238 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUsingDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26251 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUsingDeclarationStatementStorageClass::pickOutIRNodeData ( SgUsingDeclarationStatement* pointer ) 
   { 
     SgUsingDeclarationStatement* source = (SgUsingDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_initializedName = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializedName );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_is_inheriting_constructor =  source->p_is_inheriting_constructor ;
     storageOf_adaTypeAttribute.pickOutIRNodeData( &(source->p_adaTypeAttribute) );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUsingDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUsingDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUsingDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUsingDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26364 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamelistStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26377 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNamelistStatementStorageClass::pickOutIRNodeData ( SgNamelistStatement* pointer ) 
   { 
     SgNamelistStatement* source = (SgNamelistStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgNameGroupPtrList::iterator i_group_list = source->p_group_list.begin() ; 
     unsigned int tempListCountgroup_list = 0; 
     SgNameGroupPtrList::value_type *  tempListgroup_list = new SgNameGroupPtrList::value_type[ source->p_group_list.size() ]; 
     for ( ; i_group_list != source->p_group_list.end(); ++i_group_list ) 
        {
          tempListgroup_list[tempListCountgroup_list] = *i_group_list;
          tempListCountgroup_list++; 
          (*i_group_list) = (SgNameGroupPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_group_list ) );
        }
     storageOf_group_list.storeDataInEasyStorageClass(source->p_group_list);
     tempListCountgroup_list = 0; 
     i_group_list = source->p_group_list.begin() ; 
     for ( ; i_group_list != source->p_group_list.end(); ++i_group_list ) 
        {
          *i_group_list = tempListgroup_list[tempListCountgroup_list] ;
          tempListCountgroup_list++; 
        }
      delete [] tempListgroup_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNamelistStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgNameGroupPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamelistStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgNameGroupPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamelistStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgNameGroupPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamelistStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgNameGroupPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26501 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImportStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26514 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgImportStatementStorageClass::pickOutIRNodeData ( SgImportStatement* pointer ) 
   { 
     SgImportStatement* source = (SgImportStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_import_list = source->p_import_list.begin() ; 
     unsigned int tempListCountimport_list = 0; 
     SgExpressionPtrList::value_type *  tempListimport_list = new SgExpressionPtrList::value_type[ source->p_import_list.size() ]; 
     for ( ; i_import_list != source->p_import_list.end(); ++i_import_list ) 
        {
          tempListimport_list[tempListCountimport_list] = *i_import_list;
          tempListCountimport_list++; 
          (*i_import_list) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_import_list ) );
        }
     storageOf_import_list.storeDataInEasyStorageClass(source->p_import_list);
     tempListCountimport_list = 0; 
     i_import_list = source->p_import_list.begin() ; 
     for ( ; i_import_list != source->p_import_list.end(); ++i_import_list ) 
        {
          *i_import_list = tempListimport_list[tempListCountimport_list] ;
          tempListCountimport_list++; 
        }
      delete [] tempListimport_list; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgImportStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImportStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImportStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImportStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26638 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26651 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionDeclarationStorageClass::pickOutIRNodeData ( SgFunctionDeclaration* pointer ) 
   { 
     SgFunctionDeclaration* source = (SgFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 26822 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 26835 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateFunctionDeclarationStorageClass::pickOutIRNodeData ( SgTemplateFunctionDeclaration* pointer ) 
   { 
     SgTemplateFunctionDeclaration* source = (SgTemplateFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     SgTemplateArgumentPtrList::iterator i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     unsigned int tempListCounttemplateSpecializationArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateSpecializationArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateSpecializationArguments.size() ]; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] = *i_templateSpecializationArguments;
          tempListCounttemplateSpecializationArguments++; 
          (*i_templateSpecializationArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateSpecializationArguments ) );
        }
     storageOf_templateSpecializationArguments.storeDataInEasyStorageClass(source->p_templateSpecializationArguments);
     tempListCounttemplateSpecializationArguments = 0; 
     i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          *i_templateSpecializationArguments = tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] ;
          tempListCounttemplateSpecializationArguments++; 
        }
      delete [] tempListtemplateSpecializationArguments; 
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_string_represents_function_body =  source->p_string_represents_function_body ;
     storageOf_nonreal_decl_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_decl_scope );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27053 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27066 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionDeclarationStorageClass::pickOutIRNodeData ( SgMemberFunctionDeclaration* pointer ) 
   { 
     SgMemberFunctionDeclaration* source = (SgMemberFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_CtorInitializerList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CtorInitializerList );
     storageOf_associatedClassDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedClassDeclaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMemberFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27239 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateMemberFunctionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27252 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateMemberFunctionDeclarationStorageClass::pickOutIRNodeData ( SgTemplateMemberFunctionDeclaration* pointer ) 
   { 
     SgTemplateMemberFunctionDeclaration* source = (SgTemplateMemberFunctionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgTemplateParameterPtrList::iterator i_templateParameters = source->p_templateParameters.begin() ; 
     unsigned int tempListCounttemplateParameters = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtemplateParameters = new SgTemplateParameterPtrList::value_type[ source->p_templateParameters.size() ]; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          tempListtemplateParameters[tempListCounttemplateParameters] = *i_templateParameters;
          tempListCounttemplateParameters++; 
          (*i_templateParameters) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateParameters ) );
        }
     storageOf_templateParameters.storeDataInEasyStorageClass(source->p_templateParameters);
     tempListCounttemplateParameters = 0; 
     i_templateParameters = source->p_templateParameters.begin() ; 
     for ( ; i_templateParameters != source->p_templateParameters.end(); ++i_templateParameters ) 
        {
          *i_templateParameters = tempListtemplateParameters[tempListCounttemplateParameters] ;
          tempListCounttemplateParameters++; 
        }
      delete [] tempListtemplateParameters; 
     SgTemplateArgumentPtrList::iterator i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     unsigned int tempListCounttemplateSpecializationArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateSpecializationArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateSpecializationArguments.size() ]; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] = *i_templateSpecializationArguments;
          tempListCounttemplateSpecializationArguments++; 
          (*i_templateSpecializationArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateSpecializationArguments ) );
        }
     storageOf_templateSpecializationArguments.storeDataInEasyStorageClass(source->p_templateSpecializationArguments);
     tempListCounttemplateSpecializationArguments = 0; 
     i_templateSpecializationArguments = source->p_templateSpecializationArguments.begin() ; 
     for ( ; i_templateSpecializationArguments != source->p_templateSpecializationArguments.end(); ++i_templateSpecializationArguments ) 
        {
          *i_templateSpecializationArguments = tempListtemplateSpecializationArguments[tempListCounttemplateSpecializationArguments] ;
          tempListCounttemplateSpecializationArguments++; 
        }
      delete [] tempListtemplateSpecializationArguments; 
     storageOf_string.pickOutIRNodeData( &(source->p_string) );
     storageOf_string_represents_function_body =  source->p_string_represents_function_body ;
     storageOf_nonreal_decl_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_decl_scope );
     storageOf_CtorInitializerList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CtorInitializerList );
     storageOf_associatedClassDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedClassDeclaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateMemberFunctionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateMemberFunctionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateMemberFunctionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateMemberFunctionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27472 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationMemberFunctionDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27485 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationMemberFunctionDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationMemberFunctionDecl* pointer ) 
   { 
     SgTemplateInstantiationMemberFunctionDecl* source = (SgTemplateInstantiationMemberFunctionDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_template_argument_list_is_explicit =  source->p_template_argument_list_is_explicit ;
     storageOf_CtorInitializerList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CtorInitializerList );
     storageOf_associatedClassDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedClassDeclaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationMemberFunctionDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationMemberFunctionDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27684 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateInstantiationFunctionDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27697 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateInstantiationFunctionDeclStorageClass::pickOutIRNodeData ( SgTemplateInstantiationFunctionDecl* pointer ) 
   { 
     SgTemplateInstantiationFunctionDecl* source = (SgTemplateInstantiationFunctionDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_templateName.pickOutIRNodeData( &(source->p_templateName) );
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_templateArguments = source->p_templateArguments.begin() ; 
     unsigned int tempListCounttemplateArguments = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtemplateArguments = new SgTemplateArgumentPtrList::value_type[ source->p_templateArguments.size() ]; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          tempListtemplateArguments[tempListCounttemplateArguments] = *i_templateArguments;
          tempListCounttemplateArguments++; 
          (*i_templateArguments) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_templateArguments ) );
        }
     storageOf_templateArguments.storeDataInEasyStorageClass(source->p_templateArguments);
     tempListCounttemplateArguments = 0; 
     i_templateArguments = source->p_templateArguments.begin() ; 
     for ( ; i_templateArguments != source->p_templateArguments.end(); ++i_templateArguments ) 
        {
          *i_templateArguments = tempListtemplateArguments[tempListCounttemplateArguments] ;
          tempListCounttemplateArguments++; 
        }
      delete [] tempListtemplateArguments; 
     storageOf_nameResetFromMangledForm =  source->p_nameResetFromMangledForm ;
     storageOf_template_argument_list_is_explicit =  source->p_template_argument_list_is_explicit ;
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateInstantiationFunctionDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateInstantiationFunctionDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 27894 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProgramHeaderStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 27907 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgProgramHeaderStatementStorageClass::pickOutIRNodeData ( SgProgramHeaderStatement* pointer ) 
   { 
     SgProgramHeaderStatement* source = (SgProgramHeaderStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_program_statement_explicit =  source->p_program_statement_explicit ;
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgProgramHeaderStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProgramHeaderStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProgramHeaderStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProgramHeaderStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28080 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProcedureHeaderStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28093 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgProcedureHeaderStatementStorageClass::pickOutIRNodeData ( SgProcedureHeaderStatement* pointer ) 
   { 
     SgProcedureHeaderStatement* source = (SgProcedureHeaderStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_subprogram_kind =  source->p_subprogram_kind ;
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_result_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_result_name );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgProcedureHeaderStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProcedureHeaderStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProcedureHeaderStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProcedureHeaderStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28267 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEntryStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28280 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEntryStatementStorageClass::pickOutIRNodeData ( SgEntryStatement* pointer ) 
   { 
     SgEntryStatement* source = (SgEntryStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_result_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_result_name );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEntryStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEntryStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEntryStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEntryStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28452 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaEntryDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28465 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaEntryDeclStorageClass::pickOutIRNodeData ( SgAdaEntryDecl* pointer ) 
   { 
     SgAdaEntryDecl* source = (SgAdaEntryDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_entryIndex = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entryIndex );
     storageOf_entryBarrier = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entryBarrier );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaEntryDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaEntryDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaEntryDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaEntryDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28638 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaFunctionRenamingDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28651 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaFunctionRenamingDeclStorageClass::pickOutIRNodeData ( SgAdaFunctionRenamingDecl* pointer ) 
   { 
     SgAdaFunctionRenamingDecl* source = (SgAdaFunctionRenamingDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_renamed_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_renamed_function );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_parameterList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList );
     storageOf_functionModifier.pickOutIRNodeData( &(source->p_functionModifier) );
     storageOf_specialFunctionModifier.pickOutIRNodeData( &(source->p_specialFunctionModifier) );
     SgTypePtrList::iterator i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     unsigned int tempListCountexceptionSpecification = 0; 
     SgTypePtrList::value_type *  tempListexceptionSpecification = new SgTypePtrList::value_type[ source->p_exceptionSpecification.size() ]; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          tempListexceptionSpecification[tempListCountexceptionSpecification] = *i_exceptionSpecification;
          tempListCountexceptionSpecification++; 
          (*i_exceptionSpecification) = (SgTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exceptionSpecification ) );
        }
     storageOf_exceptionSpecification.storeDataInEasyStorageClass(source->p_exceptionSpecification);
     tempListCountexceptionSpecification = 0; 
     i_exceptionSpecification = source->p_exceptionSpecification.begin() ; 
     for ( ; i_exceptionSpecification != source->p_exceptionSpecification.end(); ++i_exceptionSpecification ) 
        {
          *i_exceptionSpecification = tempListexceptionSpecification[tempListCountexceptionSpecification] ;
          tempListCountexceptionSpecification++; 
        }
      delete [] tempListexceptionSpecification; 
     storageOf_named_in_end_statement =  source->p_named_in_end_statement ;
     storageOf_asm_name.storeDataInEasyStorageClass(source->p_asm_name);
     storageOf_decoratorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decoratorList );
     storageOf_ada_formal_subprogram_decl =  source->p_ada_formal_subprogram_decl ;
     storageOf_ada_formal_decl_with_box =  source->p_ada_formal_decl_with_box ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_oldStyleDefinition =  source->p_oldStyleDefinition ;
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_specialization =  source->p_specialization ;
     storageOf_requiresNameQualificationOnReturnType =  source->p_requiresNameQualificationOnReturnType ;
     storageOf_gnu_extension_section.storeDataInEasyStorageClass(source->p_gnu_extension_section);
     storageOf_gnu_extension_alias.storeDataInEasyStorageClass(source->p_gnu_extension_alias);
     storageOf_gnu_extension_visability =  source->p_gnu_extension_visability ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_length_for_return_type =  source->p_name_qualification_length_for_return_type ;
     storageOf_type_elaboration_required_for_return_type =  source->p_type_elaboration_required_for_return_type ;
     storageOf_global_qualification_required_for_return_type =  source->p_global_qualification_required_for_return_type ;
     storageOf_prototypeIsWithoutParameters =  source->p_prototypeIsWithoutParameters ;
     storageOf_gnu_regparm_attribute =  source->p_gnu_regparm_attribute ;
     storageOf_type_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_syntax );
     storageOf_type_syntax_is_available =  source->p_type_syntax_is_available ;
     storageOf_parameterList_syntax = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameterList_syntax );
     storageOf_using_C11_Noreturn_keyword =  source->p_using_C11_Noreturn_keyword ;
     storageOf_is_constexpr =  source->p_is_constexpr ;
     storageOf_using_new_function_return_type_syntax =  source->p_using_new_function_return_type_syntax ;
     storageOf_functionParameterScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionParameterScope );
     storageOf_marked_as_edg_normalization =  source->p_marked_as_edg_normalization ;
     storageOf_is_implicit_function =  source->p_is_implicit_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaFunctionRenamingDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     SgSpecialFunctionModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaFunctionRenamingDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     SgSpecialFunctionModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTypePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaFunctionRenamingDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     SgFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     SgSpecialFunctionModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTypePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaFunctionRenamingDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     SgFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     SgSpecialFunctionModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTypePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28823 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgContainsStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28836 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgContainsStatementStorageClass::pickOutIRNodeData ( SgContainsStatement* pointer ) 
   { 
     SgContainsStatement* source = (SgContainsStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgContainsStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgContainsStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgContainsStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgContainsStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 28938 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgC_PreprocessorDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 28951 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgC_PreprocessorDirectiveStatementStorageClass::pickOutIRNodeData ( SgC_PreprocessorDirectiveStatement* pointer ) 
   { 
     SgC_PreprocessorDirectiveStatement* source = (SgC_PreprocessorDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgC_PreprocessorDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgC_PreprocessorDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29054 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncludeDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29067 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIncludeDirectiveStatementStorageClass::pickOutIRNodeData ( SgIncludeDirectiveStatement* pointer ) 
   { 
     SgIncludeDirectiveStatement* source = (SgIncludeDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_headerFileBody = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headerFileBody );
     storageOf_include_file_heirarchy = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_include_file_heirarchy );
     storageOf_name_used_in_include_directive.storeDataInEasyStorageClass(source->p_name_used_in_include_directive);
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIncludeDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncludeDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIncludeDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIncludeDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29173 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefineDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDefineDirectiveStatementStorageClass::pickOutIRNodeData ( SgDefineDirectiveStatement* pointer ) 
   { 
     SgDefineDirectiveStatement* source = (SgDefineDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDefineDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefineDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefineDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefineDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29289 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUndefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29302 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUndefDirectiveStatementStorageClass::pickOutIRNodeData ( SgUndefDirectiveStatement* pointer ) 
   { 
     SgUndefDirectiveStatement* source = (SgUndefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUndefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUndefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUndefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUndefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29405 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfdefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29418 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIfdefDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfdefDirectiveStatement* pointer ) 
   { 
     SgIfdefDirectiveStatement* source = (SgIfdefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIfdefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfdefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfdefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfdefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29521 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfndefDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29534 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIfndefDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfndefDirectiveStatement* pointer ) 
   { 
     SgIfndefDirectiveStatement* source = (SgIfndefDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIfndefDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfndefDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfndefDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfndefDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29637 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIfDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29650 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIfDirectiveStatementStorageClass::pickOutIRNodeData ( SgIfDirectiveStatement* pointer ) 
   { 
     SgIfDirectiveStatement* source = (SgIfDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIfDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIfDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIfDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIfDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29753 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeadIfDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29766 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDeadIfDirectiveStatementStorageClass::pickOutIRNodeData ( SgDeadIfDirectiveStatement* pointer ) 
   { 
     SgDeadIfDirectiveStatement* source = (SgDeadIfDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDeadIfDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeadIfDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeadIfDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeadIfDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29869 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29882 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElseDirectiveStatementStorageClass::pickOutIRNodeData ( SgElseDirectiveStatement* pointer ) 
   { 
     SgElseDirectiveStatement* source = (SgElseDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElseDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 29985 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseifDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 29998 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElseifDirectiveStatementStorageClass::pickOutIRNodeData ( SgElseifDirectiveStatement* pointer ) 
   { 
     SgElseifDirectiveStatement* source = (SgElseifDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElseifDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseifDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseifDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseifDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30101 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEndifDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30114 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEndifDirectiveStatementStorageClass::pickOutIRNodeData ( SgEndifDirectiveStatement* pointer ) 
   { 
     SgEndifDirectiveStatement* source = (SgEndifDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEndifDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEndifDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEndifDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEndifDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30217 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLineDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30230 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLineDirectiveStatementStorageClass::pickOutIRNodeData ( SgLineDirectiveStatement* pointer ) 
   { 
     SgLineDirectiveStatement* source = (SgLineDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLineDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLineDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLineDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLineDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30333 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWarningDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30346 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWarningDirectiveStatementStorageClass::pickOutIRNodeData ( SgWarningDirectiveStatement* pointer ) 
   { 
     SgWarningDirectiveStatement* source = (SgWarningDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWarningDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWarningDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWarningDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWarningDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30449 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgErrorDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30462 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgErrorDirectiveStatementStorageClass::pickOutIRNodeData ( SgErrorDirectiveStatement* pointer ) 
   { 
     SgErrorDirectiveStatement* source = (SgErrorDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgErrorDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgErrorDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgErrorDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgErrorDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30565 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEmptyDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30578 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEmptyDirectiveStatementStorageClass::pickOutIRNodeData ( SgEmptyDirectiveStatement* pointer ) 
   { 
     SgEmptyDirectiveStatement* source = (SgEmptyDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEmptyDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEmptyDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEmptyDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEmptyDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30681 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIncludeNextDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30694 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIncludeNextDirectiveStatementStorageClass::pickOutIRNodeData ( SgIncludeNextDirectiveStatement* pointer ) 
   { 
     SgIncludeNextDirectiveStatement* source = (SgIncludeNextDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIncludeNextDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIncludeNextDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30797 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIdentDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30810 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIdentDirectiveStatementStorageClass::pickOutIRNodeData ( SgIdentDirectiveStatement* pointer ) 
   { 
     SgIdentDirectiveStatement* source = (SgIdentDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIdentDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIdentDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIdentDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIdentDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 30913 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLinemarkerDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 30926 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLinemarkerDirectiveStatementStorageClass::pickOutIRNodeData ( SgLinemarkerDirectiveStatement* pointer ) 
   { 
     SgLinemarkerDirectiveStatement* source = (SgLinemarkerDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_linenumber =  source->p_linenumber ;
     storageOf_filename.storeDataInEasyStorageClass(source->p_filename);
     storageOf_flaglist.storeDataInEasyStorageClass(source->p_flaglist);
     storageOf_directiveString.storeDataInEasyStorageClass(source->p_directiveString);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLinemarkerDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLinemarkerDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31036 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpThreadprivateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31049 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpThreadprivateStatementStorageClass::pickOutIRNodeData ( SgOmpThreadprivateStatement* pointer ) 
   { 
     SgOmpThreadprivateStatement* source = (SgOmpThreadprivateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpThreadprivateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpThreadprivateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpThreadprivateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpThreadprivateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31173 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranIncludeLineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFortranIncludeLineStorageClass::pickOutIRNodeData ( SgFortranIncludeLine* pointer ) 
   { 
     SgFortranIncludeLine* source = (SgFortranIncludeLine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_filename.storeDataInEasyStorageClass(source->p_filename);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFortranIncludeLineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranIncludeLineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranIncludeLineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranIncludeLineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31289 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaImportStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31302 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaImportStatementStorageClass::pickOutIRNodeData ( SgJavaImportStatement* pointer ) 
   { 
     SgJavaImportStatement* source = (SgJavaImportStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_path.pickOutIRNodeData( &(source->p_path) );
     storageOf_containsWildCard =  source->p_containsWildCard ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaImportStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaImportStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaImportStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaImportStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31410 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaPackageStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31423 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaPackageStatementStorageClass::pickOutIRNodeData ( SgJavaPackageStatement* pointer ) 
   { 
     SgJavaPackageStatement* source = (SgJavaPackageStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaPackageStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaPackageStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaPackageStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaPackageStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31530 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStmtDeclarationStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31543 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStmtDeclarationStatementStorageClass::pickOutIRNodeData ( SgStmtDeclarationStatement* pointer ) 
   { 
     SgStmtDeclarationStatement* source = (SgStmtDeclarationStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStmtDeclarationStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStmtDeclarationStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStmtDeclarationStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStmtDeclarationStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31646 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStaticAssertionDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31659 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStaticAssertionDeclarationStorageClass::pickOutIRNodeData ( SgStaticAssertionDeclaration* pointer ) 
   { 
     SgStaticAssertionDeclaration* source = (SgStaticAssertionDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_string_literal.pickOutIRNodeData( &(source->p_string_literal) );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStaticAssertionDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStaticAssertionDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStaticAssertionDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStaticAssertionDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31767 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDeclareSimdStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31780 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDeclareSimdStatementStorageClass::pickOutIRNodeData ( SgOmpDeclareSimdStatement* pointer ) 
   { 
     SgOmpDeclareSimdStatement* source = (SgOmpDeclareSimdStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpDeclareSimdStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDeclareSimdStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDeclareSimdStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDeclareSimdStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 31904 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMicrosoftAttributeDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 31917 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMicrosoftAttributeDeclarationStorageClass::pickOutIRNodeData ( SgMicrosoftAttributeDeclaration* pointer ) 
   { 
     SgMicrosoftAttributeDeclaration* source = (SgMicrosoftAttributeDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attribute_string.pickOutIRNodeData( &(source->p_attribute_string) );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMicrosoftAttributeDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMicrosoftAttributeDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMicrosoftAttributeDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMicrosoftAttributeDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32024 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialCompoolStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32037 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialCompoolStatementStorageClass::pickOutIRNodeData ( SgJovialCompoolStatement* pointer ) 
   { 
     SgJovialCompoolStatement* source = (SgJovialCompoolStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialCompoolStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialCompoolStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialCompoolStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialCompoolStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32144 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialDirectiveStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32157 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialDirectiveStatementStorageClass::pickOutIRNodeData ( SgJovialDirectiveStatement* pointer ) 
   { 
     SgJovialDirectiveStatement* source = (SgJovialDirectiveStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_content_string.storeDataInEasyStorageClass(source->p_content_string);
     storageOf_directive_type =  source->p_directive_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialDirectiveStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialDirectiveStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialDirectiveStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialDirectiveStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32261 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialDefineDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32274 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialDefineDeclarationStorageClass::pickOutIRNodeData ( SgJovialDefineDeclaration* pointer ) 
   { 
     SgJovialDefineDeclaration* source = (SgJovialDefineDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_define_string.storeDataInEasyStorageClass(source->p_define_string);
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialDefineDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialDefineDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialDefineDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialDefineDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32377 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialLabelDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32390 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialLabelDeclarationStorageClass::pickOutIRNodeData ( SgJovialLabelDeclaration* pointer ) 
   { 
     SgJovialLabelDeclaration* source = (SgJovialLabelDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_label.storeDataInEasyStorageClass(source->p_label);
     storageOf_label_type =  source->p_label_type ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialLabelDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialLabelDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialLabelDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialLabelDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32494 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialOverlayDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32507 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialOverlayDeclarationStorageClass::pickOutIRNodeData ( SgJovialOverlayDeclaration* pointer ) 
   { 
     SgJovialOverlayDeclaration* source = (SgJovialOverlayDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_overlay = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_overlay );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialOverlayDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialOverlayDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialOverlayDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialOverlayDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32611 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNonrealDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32624 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNonrealDeclStorageClass::pickOutIRNodeData ( SgNonrealDecl* pointer ) 
   { 
     SgNonrealDecl* source = (SgNonrealDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_nonreal_decl_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_decl_scope );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_template_parameter_position =  source->p_template_parameter_position ;
     storageOf_template_parameter_depth =  source->p_template_parameter_depth ;
     storageOf_templateDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_templateDeclaration );
     SgTemplateArgumentPtrList::iterator i_tpl_args = source->p_tpl_args.begin() ; 
     unsigned int tempListCounttpl_args = 0; 
     SgTemplateArgumentPtrList::value_type *  tempListtpl_args = new SgTemplateArgumentPtrList::value_type[ source->p_tpl_args.size() ]; 
     for ( ; i_tpl_args != source->p_tpl_args.end(); ++i_tpl_args ) 
        {
          tempListtpl_args[tempListCounttpl_args] = *i_tpl_args;
          tempListCounttpl_args++; 
          (*i_tpl_args) = (SgTemplateArgumentPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_tpl_args ) );
        }
     storageOf_tpl_args.storeDataInEasyStorageClass(source->p_tpl_args);
     tempListCounttpl_args = 0; 
     i_tpl_args = source->p_tpl_args.begin() ; 
     for ( ; i_tpl_args != source->p_tpl_args.end(); ++i_tpl_args ) 
        {
          *i_tpl_args = tempListtpl_args[tempListCounttpl_args] ;
          tempListCounttpl_args++; 
        }
      delete [] tempListtpl_args; 
     SgTemplateParameterPtrList::iterator i_tpl_params = source->p_tpl_params.begin() ; 
     unsigned int tempListCounttpl_params = 0; 
     SgTemplateParameterPtrList::value_type *  tempListtpl_params = new SgTemplateParameterPtrList::value_type[ source->p_tpl_params.size() ]; 
     for ( ; i_tpl_params != source->p_tpl_params.end(); ++i_tpl_params ) 
        {
          tempListtpl_params[tempListCounttpl_params] = *i_tpl_params;
          tempListCounttpl_params++; 
          (*i_tpl_params) = (SgTemplateParameterPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_tpl_params ) );
        }
     storageOf_tpl_params.storeDataInEasyStorageClass(source->p_tpl_params);
     tempListCounttpl_params = 0; 
     i_tpl_params = source->p_tpl_params.begin() ; 
     for ( ; i_tpl_params != source->p_tpl_params.end(); ++i_tpl_params ) 
        {
          *i_tpl_params = tempListtpl_params[tempListCounttpl_params] ;
          tempListCounttpl_params++; 
        }
      delete [] tempListtpl_params; 
     storageOf_is_class_member =  source->p_is_class_member ;
     storageOf_is_template_param =  source->p_is_template_param ;
     storageOf_is_template_template_param =  source->p_is_template_template_param ;
     storageOf_is_nonreal_template =  source->p_is_nonreal_template ;
     storageOf_is_nonreal_function =  source->p_is_nonreal_function ;
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNonrealDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgTemplateArgumentPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgTemplateParameterPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNonrealDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgTemplateArgumentPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgTemplateParameterPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNonrealDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgTemplateArgumentPtrList > :: writeToFile(out) ;
     EasyStorage < SgTemplateParameterPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNonrealDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgTemplateArgumentPtrList > :: readFromFile(in) ;
     EasyStorage < SgTemplateParameterPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32785 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEmptyDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32798 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEmptyDeclarationStorageClass::pickOutIRNodeData ( SgEmptyDeclaration* pointer ) 
   { 
     SgEmptyDeclaration* source = (SgEmptyDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEmptyDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEmptyDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEmptyDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEmptyDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 32900 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaPackageBodyDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 32913 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaPackageBodyDeclStorageClass::pickOutIRNodeData ( SgAdaPackageBodyDecl* pointer ) 
   { 
     SgAdaPackageBodyDecl* source = (SgAdaPackageBodyDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_spec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_spec );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaPackageBodyDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaPackageBodyDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaPackageBodyDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaPackageBodyDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33023 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaPackageSpecDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33036 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaPackageSpecDeclStorageClass::pickOutIRNodeData ( SgAdaPackageSpecDecl* pointer ) 
   { 
     SgAdaPackageSpecDecl* source = (SgAdaPackageSpecDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaPackageSpecDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaPackageSpecDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaPackageSpecDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaPackageSpecDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33146 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaRenamingDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33159 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaRenamingDeclStorageClass::pickOutIRNodeData ( SgAdaRenamingDecl* pointer ) 
   { 
     SgAdaRenamingDecl* source = (SgAdaRenamingDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_renamed = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_renamed );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaRenamingDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaRenamingDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaRenamingDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaRenamingDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33268 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskSpecDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33281 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskSpecDeclStorageClass::pickOutIRNodeData ( SgAdaTaskSpecDecl* pointer ) 
   { 
     SgAdaTaskSpecDecl* source = (SgAdaTaskSpecDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskSpecDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskSpecDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskSpecDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskSpecDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33390 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskBodyDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33403 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskBodyDeclStorageClass::pickOutIRNodeData ( SgAdaTaskBodyDecl* pointer ) 
   { 
     SgAdaTaskBodyDecl* source = (SgAdaTaskBodyDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_specificationDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_specificationDeclaration );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskBodyDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskBodyDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskBodyDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskBodyDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33512 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskTypeDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33525 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskTypeDeclStorageClass::pickOutIRNodeData ( SgAdaTaskTypeDecl* pointer ) 
   { 
     SgAdaTaskTypeDecl* source = (SgAdaTaskTypeDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskTypeDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskTypeDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskTypeDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskTypeDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33635 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedSpecDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33648 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedSpecDeclStorageClass::pickOutIRNodeData ( SgAdaProtectedSpecDecl* pointer ) 
   { 
     SgAdaProtectedSpecDecl* source = (SgAdaProtectedSpecDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedSpecDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedSpecDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedSpecDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedSpecDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33757 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedBodyDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33770 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedBodyDeclStorageClass::pickOutIRNodeData ( SgAdaProtectedBodyDecl* pointer ) 
   { 
     SgAdaProtectedBodyDecl* source = (SgAdaProtectedBodyDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_specificationDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_specificationDeclaration );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedBodyDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedBodyDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedBodyDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedBodyDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 33879 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedTypeDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 33892 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedTypeDeclStorageClass::pickOutIRNodeData ( SgAdaProtectedTypeDecl* pointer ) 
   { 
     SgAdaProtectedTypeDecl* source = (SgAdaProtectedTypeDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedTypeDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedTypeDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedTypeDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedTypeDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34002 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaRepresentationClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34015 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaRepresentationClauseStorageClass::pickOutIRNodeData ( SgAdaRepresentationClause* pointer ) 
   { 
     SgAdaRepresentationClause* source = (SgAdaRepresentationClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_recordType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_recordType );
     storageOf_alignment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_alignment );
     storageOf_components = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_components );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaRepresentationClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaRepresentationClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaRepresentationClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaRepresentationClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34120 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaComponentClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34133 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaComponentClauseStorageClass::pickOutIRNodeData ( SgAdaComponentClause* pointer ) 
   { 
     SgAdaComponentClause* source = (SgAdaComponentClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_component = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_component );
     storageOf_offset = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_offset );
     storageOf_range = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_range );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaComponentClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaComponentClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaComponentClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaComponentClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34238 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaAttributeClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34251 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaAttributeClauseStorageClass::pickOutIRNodeData ( SgAdaAttributeClause* pointer ) 
   { 
     SgAdaAttributeClause* source = (SgAdaAttributeClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attribute = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_attribute );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaAttributeClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaAttributeClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaAttributeClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaAttributeClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34355 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaEnumRepresentationClauseStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34368 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaEnumRepresentationClauseStorageClass::pickOutIRNodeData ( SgAdaEnumRepresentationClause* pointer ) 
   { 
     SgAdaEnumRepresentationClause* source = (SgAdaEnumRepresentationClause*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_enumType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_enumType );
     storageOf_components = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_components );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaEnumRepresentationClauseStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaEnumRepresentationClauseStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaEnumRepresentationClauseStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaEnumRepresentationClauseStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34472 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaGenericDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34485 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaGenericDeclStorageClass::pickOutIRNodeData ( SgAdaGenericDecl* pointer ) 
   { 
     SgAdaGenericDecl* source = (SgAdaGenericDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_definition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definition );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaGenericDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaGenericDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaGenericDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaGenericDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34595 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaFormalTypeDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34608 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaFormalTypeDeclStorageClass::pickOutIRNodeData ( SgAdaFormalTypeDecl* pointer ) 
   { 
     SgAdaFormalTypeDecl* source = (SgAdaFormalTypeDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_discriminants = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_discriminants );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaFormalTypeDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaFormalTypeDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaFormalTypeDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaFormalTypeDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34717 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDiscriminatedTypeDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34730 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDiscriminatedTypeDeclStorageClass::pickOutIRNodeData ( SgAdaDiscriminatedTypeDecl* pointer ) 
   { 
     SgAdaDiscriminatedTypeDecl* source = (SgAdaDiscriminatedTypeDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_discriminantScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_discriminantScope );
     storageOf_discriminants = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_discriminants );
     storageOf_discriminatedDecl = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_discriminatedDecl );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDiscriminatedTypeDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDiscriminatedTypeDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDiscriminatedTypeDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDiscriminatedTypeDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34837 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaGenericInstanceDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34850 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaGenericInstanceDeclStorageClass::pickOutIRNodeData ( SgAdaGenericInstanceDecl* pointer ) 
   { 
     SgAdaGenericInstanceDecl* source = (SgAdaGenericInstanceDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_genericDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_genericDeclaration );
     storageOf_instantiatedScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_instantiatedScope );
     storageOf_actual_parameters = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_actual_parameters );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaGenericInstanceDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaGenericInstanceDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaGenericInstanceDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaGenericInstanceDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 34961 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaFormalPackageDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 34974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaFormalPackageDeclStorageClass::pickOutIRNodeData ( SgAdaFormalPackageDecl* pointer ) 
   { 
     SgAdaFormalPackageDecl* source = (SgAdaFormalPackageDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_actual_parameters = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_actual_parameters );
     storageOf_prototype = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_prototype );
     storageOf_prototypeScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_prototypeScope );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaFormalPackageDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaFormalPackageDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaFormalPackageDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaFormalPackageDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35085 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaParameterListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35098 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaParameterListStorageClass::pickOutIRNodeData ( SgAdaParameterList* pointer ) 
   { 
     SgAdaParameterList* source = (SgAdaParameterList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgDeclarationStatementPtrList::iterator i_parameters = source->p_parameters.begin() ; 
     unsigned int tempListCountparameters = 0; 
     SgDeclarationStatementPtrList::value_type *  tempListparameters = new SgDeclarationStatementPtrList::value_type[ source->p_parameters.size() ]; 
     for ( ; i_parameters != source->p_parameters.end(); ++i_parameters ) 
        {
          tempListparameters[tempListCountparameters] = *i_parameters;
          tempListCountparameters++; 
          (*i_parameters) = (SgDeclarationStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_parameters ) );
        }
     storageOf_parameters.storeDataInEasyStorageClass(source->p_parameters);
     tempListCountparameters = 0; 
     i_parameters = source->p_parameters.begin() ; 
     for ( ; i_parameters != source->p_parameters.end(); ++i_parameters ) 
        {
          *i_parameters = tempListparameters[tempListCountparameters] ;
          tempListCountparameters++; 
        }
      delete [] tempListparameters; 
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaParameterListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaParameterListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgDeclarationStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaParameterListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgDeclarationStatementPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaParameterListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgDeclarationStatementPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35222 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaVariantDeclStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35235 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaVariantDeclStorageClass::pickOutIRNodeData ( SgAdaVariantDecl* pointer ) 
   { 
     SgAdaVariantDecl* source = (SgAdaVariantDecl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_discriminant = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_discriminant );
     storageOf_variants = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variants );
     storageOf_decl_attributes =  source->p_decl_attributes ;
     storageOf_linkage.storeDataInEasyStorageClass(source->p_linkage);
     storageOf_declarationModifier.pickOutIRNodeData( &(source->p_declarationModifier) );
     storageOf_nameOnly =  source->p_nameOnly ;
     storageOf_forward =  source->p_forward ;
     storageOf_externBrace =  source->p_externBrace ;
     storageOf_skipElaborateType =  source->p_skipElaborateType ;
     storageOf_definingDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_definingDeclaration );
     storageOf_firstNondefiningDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_firstNondefiningDeclaration );
     SgQualifiedNamePtrList::iterator i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     unsigned int tempListCountqualifiedNameList = 0; 
     SgQualifiedNamePtrList::value_type *  tempListqualifiedNameList = new SgQualifiedNamePtrList::value_type[ source->p_qualifiedNameList.size() ]; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          tempListqualifiedNameList[tempListCountqualifiedNameList] = *i_qualifiedNameList;
          tempListCountqualifiedNameList++; 
          (*i_qualifiedNameList) = (SgQualifiedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_qualifiedNameList ) );
        }
     storageOf_qualifiedNameList.storeDataInEasyStorageClass(source->p_qualifiedNameList);
     tempListCountqualifiedNameList = 0; 
     i_qualifiedNameList = source->p_qualifiedNameList.begin() ; 
     for ( ; i_qualifiedNameList != source->p_qualifiedNameList.end(); ++i_qualifiedNameList ) 
        {
          *i_qualifiedNameList = tempListqualifiedNameList[tempListCountqualifiedNameList] ;
          tempListCountqualifiedNameList++; 
        }
      delete [] tempListqualifiedNameList; 
     storageOf_binding_label.storeDataInEasyStorageClass(source->p_binding_label);
     storageOf_declarationScope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declarationScope );
     storageOf_unparse_template_ast =  source->p_unparse_template_ast ;
     storageOf_adaAspects = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_adaAspects );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaVariantDeclStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     SgDeclarationModifierStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgQualifiedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaVariantDeclStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     SgDeclarationModifierStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgQualifiedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaVariantDeclStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     SgDeclarationModifierStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgQualifiedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaVariantDeclStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     SgDeclarationModifierStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgQualifiedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35339 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExprStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35352 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExprStatementStorageClass::pickOutIRNodeData ( SgExprStatement* pointer ) 
   { 
     SgExprStatement* source = (SgExprStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgExprStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExprStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExprStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExprStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35412 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35425 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLabelStatementStorageClass::pickOutIRNodeData ( SgLabelStatement* pointer ) 
   { 
     SgLabelStatement* source = (SgLabelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_label.pickOutIRNodeData( &(source->p_label) );
     storageOf_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_scope );
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_label_type =  source->p_label_type ;
     storageOf_gnu_extension_unused =  source->p_gnu_extension_unused ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLabelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35493 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCaseOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35506 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCaseOptionStmtStorageClass::pickOutIRNodeData ( SgCaseOptionStmt* pointer ) 
   { 
     SgCaseOptionStmt* source = (SgCaseOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_key = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_key_range_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key_range_end );
     storageOf_case_construct_name.storeDataInEasyStorageClass(source->p_case_construct_name);
     storageOf_has_fall_through =  source->p_has_fall_through ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCaseOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCaseOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCaseOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCaseOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35574 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTryStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35587 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTryStmtStorageClass::pickOutIRNodeData ( SgTryStmt* pointer ) 
   { 
     SgTryStmt* source = (SgTryStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_catch_statement_seq_root = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_catch_statement_seq_root );
     storageOf_else_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_body );
     storageOf_finally_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_finally_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTryStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTryStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTryStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTryStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35650 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefaultOptionStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35663 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDefaultOptionStmtStorageClass::pickOutIRNodeData ( SgDefaultOptionStmt* pointer ) 
   { 
     SgDefaultOptionStmt* source = (SgDefaultOptionStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_default_construct_name.storeDataInEasyStorageClass(source->p_default_construct_name);
     storageOf_has_fall_through =  source->p_has_fall_through ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDefaultOptionStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefaultOptionStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefaultOptionStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefaultOptionStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35729 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBreakStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35742 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBreakStmtStorageClass::pickOutIRNodeData ( SgBreakStmt* pointer ) 
   { 
     SgBreakStmt* source = (SgBreakStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_do_string_label.storeDataInEasyStorageClass(source->p_do_string_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBreakStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBreakStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBreakStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBreakStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35806 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgContinueStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35819 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgContinueStmtStorageClass::pickOutIRNodeData ( SgContinueStmt* pointer ) 
   { 
     SgContinueStmt* source = (SgContinueStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_do_string_label.storeDataInEasyStorageClass(source->p_do_string_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgContinueStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgContinueStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgContinueStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgContinueStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35883 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReturnStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35896 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgReturnStmtStorageClass::pickOutIRNodeData ( SgReturnStmt* pointer ) 
   { 
     SgReturnStmt* source = (SgReturnStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgReturnStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReturnStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReturnStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReturnStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 35956 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 35969 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGotoStatementStorageClass::pickOutIRNodeData ( SgGotoStatement* pointer ) 
   { 
     SgGotoStatement* source = (SgGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label );
     storageOf_label_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label_expression );
     storageOf_selector_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_selector_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36031 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSpawnStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36044 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSpawnStmtStorageClass::pickOutIRNodeData ( SgSpawnStmt* pointer ) 
   { 
     SgSpawnStmt* source = (SgSpawnStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_the_func = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_the_func );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSpawnStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSpawnStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSpawnStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSpawnStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36104 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36117 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNullStatementStorageClass::pickOutIRNodeData ( SgNullStatement* pointer ) 
   { 
     SgNullStatement* source = (SgNullStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNullStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36176 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariantStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36189 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVariantStatementStorageClass::pickOutIRNodeData ( SgVariantStatement* pointer ) 
   { 
     SgVariantStatement* source = (SgVariantStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVariantStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariantStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariantStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariantStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36248 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgForInitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36261 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgForInitStatementStorageClass::pickOutIRNodeData ( SgForInitStatement* pointer ) 
   { 
     SgForInitStatement* source = (SgForInitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgStatementPtrList::iterator i_init_stmt = source->p_init_stmt.begin() ; 
     unsigned int tempListCountinit_stmt = 0; 
     SgStatementPtrList::value_type *  tempListinit_stmt = new SgStatementPtrList::value_type[ source->p_init_stmt.size() ]; 
     for ( ; i_init_stmt != source->p_init_stmt.end(); ++i_init_stmt ) 
        {
          tempListinit_stmt[tempListCountinit_stmt] = *i_init_stmt;
          tempListCountinit_stmt++; 
          (*i_init_stmt) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_init_stmt ) );
        }
     storageOf_init_stmt.storeDataInEasyStorageClass(source->p_init_stmt);
     tempListCountinit_stmt = 0; 
     i_init_stmt = source->p_init_stmt.begin() ; 
     for ( ; i_init_stmt != source->p_init_stmt.end(); ++i_init_stmt ) 
        {
          *i_init_stmt = tempListinit_stmt[tempListCountinit_stmt] ;
          tempListCountinit_stmt++; 
        }
      delete [] tempListinit_stmt; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgForInitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgForInitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgForInitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgForInitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36342 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCatchStatementSeqStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36355 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCatchStatementSeqStorageClass::pickOutIRNodeData ( SgCatchStatementSeq* pointer ) 
   { 
     SgCatchStatementSeq* source = (SgCatchStatementSeq*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgStatementPtrList::iterator i_catch_statement_seq = source->p_catch_statement_seq.begin() ; 
     unsigned int tempListCountcatch_statement_seq = 0; 
     SgStatementPtrList::value_type *  tempListcatch_statement_seq = new SgStatementPtrList::value_type[ source->p_catch_statement_seq.size() ]; 
     for ( ; i_catch_statement_seq != source->p_catch_statement_seq.end(); ++i_catch_statement_seq ) 
        {
          tempListcatch_statement_seq[tempListCountcatch_statement_seq] = *i_catch_statement_seq;
          tempListCountcatch_statement_seq++; 
          (*i_catch_statement_seq) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_catch_statement_seq ) );
        }
     storageOf_catch_statement_seq.storeDataInEasyStorageClass(source->p_catch_statement_seq);
     tempListCountcatch_statement_seq = 0; 
     i_catch_statement_seq = source->p_catch_statement_seq.begin() ; 
     for ( ; i_catch_statement_seq != source->p_catch_statement_seq.end(); ++i_catch_statement_seq ) 
        {
          *i_catch_statement_seq = tempListcatch_statement_seq[tempListCountcatch_statement_seq] ;
          tempListCountcatch_statement_seq++; 
        }
      delete [] tempListcatch_statement_seq; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCatchStatementSeqStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCatchStatementSeqStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCatchStatementSeqStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCatchStatementSeqStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36436 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgProcessControlStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36449 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgProcessControlStatementStorageClass::pickOutIRNodeData ( SgProcessControlStatement* pointer ) 
   { 
     SgProcessControlStatement* source = (SgProcessControlStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_control_kind =  source->p_control_kind ;
     storageOf_code = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_code );
     storageOf_quiet = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_quiet );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgProcessControlStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgProcessControlStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgProcessControlStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgProcessControlStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36511 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIOStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36524 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIOStatementStorageClass::pickOutIRNodeData ( SgIOStatement* pointer ) 
   { 
     SgIOStatement* source = (SgIOStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIOStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIOStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIOStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIOStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36589 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPrintStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36602 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPrintStatementStorageClass::pickOutIRNodeData ( SgPrintStatement* pointer ) 
   { 
     SgPrintStatement* source = (SgPrintStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPrintStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPrintStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPrintStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPrintStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36668 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReadStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36681 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgReadStatementStorageClass::pickOutIRNodeData ( SgReadStatement* pointer ) 
   { 
     SgReadStatement* source = (SgReadStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_namelist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namelist );
     storageOf_advance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_advance );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_decimal = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decimal );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end );
     storageOf_eor = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_eor );
     storageOf_id = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_id );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_pos = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pos );
     storageOf_rec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rec );
     storageOf_round = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_round );
     storageOf_sign = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sign );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgReadStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReadStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReadStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReadStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36762 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWriteStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36775 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWriteStatementStorageClass::pickOutIRNodeData ( SgWriteStatement* pointer ) 
   { 
     SgWriteStatement* source = (SgWriteStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_format = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_format );
     storageOf_namelist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_namelist );
     storageOf_advance = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_advance );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_decimal = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decimal );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end );
     storageOf_eor = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_eor );
     storageOf_id = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_id );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_pos = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pos );
     storageOf_rec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rec );
     storageOf_round = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_round );
     storageOf_sign = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sign );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWriteStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWriteStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWriteStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWriteStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36856 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOpenStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36869 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOpenStatementStorageClass::pickOutIRNodeData ( SgOpenStatement* pointer ) 
   { 
     SgOpenStatement* source = (SgOpenStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_status = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_status );
     storageOf_access = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_access );
     storageOf_form = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_form );
     storageOf_recl = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_recl );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_position );
     storageOf_action = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_action );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_round = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_round );
     storageOf_sign = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sign );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOpenStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOpenStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOpenStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOpenStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 36947 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCloseStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 36960 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCloseStatementStorageClass::pickOutIRNodeData ( SgCloseStatement* pointer ) 
   { 
     SgCloseStatement* source = (SgCloseStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_status = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_status );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCloseStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCloseStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCloseStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCloseStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37026 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInquireStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37039 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgInquireStatementStorageClass::pickOutIRNodeData ( SgInquireStatement* pointer ) 
   { 
     SgInquireStatement* source = (SgInquireStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_access = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_access );
     storageOf_form = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_form );
     storageOf_recl = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_recl );
     storageOf_blank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blank );
     storageOf_exist = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exist );
     storageOf_opened = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_opened );
     storageOf_number = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_number );
     storageOf_named = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_named );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_sequential = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sequential );
     storageOf_direct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_direct );
     storageOf_formatted = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_formatted );
     storageOf_unformatted = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unformatted );
     storageOf_nextrec = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nextrec );
     storageOf_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_position );
     storageOf_action = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_action );
     storageOf_read = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_read );
     storageOf_write = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_write );
     storageOf_readwrite = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_readwrite );
     storageOf_delim = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delim );
     storageOf_pad = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pad );
     storageOf_asynchronous = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_asynchronous );
     storageOf_decimal = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_decimal );
     storageOf_stream = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stream );
     storageOf_size = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_size );
     storageOf_pending = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pending );
     storageOf_iolengthExp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iolengthExp );
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgInquireStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInquireStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInquireStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInquireStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37132 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFlushStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37145 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFlushStatementStorageClass::pickOutIRNodeData ( SgFlushStatement* pointer ) 
   { 
     SgFlushStatement* source = (SgFlushStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFlushStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFlushStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFlushStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFlushStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37210 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBackspaceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37223 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBackspaceStatementStorageClass::pickOutIRNodeData ( SgBackspaceStatement* pointer ) 
   { 
     SgBackspaceStatement* source = (SgBackspaceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBackspaceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBackspaceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBackspaceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBackspaceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37288 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRewindStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37301 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRewindStatementStorageClass::pickOutIRNodeData ( SgRewindStatement* pointer ) 
   { 
     SgRewindStatement* source = (SgRewindStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRewindStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRewindStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRewindStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRewindStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37366 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEndfileStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37379 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEndfileStatementStorageClass::pickOutIRNodeData ( SgEndfileStatement* pointer ) 
   { 
     SgEndfileStatement* source = (SgEndfileStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEndfileStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEndfileStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEndfileStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEndfileStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37444 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37457 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWaitStatementStorageClass::pickOutIRNodeData ( SgWaitStatement* pointer ) 
   { 
     SgWaitStatement* source = (SgWaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_io_statement =  source->p_io_statement ;
     storageOf_io_stmt_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_stmt_list );
     storageOf_unit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unit );
     storageOf_iostat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iostat );
     storageOf_err = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err );
     storageOf_iomsg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iomsg );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37522 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFortranContinueStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37535 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFortranContinueStmtStorageClass::pickOutIRNodeData ( SgFortranContinueStmt* pointer ) 
   { 
     SgFortranContinueStmt* source = (SgFortranContinueStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFortranContinueStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFortranContinueStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFortranContinueStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFortranContinueStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37594 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWhereStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37607 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWhereStatementStorageClass::pickOutIRNodeData ( SgWhereStatement* pointer ) 
   { 
     SgWhereStatement* source = (SgWhereStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_elsewhere = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elsewhere );
     storageOf_end_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end_numeric_label );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_has_end_statement =  source->p_has_end_statement ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWhereStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWhereStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWhereStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWhereStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37676 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElseWhereStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37689 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElseWhereStatementStorageClass::pickOutIRNodeData ( SgElseWhereStatement* pointer ) 
   { 
     SgElseWhereStatement* source = (SgElseWhereStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_elsewhere = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elsewhere );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElseWhereStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElseWhereStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElseWhereStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElseWhereStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37751 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullifyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37764 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNullifyStatementStorageClass::pickOutIRNodeData ( SgNullifyStatement* pointer ) 
   { 
     SgNullifyStatement* source = (SgNullifyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_pointer_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pointer_list );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNullifyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullifyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullifyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullifyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37824 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArithmeticIfStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37837 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgArithmeticIfStatementStorageClass::pickOutIRNodeData ( SgArithmeticIfStatement* pointer ) 
   { 
     SgArithmeticIfStatement* source = (SgArithmeticIfStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_conditional = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional );
     storageOf_less_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_less_label );
     storageOf_equal_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_equal_label );
     storageOf_greater_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_greater_label );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgArithmeticIfStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArithmeticIfStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArithmeticIfStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArithmeticIfStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37900 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37913 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAssignStatementStorageClass::pickOutIRNodeData ( SgAssignStatement* pointer ) 
   { 
     SgAssignStatement* source = (SgAssignStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label );
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAssignStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 37974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComputedGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 37987 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgComputedGotoStatementStorageClass::pickOutIRNodeData ( SgComputedGotoStatement* pointer ) 
   { 
     SgComputedGotoStatement* source = (SgComputedGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_labelList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_labelList );
     storageOf_label_index = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_label_index );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgComputedGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComputedGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComputedGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComputedGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38048 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignedGotoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38061 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAssignedGotoStatementStorageClass::pickOutIRNodeData ( SgAssignedGotoStatement* pointer ) 
   { 
     SgAssignedGotoStatement* source = (SgAssignedGotoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_targets = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_targets );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAssignedGotoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignedGotoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignedGotoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignedGotoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38121 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAllocateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38134 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAllocateStatementStorageClass::pickOutIRNodeData ( SgAllocateStatement* pointer ) 
   { 
     SgAllocateStatement* source = (SgAllocateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expr_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expr_list );
     storageOf_stat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat_expression );
     storageOf_errmsg_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_errmsg_expression );
     storageOf_source_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAllocateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAllocateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAllocateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAllocateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38197 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeallocateStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38210 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDeallocateStatementStorageClass::pickOutIRNodeData ( SgDeallocateStatement* pointer ) 
   { 
     SgDeallocateStatement* source = (SgDeallocateStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expr_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expr_list );
     storageOf_stat_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat_expression );
     storageOf_errmsg_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_errmsg_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDeallocateStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeallocateStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeallocateStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeallocateStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38272 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcNotifyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38285 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcNotifyStatementStorageClass::pickOutIRNodeData ( SgUpcNotifyStatement* pointer ) 
   { 
     SgUpcNotifyStatement* source = (SgUpcNotifyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_notify_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_notify_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcNotifyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcNotifyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcNotifyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcNotifyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38345 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcWaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38358 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcWaitStatementStorageClass::pickOutIRNodeData ( SgUpcWaitStatement* pointer ) 
   { 
     SgUpcWaitStatement* source = (SgUpcWaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_wait_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_wait_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcWaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcWaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcWaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcWaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38418 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcBarrierStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38431 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcBarrierStatementStorageClass::pickOutIRNodeData ( SgUpcBarrierStatement* pointer ) 
   { 
     SgUpcBarrierStatement* source = (SgUpcBarrierStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_barrier_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_barrier_expression );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcBarrierStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcBarrierStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcBarrierStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcBarrierStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38491 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcFenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38504 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcFenceStatementStorageClass::pickOutIRNodeData ( SgUpcFenceStatement* pointer ) 
   { 
     SgUpcFenceStatement* source = (SgUpcFenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcFenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcFenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcFenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcFenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38563 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpBarrierStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38576 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpBarrierStatementStorageClass::pickOutIRNodeData ( SgOmpBarrierStatement* pointer ) 
   { 
     SgOmpBarrierStatement* source = (SgOmpBarrierStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpBarrierStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpBarrierStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpBarrierStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpBarrierStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38635 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTaskwaitStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38648 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTaskwaitStatementStorageClass::pickOutIRNodeData ( SgOmpTaskwaitStatement* pointer ) 
   { 
     SgOmpTaskwaitStatement* source = (SgOmpTaskwaitStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpTaskwaitStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTaskwaitStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTaskwaitStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTaskwaitStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38707 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpFlushStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38720 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpFlushStatementStorageClass::pickOutIRNodeData ( SgOmpFlushStatement* pointer ) 
   { 
     SgOmpFlushStatement* source = (SgOmpFlushStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgVarRefExpPtrList::iterator i_variables = source->p_variables.begin() ; 
     unsigned int tempListCountvariables = 0; 
     SgVarRefExpPtrList::value_type *  tempListvariables = new SgVarRefExpPtrList::value_type[ source->p_variables.size() ]; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          tempListvariables[tempListCountvariables] = *i_variables;
          tempListCountvariables++; 
          (*i_variables) = (SgVarRefExpPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_variables ) );
        }
     storageOf_variables.storeDataInEasyStorageClass(source->p_variables);
     tempListCountvariables = 0; 
     i_variables = source->p_variables.begin() ; 
     for ( ; i_variables != source->p_variables.end(); ++i_variables ) 
        {
          *i_variables = tempListvariables[tempListCountvariables] ;
          tempListCountvariables++; 
        }
      delete [] tempListvariables; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpFlushStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgVarRefExpPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpFlushStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgVarRefExpPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpFlushStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgVarRefExpPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpFlushStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgVarRefExpPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38801 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpBodyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38814 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpBodyStatementStorageClass::pickOutIRNodeData ( SgOmpBodyStatement* pointer ) 
   { 
     SgOmpBodyStatement* source = (SgOmpBodyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpBodyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpBodyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpBodyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpBodyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38874 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpMasterStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38887 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpMasterStatementStorageClass::pickOutIRNodeData ( SgOmpMasterStatement* pointer ) 
   { 
     SgOmpMasterStatement* source = (SgOmpMasterStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpMasterStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpMasterStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpMasterStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpMasterStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 38947 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpOrderedStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 38960 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpOrderedStatementStorageClass::pickOutIRNodeData ( SgOmpOrderedStatement* pointer ) 
   { 
     SgOmpOrderedStatement* source = (SgOmpOrderedStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpOrderedStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpOrderedStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpOrderedStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpOrderedStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39020 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpCriticalStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39033 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpCriticalStatementStorageClass::pickOutIRNodeData ( SgOmpCriticalStatement* pointer ) 
   { 
     SgOmpCriticalStatement* source = (SgOmpCriticalStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpCriticalStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpCriticalStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpCriticalStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpCriticalStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39098 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSectionStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39111 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSectionStatementStorageClass::pickOutIRNodeData ( SgOmpSectionStatement* pointer ) 
   { 
     SgOmpSectionStatement* source = (SgOmpSectionStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpSectionStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSectionStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSectionStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSectionStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39171 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpWorkshareStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39184 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpWorkshareStatementStorageClass::pickOutIRNodeData ( SgOmpWorkshareStatement* pointer ) 
   { 
     SgOmpWorkshareStatement* source = (SgOmpWorkshareStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpWorkshareStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpWorkshareStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpWorkshareStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpWorkshareStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39244 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpClauseBodyStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39257 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpClauseBodyStatementStorageClass::pickOutIRNodeData ( SgOmpClauseBodyStatement* pointer ) 
   { 
     SgOmpClauseBodyStatement* source = (SgOmpClauseBodyStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpClauseBodyStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpClauseBodyStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpClauseBodyStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpClauseBodyStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39339 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpParallelStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39352 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpParallelStatementStorageClass::pickOutIRNodeData ( SgOmpParallelStatement* pointer ) 
   { 
     SgOmpParallelStatement* source = (SgOmpParallelStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpParallelStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpParallelStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpParallelStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpParallelStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39434 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSingleStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39447 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSingleStatementStorageClass::pickOutIRNodeData ( SgOmpSingleStatement* pointer ) 
   { 
     SgOmpSingleStatement* source = (SgOmpSingleStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpSingleStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSingleStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSingleStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSingleStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39529 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpAtomicStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39542 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpAtomicStatementStorageClass::pickOutIRNodeData ( SgOmpAtomicStatement* pointer ) 
   { 
     SgOmpAtomicStatement* source = (SgOmpAtomicStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpAtomicStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpAtomicStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpAtomicStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpAtomicStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39624 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTaskStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39637 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTaskStatementStorageClass::pickOutIRNodeData ( SgOmpTaskStatement* pointer ) 
   { 
     SgOmpTaskStatement* source = (SgOmpTaskStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpTaskStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTaskStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTaskStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTaskStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39719 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpForStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39732 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpForStatementStorageClass::pickOutIRNodeData ( SgOmpForStatement* pointer ) 
   { 
     SgOmpForStatement* source = (SgOmpForStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpForStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpForStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpForStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpForStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39814 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpDoStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39827 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpDoStatementStorageClass::pickOutIRNodeData ( SgOmpDoStatement* pointer ) 
   { 
     SgOmpDoStatement* source = (SgOmpDoStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpDoStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpDoStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpDoStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpDoStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 39909 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSectionsStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 39922 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSectionsStatementStorageClass::pickOutIRNodeData ( SgOmpSectionsStatement* pointer ) 
   { 
     SgOmpSectionsStatement* source = (SgOmpSectionsStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpSectionsStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSectionsStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSectionsStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSectionsStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40004 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTargetStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40017 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTargetStatementStorageClass::pickOutIRNodeData ( SgOmpTargetStatement* pointer ) 
   { 
     SgOmpTargetStatement* source = (SgOmpTargetStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpTargetStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTargetStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTargetStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTargetStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40099 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpTargetDataStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40112 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpTargetDataStatementStorageClass::pickOutIRNodeData ( SgOmpTargetDataStatement* pointer ) 
   { 
     SgOmpTargetDataStatement* source = (SgOmpTargetDataStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpTargetDataStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpTargetDataStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpTargetDataStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpTargetDataStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40194 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpSimdStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40207 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpSimdStatementStorageClass::pickOutIRNodeData ( SgOmpSimdStatement* pointer ) 
   { 
     SgOmpSimdStatement* source = (SgOmpSimdStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpSimdStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpSimdStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpSimdStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpSimdStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40289 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOmpForSimdStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40302 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOmpForSimdStatementStorageClass::pickOutIRNodeData ( SgOmpForSimdStatement* pointer ) 
   { 
     SgOmpForSimdStatement* source = (SgOmpForSimdStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgOmpClausePtrList::iterator i_clauses = source->p_clauses.begin() ; 
     unsigned int tempListCountclauses = 0; 
     SgOmpClausePtrList::value_type *  tempListclauses = new SgOmpClausePtrList::value_type[ source->p_clauses.size() ]; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          tempListclauses[tempListCountclauses] = *i_clauses;
          tempListCountclauses++; 
          (*i_clauses) = (SgOmpClausePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_clauses ) );
        }
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     tempListCountclauses = 0; 
     i_clauses = source->p_clauses.begin() ; 
     for ( ; i_clauses != source->p_clauses.end(); ++i_clauses ) 
        {
          *i_clauses = tempListclauses[tempListCountclauses] ;
          tempListCountclauses++; 
        }
      delete [] tempListclauses; 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOmpForSimdStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgOmpClausePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOmpForSimdStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgOmpClausePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOmpForSimdStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgOmpClausePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOmpForSimdStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgOmpClausePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40384 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSequenceStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40397 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSequenceStatementStorageClass::pickOutIRNodeData ( SgSequenceStatement* pointer ) 
   { 
     SgSequenceStatement* source = (SgSequenceStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSequenceStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSequenceStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSequenceStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSequenceStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40456 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWithStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40469 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWithStatementStorageClass::pickOutIRNodeData ( SgWithStatement* pointer ) 
   { 
     SgWithStatement* source = (SgWithStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWithStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWithStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWithStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWithStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40530 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPythonPrintStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40543 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPythonPrintStmtStorageClass::pickOutIRNodeData ( SgPythonPrintStmt* pointer ) 
   { 
     SgPythonPrintStmt* source = (SgPythonPrintStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_destination = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_destination );
     storageOf_values = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_values );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPythonPrintStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPythonPrintStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPythonPrintStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPythonPrintStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40604 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPassStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40617 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPassStatementStorageClass::pickOutIRNodeData ( SgPassStatement* pointer ) 
   { 
     SgPassStatement* source = (SgPassStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPassStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPassStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPassStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPassStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40676 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssertStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40689 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAssertStmtStorageClass::pickOutIRNodeData ( SgAssertStmt* pointer ) 
   { 
     SgAssertStmt* source = (SgAssertStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_test = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_test );
     storageOf_exception_argument = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exception_argument );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAssertStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssertStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssertStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssertStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40750 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExecStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40763 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExecStatementStorageClass::pickOutIRNodeData ( SgExecStatement* pointer ) 
   { 
     SgExecStatement* source = (SgExecStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_executable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executable );
     storageOf_globals = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globals );
     storageOf_locals = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_locals );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgExecStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExecStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExecStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExecStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40825 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPythonGlobalStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40838 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPythonGlobalStmtStorageClass::pickOutIRNodeData ( SgPythonGlobalStmt* pointer ) 
   { 
     SgPythonGlobalStmt* source = (SgPythonGlobalStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgInitializedNamePtrList::iterator i_names = source->p_names.begin() ; 
     unsigned int tempListCountnames = 0; 
     SgInitializedNamePtrList::value_type *  tempListnames = new SgInitializedNamePtrList::value_type[ source->p_names.size() ]; 
     for ( ; i_names != source->p_names.end(); ++i_names ) 
        {
          tempListnames[tempListCountnames] = *i_names;
          tempListCountnames++; 
          (*i_names) = (SgInitializedNamePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_names ) );
        }
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     tempListCountnames = 0; 
     i_names = source->p_names.begin() ; 
     for ( ; i_names != source->p_names.end(); ++i_names ) 
        {
          *i_names = tempListnames[tempListCountnames] ;
          tempListCountnames++; 
        }
      delete [] tempListnames; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPythonGlobalStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgInitializedNamePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPythonGlobalStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgInitializedNamePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPythonGlobalStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgInitializedNamePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPythonGlobalStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgInitializedNamePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40919 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaThrowStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 40932 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaThrowStatementStorageClass::pickOutIRNodeData ( SgJavaThrowStatement* pointer ) 
   { 
     SgJavaThrowStatement* source = (SgJavaThrowStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_throwOp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_throwOp );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaThrowStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaThrowStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaThrowStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaThrowStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 40992 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaSynchronizedStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41005 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaSynchronizedStatementStorageClass::pickOutIRNodeData ( SgJavaSynchronizedStatement* pointer ) 
   { 
     SgJavaSynchronizedStatement* source = (SgJavaSynchronizedStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaSynchronizedStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaSynchronizedStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaSynchronizedStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaSynchronizedStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41066 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsyncStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41079 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsyncStmtStorageClass::pickOutIRNodeData ( SgAsyncStmt* pointer ) 
   { 
     SgAsyncStmt* source = (SgAsyncStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsyncStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsyncStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsyncStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsyncStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41139 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFinishStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41152 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFinishStmtStorageClass::pickOutIRNodeData ( SgFinishStmt* pointer ) 
   { 
     SgFinishStmt* source = (SgFinishStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFinishStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFinishStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFinishStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFinishStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41212 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAtStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41225 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAtStmtStorageClass::pickOutIRNodeData ( SgAtStmt* pointer ) 
   { 
     SgAtStmt* source = (SgAtStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAtStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAtStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAtStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAtStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41286 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAtomicStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41299 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAtomicStmtStorageClass::pickOutIRNodeData ( SgAtomicStmt* pointer ) 
   { 
     SgAtomicStmt* source = (SgAtomicStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAtomicStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAtomicStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAtomicStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAtomicStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41359 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWhenStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41372 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWhenStmtStorageClass::pickOutIRNodeData ( SgWhenStmt* pointer ) 
   { 
     SgWhenStmt* source = (SgWhenStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWhenStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWhenStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWhenStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWhenStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41433 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImageControlStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41446 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgImageControlStatementStorageClass::pickOutIRNodeData ( SgImageControlStatement* pointer ) 
   { 
     SgImageControlStatement* source = (SgImageControlStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_image_control_statement =  source->p_image_control_statement ;
     storageOf_stat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat );
     storageOf_err_msg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err_msg );
     storageOf_acquired_lock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_acquired_lock );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgImageControlStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImageControlStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImageControlStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImageControlStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41509 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSyncAllStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41522 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSyncAllStatementStorageClass::pickOutIRNodeData ( SgSyncAllStatement* pointer ) 
   { 
     SgSyncAllStatement* source = (SgSyncAllStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_image_control_statement =  source->p_image_control_statement ;
     storageOf_stat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat );
     storageOf_err_msg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err_msg );
     storageOf_acquired_lock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_acquired_lock );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSyncAllStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSyncAllStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSyncAllStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSyncAllStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41585 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSyncImagesStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41598 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSyncImagesStatementStorageClass::pickOutIRNodeData ( SgSyncImagesStatement* pointer ) 
   { 
     SgSyncImagesStatement* source = (SgSyncImagesStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_image_set = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_image_set );
     storageOf_image_control_statement =  source->p_image_control_statement ;
     storageOf_stat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat );
     storageOf_err_msg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err_msg );
     storageOf_acquired_lock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_acquired_lock );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSyncImagesStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSyncImagesStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSyncImagesStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSyncImagesStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41662 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSyncMemoryStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41675 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSyncMemoryStatementStorageClass::pickOutIRNodeData ( SgSyncMemoryStatement* pointer ) 
   { 
     SgSyncMemoryStatement* source = (SgSyncMemoryStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_image_control_statement =  source->p_image_control_statement ;
     storageOf_stat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat );
     storageOf_err_msg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err_msg );
     storageOf_acquired_lock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_acquired_lock );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSyncMemoryStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSyncMemoryStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSyncMemoryStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSyncMemoryStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41738 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSyncTeamStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41751 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSyncTeamStatementStorageClass::pickOutIRNodeData ( SgSyncTeamStatement* pointer ) 
   { 
     SgSyncTeamStatement* source = (SgSyncTeamStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_team_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_team_value );
     storageOf_image_control_statement =  source->p_image_control_statement ;
     storageOf_stat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat );
     storageOf_err_msg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err_msg );
     storageOf_acquired_lock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_acquired_lock );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSyncTeamStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSyncTeamStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSyncTeamStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSyncTeamStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41815 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLockStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41828 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLockStatementStorageClass::pickOutIRNodeData ( SgLockStatement* pointer ) 
   { 
     SgLockStatement* source = (SgLockStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lock_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lock_variable );
     storageOf_image_control_statement =  source->p_image_control_statement ;
     storageOf_stat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat );
     storageOf_err_msg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err_msg );
     storageOf_acquired_lock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_acquired_lock );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLockStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLockStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLockStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLockStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41892 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnlockStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41905 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnlockStatementStorageClass::pickOutIRNodeData ( SgUnlockStatement* pointer ) 
   { 
     SgUnlockStatement* source = (SgUnlockStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lock_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lock_variable );
     storageOf_image_control_statement =  source->p_image_control_statement ;
     storageOf_stat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stat );
     storageOf_err_msg = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_err_msg );
     storageOf_acquired_lock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_acquired_lock );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnlockStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnlockStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnlockStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnlockStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 41969 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaExitStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 41982 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaExitStmtStorageClass::pickOutIRNodeData ( SgAdaExitStmt* pointer ) 
   { 
     SgAdaExitStmt* source = (SgAdaExitStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_loop = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_loop );
     storageOf_condition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_condition );
     storageOf_explicitLoopName =  source->p_explicitLoopName ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaExitStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaExitStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaExitStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaExitStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42044 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaDelayStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42057 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaDelayStmtStorageClass::pickOutIRNodeData ( SgAdaDelayStmt* pointer ) 
   { 
     SgAdaDelayStmt* source = (SgAdaDelayStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_time = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_time );
     storageOf_isRelative =  source->p_isRelative ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaDelayStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaDelayStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaDelayStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaDelayStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42118 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaLoopStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42131 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaLoopStmtStorageClass::pickOutIRNodeData ( SgAdaLoopStmt* pointer ) 
   { 
     SgAdaLoopStmt* source = (SgAdaLoopStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_string_label.storeDataInEasyStorageClass(source->p_string_label);
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaLoopStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaLoopStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaLoopStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaLoopStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42196 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaSelectStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42209 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaSelectStmtStorageClass::pickOutIRNodeData ( SgAdaSelectStmt* pointer ) 
   { 
     SgAdaSelectStmt* source = (SgAdaSelectStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_select_path = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_select_path );
     storageOf_or_path = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_or_path );
     storageOf_else_path = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_else_path );
     storageOf_abort_path = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_abort_path );
     storageOf_select_type =  source->p_select_type ;
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaSelectStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaSelectStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaSelectStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaSelectStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42273 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaSelectAlternativeStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42286 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaSelectAlternativeStmtStorageClass::pickOutIRNodeData ( SgAdaSelectAlternativeStmt* pointer ) 
   { 
     SgAdaSelectAlternativeStmt* source = (SgAdaSelectAlternativeStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_guard = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_guard );
     storageOf_next = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_next );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaSelectAlternativeStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaSelectAlternativeStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaSelectAlternativeStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaSelectAlternativeStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42348 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTerminateStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42361 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTerminateStmtStorageClass::pickOutIRNodeData ( SgAdaTerminateStmt* pointer ) 
   { 
     SgAdaTerminateStmt* source = (SgAdaTerminateStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTerminateStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTerminateStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTerminateStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTerminateStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42420 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaUnscopedBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42433 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaUnscopedBlockStorageClass::pickOutIRNodeData ( SgAdaUnscopedBlock* pointer ) 
   { 
     SgAdaUnscopedBlock* source = (SgAdaUnscopedBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgStatementPtrList::iterator i_statements = source->p_statements.begin() ; 
     unsigned int tempListCountstatements = 0; 
     SgStatementPtrList::value_type *  tempListstatements = new SgStatementPtrList::value_type[ source->p_statements.size() ]; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          tempListstatements[tempListCountstatements] = *i_statements;
          tempListCountstatements++; 
          (*i_statements) = (SgStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statements ) );
        }
     storageOf_statements.storeDataInEasyStorageClass(source->p_statements);
     tempListCountstatements = 0; 
     i_statements = source->p_statements.begin() ; 
     for ( ; i_statements != source->p_statements.end(); ++i_statements ) 
        {
          *i_statements = tempListstatements[tempListCountstatements] ;
          tempListCountstatements++; 
        }
      delete [] tempListstatements; 
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaUnscopedBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaUnscopedBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaUnscopedBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStatementPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaUnscopedBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStatementPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42514 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaVariantWhenStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42527 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaVariantWhenStmtStorageClass::pickOutIRNodeData ( SgAdaVariantWhenStmt* pointer ) 
   { 
     SgAdaVariantWhenStmt* source = (SgAdaVariantWhenStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_choices = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_choices );
     storageOf_components = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_components );
     storageOf_numeric_label = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_numeric_label );
     storageOf_source_sequence_value =  source->p_source_sequence_value ;
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaVariantWhenStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaVariantWhenStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaVariantWhenStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaVariantWhenStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42588 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42601 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExpressionStorageClass::pickOutIRNodeData ( SgExpression* pointer ) 
   { 
     SgExpression* source = (SgExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42662 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42675 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnaryOpStorageClass::pickOutIRNodeData ( SgUnaryOp* pointer ) 
   { 
     SgUnaryOp* source = (SgUnaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42739 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExpressionRootStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42752 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExpressionRootStorageClass::pickOutIRNodeData ( SgExpressionRoot* pointer ) 
   { 
     SgExpressionRoot* source = (SgExpressionRoot*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgExpressionRootStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExpressionRootStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExpressionRootStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExpressionRootStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42816 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42829 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMinusOpStorageClass::pickOutIRNodeData ( SgMinusOp* pointer ) 
   { 
     SgMinusOp* source = (SgMinusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMinusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42893 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnaryAddOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42906 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnaryAddOpStorageClass::pickOutIRNodeData ( SgUnaryAddOp* pointer ) 
   { 
     SgUnaryAddOp* source = (SgUnaryAddOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnaryAddOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnaryAddOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnaryAddOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnaryAddOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 42970 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNotOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 42983 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNotOpStorageClass::pickOutIRNodeData ( SgNotOp* pointer ) 
   { 
     SgNotOp* source = (SgNotOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNotOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNotOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNotOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNotOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43047 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerDerefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43060 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPointerDerefExpStorageClass::pickOutIRNodeData ( SgPointerDerefExp* pointer ) 
   { 
     SgPointerDerefExp* source = (SgPointerDerefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPointerDerefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerDerefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerDerefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerDerefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43124 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAddressOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43137 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAddressOfOpStorageClass::pickOutIRNodeData ( SgAddressOfOp* pointer ) 
   { 
     SgAddressOfOp* source = (SgAddressOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAddressOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAddressOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAddressOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAddressOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43202 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusMinusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43215 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMinusMinusOpStorageClass::pickOutIRNodeData ( SgMinusMinusOp* pointer ) 
   { 
     SgMinusMinusOp* source = (SgMinusMinusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMinusMinusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusMinusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusMinusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusMinusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43279 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPlusPlusOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43292 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPlusPlusOpStorageClass::pickOutIRNodeData ( SgPlusPlusOp* pointer ) 
   { 
     SgPlusPlusOp* source = (SgPlusPlusOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPlusPlusOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPlusPlusOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPlusPlusOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPlusPlusOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43356 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitComplementOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43369 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBitComplementOpStorageClass::pickOutIRNodeData ( SgBitComplementOp* pointer ) 
   { 
     SgBitComplementOp* source = (SgBitComplementOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBitComplementOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitComplementOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitComplementOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitComplementOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43433 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCastExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43446 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCastExpStorageClass::pickOutIRNodeData ( SgCastExp* pointer ) 
   { 
     SgCastExp* source = (SgCastExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_cast_type =  source->p_cast_type ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_castContainsBaseTypeDefiningDeclaration =  source->p_castContainsBaseTypeDefiningDeclaration ;
     storageOf_name_qualification_for_pointer_to_member_class_length =  source->p_name_qualification_for_pointer_to_member_class_length ;
     storageOf_type_elaboration_for_pointer_to_member_class_required =  source->p_type_elaboration_for_pointer_to_member_class_required ;
     storageOf_global_qualification_for_pointer_to_member_class_required =  source->p_global_qualification_for_pointer_to_member_class_required ;
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCastExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCastExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCastExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCastExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43519 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgThrowOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43532 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgThrowOpStorageClass::pickOutIRNodeData ( SgThrowOp* pointer ) 
   { 
     SgThrowOp* source = (SgThrowOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_throwKind =  source->p_throwKind ;
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgThrowOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgThrowOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgThrowOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgThrowOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43597 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRealPartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43610 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRealPartOpStorageClass::pickOutIRNodeData ( SgRealPartOp* pointer ) 
   { 
     SgRealPartOp* source = (SgRealPartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRealPartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRealPartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRealPartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRealPartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43674 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImagPartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43687 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgImagPartOpStorageClass::pickOutIRNodeData ( SgImagPartOp* pointer ) 
   { 
     SgImagPartOp* source = (SgImagPartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgImagPartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImagPartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImagPartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImagPartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43751 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConjugateOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43764 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgConjugateOpStorageClass::pickOutIRNodeData ( SgConjugateOp* pointer ) 
   { 
     SgConjugateOp* source = (SgConjugateOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgConjugateOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConjugateOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConjugateOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConjugateOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43828 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUserDefinedUnaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43841 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUserDefinedUnaryOpStorageClass::pickOutIRNodeData ( SgUserDefinedUnaryOp* pointer ) 
   { 
     SgUserDefinedUnaryOp* source = (SgUserDefinedUnaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operator_name.pickOutIRNodeData( &(source->p_operator_name) );
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUserDefinedUnaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUserDefinedUnaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUserDefinedUnaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUserDefinedUnaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43911 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMatrixTransposeOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 43924 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMatrixTransposeOpStorageClass::pickOutIRNodeData ( SgMatrixTransposeOp* pointer ) 
   { 
     SgMatrixTransposeOp* source = (SgMatrixTransposeOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_is_conjugate =  source->p_is_conjugate ;
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMatrixTransposeOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMatrixTransposeOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMatrixTransposeOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMatrixTransposeOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 43989 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAbsOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44002 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAbsOpStorageClass::pickOutIRNodeData ( SgAbsOp* pointer ) 
   { 
     SgAbsOp* source = (SgAbsOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_mode =  source->p_mode ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAbsOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAbsOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAbsOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAbsOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44066 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBinaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44079 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBinaryOpStorageClass::pickOutIRNodeData ( SgBinaryOp* pointer ) 
   { 
     SgBinaryOp* source = (SgBinaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBinaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBinaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBinaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBinaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44144 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrowExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44157 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgArrowExpStorageClass::pickOutIRNodeData ( SgArrowExp* pointer ) 
   { 
     SgArrowExp* source = (SgArrowExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgArrowExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrowExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrowExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrowExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44222 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDotExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44235 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDotExpStorageClass::pickOutIRNodeData ( SgDotExp* pointer ) 
   { 
     SgDotExp* source = (SgDotExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDotExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDotExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDotExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDotExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44300 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDotStarOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44313 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDotStarOpStorageClass::pickOutIRNodeData ( SgDotStarOp* pointer ) 
   { 
     SgDotStarOp* source = (SgDotStarOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDotStarOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDotStarOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDotStarOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDotStarOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44378 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgArrowStarOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44391 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgArrowStarOpStorageClass::pickOutIRNodeData ( SgArrowStarOp* pointer ) 
   { 
     SgArrowStarOp* source = (SgArrowStarOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgArrowStarOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgArrowStarOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgArrowStarOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgArrowStarOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44456 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEqualityOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44469 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEqualityOpStorageClass::pickOutIRNodeData ( SgEqualityOp* pointer ) 
   { 
     SgEqualityOp* source = (SgEqualityOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEqualityOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEqualityOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEqualityOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEqualityOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44534 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLessThanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44547 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLessThanOpStorageClass::pickOutIRNodeData ( SgLessThanOp* pointer ) 
   { 
     SgLessThanOp* source = (SgLessThanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLessThanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLessThanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLessThanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLessThanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44612 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGreaterThanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44625 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGreaterThanOpStorageClass::pickOutIRNodeData ( SgGreaterThanOp* pointer ) 
   { 
     SgGreaterThanOp* source = (SgGreaterThanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgGreaterThanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGreaterThanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGreaterThanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGreaterThanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44690 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNotEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44703 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNotEqualOpStorageClass::pickOutIRNodeData ( SgNotEqualOp* pointer ) 
   { 
     SgNotEqualOp* source = (SgNotEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNotEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNotEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNotEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNotEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44768 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLessOrEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44781 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLessOrEqualOpStorageClass::pickOutIRNodeData ( SgLessOrEqualOp* pointer ) 
   { 
     SgLessOrEqualOp* source = (SgLessOrEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLessOrEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLessOrEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLessOrEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLessOrEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44846 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgGreaterOrEqualOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44859 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgGreaterOrEqualOpStorageClass::pickOutIRNodeData ( SgGreaterOrEqualOp* pointer ) 
   { 
     SgGreaterOrEqualOp* source = (SgGreaterOrEqualOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgGreaterOrEqualOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgGreaterOrEqualOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgGreaterOrEqualOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgGreaterOrEqualOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 44924 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAddOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 44937 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAddOpStorageClass::pickOutIRNodeData ( SgAddOp* pointer ) 
   { 
     SgAddOp* source = (SgAddOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAddOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAddOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAddOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAddOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45002 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSubtractOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45015 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSubtractOpStorageClass::pickOutIRNodeData ( SgSubtractOp* pointer ) 
   { 
     SgSubtractOp* source = (SgSubtractOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSubtractOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSubtractOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSubtractOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSubtractOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45080 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMultiplyOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45093 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMultiplyOpStorageClass::pickOutIRNodeData ( SgMultiplyOp* pointer ) 
   { 
     SgMultiplyOp* source = (SgMultiplyOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMultiplyOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMultiplyOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMultiplyOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMultiplyOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45158 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45171 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDivideOpStorageClass::pickOutIRNodeData ( SgDivideOp* pointer ) 
   { 
     SgDivideOp* source = (SgDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45236 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntegerDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45249 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIntegerDivideOpStorageClass::pickOutIRNodeData ( SgIntegerDivideOp* pointer ) 
   { 
     SgIntegerDivideOp* source = (SgIntegerDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIntegerDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntegerDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntegerDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntegerDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45314 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45327 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgModOpStorageClass::pickOutIRNodeData ( SgModOp* pointer ) 
   { 
     SgModOp* source = (SgModOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgModOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45392 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45405 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAndOpStorageClass::pickOutIRNodeData ( SgAndOp* pointer ) 
   { 
     SgAndOp* source = (SgAndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45470 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgOrOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45483 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgOrOpStorageClass::pickOutIRNodeData ( SgOrOp* pointer ) 
   { 
     SgOrOp* source = (SgOrOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgOrOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgOrOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgOrOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgOrOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45548 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitXorOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45561 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBitXorOpStorageClass::pickOutIRNodeData ( SgBitXorOp* pointer ) 
   { 
     SgBitXorOp* source = (SgBitXorOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBitXorOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitXorOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitXorOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitXorOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45626 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitAndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45639 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBitAndOpStorageClass::pickOutIRNodeData ( SgBitAndOp* pointer ) 
   { 
     SgBitAndOp* source = (SgBitAndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBitAndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitAndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitAndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitAndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45704 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitOrOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45717 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBitOrOpStorageClass::pickOutIRNodeData ( SgBitOrOp* pointer ) 
   { 
     SgBitOrOp* source = (SgBitOrOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBitOrOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitOrOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitOrOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitOrOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45782 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBitEqvOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45795 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBitEqvOpStorageClass::pickOutIRNodeData ( SgBitEqvOp* pointer ) 
   { 
     SgBitEqvOp* source = (SgBitEqvOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBitEqvOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBitEqvOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBitEqvOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBitEqvOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45860 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommaOpExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45873 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCommaOpExpStorageClass::pickOutIRNodeData ( SgCommaOpExp* pointer ) 
   { 
     SgCommaOpExp* source = (SgCommaOpExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCommaOpExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommaOpExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommaOpExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommaOpExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 45938 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 45951 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLshiftOpStorageClass::pickOutIRNodeData ( SgLshiftOp* pointer ) 
   { 
     SgLshiftOp* source = (SgLshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46016 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46029 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRshiftOpStorageClass::pickOutIRNodeData ( SgRshiftOp* pointer ) 
   { 
     SgRshiftOp* source = (SgRshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46094 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPntrArrRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46107 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPntrArrRefExpStorageClass::pickOutIRNodeData ( SgPntrArrRefExp* pointer ) 
   { 
     SgPntrArrRefExp* source = (SgPntrArrRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPntrArrRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPntrArrRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPntrArrRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPntrArrRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46172 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopeOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46185 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgScopeOpStorageClass::pickOutIRNodeData ( SgScopeOp* pointer ) 
   { 
     SgScopeOp* source = (SgScopeOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgScopeOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopeOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopeOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopeOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46250 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46263 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAssignOpStorageClass::pickOutIRNodeData ( SgAssignOp* pointer ) 
   { 
     SgAssignOp* source = (SgAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46328 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExponentiationOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46341 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExponentiationOpStorageClass::pickOutIRNodeData ( SgExponentiationOp* pointer ) 
   { 
     SgExponentiationOp* source = (SgExponentiationOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgExponentiationOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExponentiationOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExponentiationOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExponentiationOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46406 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaUnsignedRshiftOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46419 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaUnsignedRshiftOpStorageClass::pickOutIRNodeData ( SgJavaUnsignedRshiftOp* pointer ) 
   { 
     SgJavaUnsignedRshiftOp* source = (SgJavaUnsignedRshiftOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaUnsignedRshiftOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaUnsignedRshiftOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaUnsignedRshiftOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaUnsignedRshiftOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46484 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConcatenationOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46497 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgConcatenationOpStorageClass::pickOutIRNodeData ( SgConcatenationOp* pointer ) 
   { 
     SgConcatenationOp* source = (SgConcatenationOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgConcatenationOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConcatenationOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConcatenationOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConcatenationOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46562 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPointerAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46575 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPointerAssignOpStorageClass::pickOutIRNodeData ( SgPointerAssignOp* pointer ) 
   { 
     SgPointerAssignOp* source = (SgPointerAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPointerAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPointerAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPointerAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPointerAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46640 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUserDefinedBinaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46653 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUserDefinedBinaryOpStorageClass::pickOutIRNodeData ( SgUserDefinedBinaryOp* pointer ) 
   { 
     SgUserDefinedBinaryOp* source = (SgUserDefinedBinaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operator_name.pickOutIRNodeData( &(source->p_operator_name) );
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUserDefinedBinaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUserDefinedBinaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUserDefinedBinaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUserDefinedBinaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46724 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCompoundAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46737 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCompoundAssignOpStorageClass::pickOutIRNodeData ( SgCompoundAssignOp* pointer ) 
   { 
     SgCompoundAssignOp* source = (SgCompoundAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCompoundAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCompoundAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCompoundAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCompoundAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46802 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPlusAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46815 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPlusAssignOpStorageClass::pickOutIRNodeData ( SgPlusAssignOp* pointer ) 
   { 
     SgPlusAssignOp* source = (SgPlusAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPlusAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPlusAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPlusAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPlusAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46880 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMinusAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46893 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMinusAssignOpStorageClass::pickOutIRNodeData ( SgMinusAssignOp* pointer ) 
   { 
     SgMinusAssignOp* source = (SgMinusAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMinusAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMinusAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMinusAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMinusAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 46958 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAndAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 46971 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAndAssignOpStorageClass::pickOutIRNodeData ( SgAndAssignOp* pointer ) 
   { 
     SgAndAssignOp* source = (SgAndAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAndAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAndAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAndAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAndAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47036 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIorAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47049 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIorAssignOpStorageClass::pickOutIRNodeData ( SgIorAssignOp* pointer ) 
   { 
     SgIorAssignOp* source = (SgIorAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIorAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIorAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIorAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIorAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47114 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMultAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47127 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMultAssignOpStorageClass::pickOutIRNodeData ( SgMultAssignOp* pointer ) 
   { 
     SgMultAssignOp* source = (SgMultAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMultAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMultAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMultAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMultAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47192 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDivAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47205 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDivAssignOpStorageClass::pickOutIRNodeData ( SgDivAssignOp* pointer ) 
   { 
     SgDivAssignOp* source = (SgDivAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDivAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDivAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDivAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDivAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47270 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47283 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgModAssignOpStorageClass::pickOutIRNodeData ( SgModAssignOp* pointer ) 
   { 
     SgModAssignOp* source = (SgModAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgModAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47348 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgXorAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47361 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgXorAssignOpStorageClass::pickOutIRNodeData ( SgXorAssignOp* pointer ) 
   { 
     SgXorAssignOp* source = (SgXorAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgXorAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgXorAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgXorAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgXorAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47426 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47439 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLshiftAssignOpStorageClass::pickOutIRNodeData ( SgLshiftAssignOp* pointer ) 
   { 
     SgLshiftAssignOp* source = (SgLshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47504 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47517 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRshiftAssignOpStorageClass::pickOutIRNodeData ( SgRshiftAssignOp* pointer ) 
   { 
     SgRshiftAssignOp* source = (SgRshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47582 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaUnsignedRshiftAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47595 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaUnsignedRshiftAssignOpStorageClass::pickOutIRNodeData ( SgJavaUnsignedRshiftAssignOp* pointer ) 
   { 
     SgJavaUnsignedRshiftAssignOp* source = (SgJavaUnsignedRshiftAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaUnsignedRshiftAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaUnsignedRshiftAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaUnsignedRshiftAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaUnsignedRshiftAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47660 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntegerDivideAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47673 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIntegerDivideAssignOpStorageClass::pickOutIRNodeData ( SgIntegerDivideAssignOp* pointer ) 
   { 
     SgIntegerDivideAssignOp* source = (SgIntegerDivideAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIntegerDivideAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntegerDivideAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntegerDivideAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntegerDivideAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47738 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExponentiationAssignOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47751 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExponentiationAssignOpStorageClass::pickOutIRNodeData ( SgExponentiationAssignOp* pointer ) 
   { 
     SgExponentiationAssignOp* source = (SgExponentiationAssignOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgExponentiationAssignOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExponentiationAssignOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExponentiationAssignOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExponentiationAssignOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47816 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMembershipOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47829 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMembershipOpStorageClass::pickOutIRNodeData ( SgMembershipOp* pointer ) 
   { 
     SgMembershipOp* source = (SgMembershipOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMembershipOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMembershipOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMembershipOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMembershipOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47894 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSpaceshipOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47907 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSpaceshipOpStorageClass::pickOutIRNodeData ( SgSpaceshipOp* pointer ) 
   { 
     SgSpaceshipOp* source = (SgSpaceshipOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSpaceshipOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSpaceshipOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSpaceshipOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSpaceshipOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 47972 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNonMembershipOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 47985 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNonMembershipOpStorageClass::pickOutIRNodeData ( SgNonMembershipOp* pointer ) 
   { 
     SgNonMembershipOp* source = (SgNonMembershipOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNonMembershipOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNonMembershipOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNonMembershipOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNonMembershipOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48050 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIsOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48063 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIsOpStorageClass::pickOutIRNodeData ( SgIsOp* pointer ) 
   { 
     SgIsOp* source = (SgIsOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIsOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIsOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIsOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIsOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48128 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIsNotOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48141 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIsNotOpStorageClass::pickOutIRNodeData ( SgIsNotOp* pointer ) 
   { 
     SgIsNotOp* source = (SgIsNotOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIsNotOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIsNotOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIsNotOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIsNotOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48206 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDotDotExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48219 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDotDotExpStorageClass::pickOutIRNodeData ( SgDotDotExp* pointer ) 
   { 
     SgDotDotExp* source = (SgDotDotExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDotDotExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDotDotExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDotDotExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDotDotExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48284 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElementwiseOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48297 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElementwiseOpStorageClass::pickOutIRNodeData ( SgElementwiseOp* pointer ) 
   { 
     SgElementwiseOp* source = (SgElementwiseOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElementwiseOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElementwiseOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElementwiseOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElementwiseOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48362 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElementwiseMultiplyOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48375 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElementwiseMultiplyOpStorageClass::pickOutIRNodeData ( SgElementwiseMultiplyOp* pointer ) 
   { 
     SgElementwiseMultiplyOp* source = (SgElementwiseMultiplyOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElementwiseMultiplyOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElementwiseMultiplyOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElementwiseMultiplyOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElementwiseMultiplyOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48440 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElementwisePowerOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48453 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElementwisePowerOpStorageClass::pickOutIRNodeData ( SgElementwisePowerOp* pointer ) 
   { 
     SgElementwisePowerOp* source = (SgElementwisePowerOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElementwisePowerOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElementwisePowerOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElementwisePowerOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElementwisePowerOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48518 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElementwiseLeftDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48531 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElementwiseLeftDivideOpStorageClass::pickOutIRNodeData ( SgElementwiseLeftDivideOp* pointer ) 
   { 
     SgElementwiseLeftDivideOp* source = (SgElementwiseLeftDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElementwiseLeftDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElementwiseLeftDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElementwiseLeftDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElementwiseLeftDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48596 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElementwiseDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48609 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElementwiseDivideOpStorageClass::pickOutIRNodeData ( SgElementwiseDivideOp* pointer ) 
   { 
     SgElementwiseDivideOp* source = (SgElementwiseDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElementwiseDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElementwiseDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElementwiseDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElementwiseDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48674 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElementwiseAddOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48687 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElementwiseAddOpStorageClass::pickOutIRNodeData ( SgElementwiseAddOp* pointer ) 
   { 
     SgElementwiseAddOp* source = (SgElementwiseAddOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElementwiseAddOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElementwiseAddOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElementwiseAddOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElementwiseAddOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48752 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgElementwiseSubtractOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48765 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgElementwiseSubtractOpStorageClass::pickOutIRNodeData ( SgElementwiseSubtractOp* pointer ) 
   { 
     SgElementwiseSubtractOp* source = (SgElementwiseSubtractOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgElementwiseSubtractOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgElementwiseSubtractOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgElementwiseSubtractOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgElementwiseSubtractOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48830 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPowerOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48843 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPowerOpStorageClass::pickOutIRNodeData ( SgPowerOp* pointer ) 
   { 
     SgPowerOp* source = (SgPowerOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPowerOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPowerOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPowerOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPowerOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48908 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLeftDivideOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48921 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLeftDivideOpStorageClass::pickOutIRNodeData ( SgLeftDivideOp* pointer ) 
   { 
     SgLeftDivideOp* source = (SgLeftDivideOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLeftDivideOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLeftDivideOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLeftDivideOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLeftDivideOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 48986 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRemOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 48999 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRemOpStorageClass::pickOutIRNodeData ( SgRemOp* pointer ) 
   { 
     SgRemOp* source = (SgRemOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRemOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRemOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRemOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRemOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49064 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReplicationOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49077 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgReplicationOpStorageClass::pickOutIRNodeData ( SgReplicationOp* pointer ) 
   { 
     SgReplicationOp* source = (SgReplicationOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgReplicationOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReplicationOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReplicationOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReplicationOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49142 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAtOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49155 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAtOpStorageClass::pickOutIRNodeData ( SgAtOp* pointer ) 
   { 
     SgAtOp* source = (SgAtOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand_i );
     storageOf_rhs_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAtOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAtOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAtOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAtOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49220 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgExprListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49233 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgExprListExpStorageClass::pickOutIRNodeData ( SgExprListExp* pointer ) 
   { 
     SgExprListExp* source = (SgExprListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgExprListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgExprListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgExprListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgExprListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49316 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49329 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgListExpStorageClass::pickOutIRNodeData ( SgListExp* pointer ) 
   { 
     SgListExp* source = (SgListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49412 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTupleExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49425 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTupleExpStorageClass::pickOutIRNodeData ( SgTupleExp* pointer ) 
   { 
     SgTupleExp* source = (SgTupleExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTupleExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTupleExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTupleExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTupleExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49508 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMatrixExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49521 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMatrixExpStorageClass::pickOutIRNodeData ( SgMatrixExp* pointer ) 
   { 
     SgMatrixExp* source = (SgMatrixExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgExpressionPtrList::value_type *  tempListexpressions = new SgExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMatrixExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMatrixExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMatrixExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMatrixExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49604 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgValueExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49617 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgValueExpStorageClass::pickOutIRNodeData ( SgValueExp* pointer ) 
   { 
     SgValueExp* source = (SgValueExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgValueExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgValueExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgValueExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgValueExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49679 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBoolValExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49692 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBoolValExpStorageClass::pickOutIRNodeData ( SgBoolValExp* pointer ) 
   { 
     SgBoolValExp* source = (SgBoolValExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBoolValExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBoolValExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBoolValExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBoolValExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49755 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49768 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStringValStorageClass::pickOutIRNodeData ( SgStringVal* pointer ) 
   { 
     SgStringVal* source = (SgStringVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value.storeDataInEasyStorageClass(source->p_value);
     storageOf_wcharString =  source->p_wcharString ;
     storageOf_stringDelimiter =  source->p_stringDelimiter ;
     storageOf_is16bitString =  source->p_is16bitString ;
     storageOf_is32bitString =  source->p_is32bitString ;
     storageOf_isRawString =  source->p_isRawString ;
     storageOf_raw_string_value.storeDataInEasyStorageClass(source->p_raw_string_value);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStringValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStringValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStringValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49841 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgShortValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49854 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgShortValStorageClass::pickOutIRNodeData ( SgShortVal* pointer ) 
   { 
     SgShortVal* source = (SgShortVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgShortValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgShortValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgShortValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgShortValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 49922 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 49935 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCharValStorageClass::pickOutIRNodeData ( SgCharVal* pointer ) 
   { 
     SgCharVal* source = (SgCharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50003 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedCharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50016 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedCharValStorageClass::pickOutIRNodeData ( SgUnsignedCharVal* pointer ) 
   { 
     SgUnsignedCharVal* source = (SgUnsignedCharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnsignedCharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedCharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedCharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedCharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50084 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgWcharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50097 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgWcharValStorageClass::pickOutIRNodeData ( SgWcharVal* pointer ) 
   { 
     SgWcharVal* source = (SgWcharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_valueUL =  source->p_valueUL ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgWcharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgWcharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgWcharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgWcharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50165 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedShortValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50178 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedShortValStorageClass::pickOutIRNodeData ( SgUnsignedShortVal* pointer ) 
   { 
     SgUnsignedShortVal* source = (SgUnsignedShortVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnsignedShortValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedShortValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedShortValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedShortValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50246 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50259 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIntValStorageClass::pickOutIRNodeData ( SgIntVal* pointer ) 
   { 
     SgIntVal* source = (SgIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50327 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50340 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEnumValStorageClass::pickOutIRNodeData ( SgEnumVal* pointer ) 
   { 
     SgEnumVal* source = (SgEnumVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_requiresNameQualification =  source->p_requiresNameQualification ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEnumValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50413 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50426 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedIntValStorageClass::pickOutIRNodeData ( SgUnsignedIntVal* pointer ) 
   { 
     SgUnsignedIntVal* source = (SgUnsignedIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnsignedIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50494 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50507 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLongIntValStorageClass::pickOutIRNodeData ( SgLongIntVal* pointer ) 
   { 
     SgLongIntVal* source = (SgLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50575 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50588 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLongLongIntValStorageClass::pickOutIRNodeData ( SgLongLongIntVal* pointer ) 
   { 
     SgLongLongIntVal* source = (SgLongLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLongLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50656 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedLongLongIntValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50669 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedLongLongIntValStorageClass::pickOutIRNodeData ( SgUnsignedLongLongIntVal* pointer ) 
   { 
     SgUnsignedLongLongIntVal* source = (SgUnsignedLongLongIntVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnsignedLongLongIntValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedLongLongIntValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedLongLongIntValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedLongLongIntValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50737 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnsignedLongValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50750 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnsignedLongValStorageClass::pickOutIRNodeData ( SgUnsignedLongVal* pointer ) 
   { 
     SgUnsignedLongVal* source = (SgUnsignedLongVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnsignedLongValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnsignedLongValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnsignedLongValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnsignedLongValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50818 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFloatValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50831 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFloatValStorageClass::pickOutIRNodeData ( SgFloatVal* pointer ) 
   { 
     SgFloatVal* source = (SgFloatVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFloatValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFloatValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFloatValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFloatValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50899 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDoubleValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50912 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDoubleValStorageClass::pickOutIRNodeData ( SgDoubleVal* pointer ) 
   { 
     SgDoubleVal* source = (SgDoubleVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDoubleValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDoubleValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDoubleValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDoubleValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 50980 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLongDoubleValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 50993 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLongDoubleValStorageClass::pickOutIRNodeData ( SgLongDoubleVal* pointer ) 
   { 
     SgLongDoubleVal* source = (SgLongDoubleVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLongDoubleValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLongDoubleValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLongDoubleValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLongDoubleValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51061 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComplexValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51074 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgComplexValStorageClass::pickOutIRNodeData ( SgComplexVal* pointer ) 
   { 
     SgComplexVal* source = (SgComplexVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_real_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_real_value );
     storageOf_imaginary_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_imaginary_value );
     storageOf_precisionType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_precisionType );
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgComplexValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComplexValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComplexValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComplexValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51144 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcThreadsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51157 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcThreadsStorageClass::pickOutIRNodeData ( SgUpcThreads* pointer ) 
   { 
     SgUpcThreads* source = (SgUpcThreads*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcThreadsStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcThreadsStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcThreadsStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcThreadsStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51225 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcMythreadStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51238 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcMythreadStorageClass::pickOutIRNodeData ( SgUpcMythread* pointer ) 
   { 
     SgUpcMythread* source = (SgUpcMythread*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcMythreadStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcMythreadStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcMythreadStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcMythreadStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51306 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateParameterValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51319 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateParameterValStorageClass::pickOutIRNodeData ( SgTemplateParameterVal* pointer ) 
   { 
     SgTemplateParameterVal* source = (SgTemplateParameterVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_template_parameter_position =  source->p_template_parameter_position ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_valueType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_valueType );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateParameterValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateParameterValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateParameterValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateParameterValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51388 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullptrValExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51401 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNullptrValExpStorageClass::pickOutIRNodeData ( SgNullptrValExp* pointer ) 
   { 
     SgNullptrValExp* source = (SgNullptrValExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNullptrValExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullptrValExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullptrValExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullptrValExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51463 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgChar16ValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51476 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgChar16ValStorageClass::pickOutIRNodeData ( SgChar16Val* pointer ) 
   { 
     SgChar16Val* source = (SgChar16Val*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_valueUL =  source->p_valueUL ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgChar16ValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgChar16ValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgChar16ValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgChar16ValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51544 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgChar32ValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51557 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgChar32ValStorageClass::pickOutIRNodeData ( SgChar32Val* pointer ) 
   { 
     SgChar32Val* source = (SgChar32Val*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_valueUL =  source->p_valueUL ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgChar32ValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgChar32ValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgChar32ValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgChar32ValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51625 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFloat80ValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51638 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFloat80ValStorageClass::pickOutIRNodeData ( SgFloat80Val* pointer ) 
   { 
     SgFloat80Val* source = (SgFloat80Val*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFloat80ValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFloat80ValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFloat80ValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFloat80ValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51706 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFloat128ValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51719 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFloat128ValStorageClass::pickOutIRNodeData ( SgFloat128Val* pointer ) 
   { 
     SgFloat128Val* source = (SgFloat128Val*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFloat128ValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFloat128ValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFloat128ValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFloat128ValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51787 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVoidValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51800 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVoidValStorageClass::pickOutIRNodeData ( SgVoidVal* pointer ) 
   { 
     SgVoidVal* source = (SgVoidVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVoidValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVoidValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVoidValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVoidValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51862 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaFloatValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51875 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaFloatValStorageClass::pickOutIRNodeData ( SgAdaFloatVal* pointer ) 
   { 
     SgAdaFloatVal* source = (SgAdaFloatVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaFloatValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaFloatValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaFloatValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaFloatValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 51942 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSignedCharValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 51955 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSignedCharValStorageClass::pickOutIRNodeData ( SgSignedCharVal* pointer ) 
   { 
     SgSignedCharVal* source = (SgSignedCharVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSignedCharValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSignedCharValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSignedCharValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSignedCharValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52023 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialBitValStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52036 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialBitValStorageClass::pickOutIRNodeData ( SgJovialBitVal* pointer ) 
   { 
     SgJovialBitVal* source = (SgJovialBitVal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_valueString.storeDataInEasyStorageClass(source->p_valueString);
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialBitValStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialBitValStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialBitValStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialBitValStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52103 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCallExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52116 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCallExpressionStorageClass::pickOutIRNodeData ( SgCallExpression* pointer ) 
   { 
     SgCallExpression* source = (SgCallExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCallExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCallExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCallExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCallExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52180 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionCallExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52193 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionCallExpStorageClass::pickOutIRNodeData ( SgFunctionCallExp* pointer ) 
   { 
     SgFunctionCallExp* source = (SgFunctionCallExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_uses_operator_syntax =  source->p_uses_operator_syntax ;
     storageOf_usesObjectCallSyntax =  source->p_usesObjectCallSyntax ;
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionCallExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionCallExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionCallExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionCallExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52259 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCudaKernelCallExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52272 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCudaKernelCallExpStorageClass::pickOutIRNodeData ( SgCudaKernelCallExp* pointer ) 
   { 
     SgCudaKernelCallExp* source = (SgCudaKernelCallExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_exec_config = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exec_config );
     storageOf_uses_operator_syntax =  source->p_uses_operator_syntax ;
     storageOf_usesObjectCallSyntax =  source->p_usesObjectCallSyntax ;
     storageOf_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCudaKernelCallExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCudaKernelCallExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCudaKernelCallExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCudaKernelCallExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52339 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcLocalsizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52352 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcLocalsizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcLocalsizeofExpression* pointer ) 
   { 
     SgUpcLocalsizeofExpression* source = (SgUpcLocalsizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcLocalsizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcLocalsizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52416 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcBlocksizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52429 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcBlocksizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcBlocksizeofExpression* pointer ) 
   { 
     SgUpcBlocksizeofExpression* source = (SgUpcBlocksizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcBlocksizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcBlocksizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52493 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUpcElemsizeofExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52506 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUpcElemsizeofExpressionStorageClass::pickOutIRNodeData ( SgUpcElemsizeofExpression* pointer ) 
   { 
     SgUpcElemsizeofExpression* source = (SgUpcElemsizeofExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUpcElemsizeofExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUpcElemsizeofExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUpcElemsizeofExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUpcElemsizeofExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52570 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaInstanceOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52583 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaInstanceOfOpStorageClass::pickOutIRNodeData ( SgJavaInstanceOfOp* pointer ) 
   { 
     SgJavaInstanceOfOp* source = (SgJavaInstanceOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaInstanceOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaInstanceOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaInstanceOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaInstanceOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52647 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSuperExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52660 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSuperExpStorageClass::pickOutIRNodeData ( SgSuperExp* pointer ) 
   { 
     SgSuperExp* source = (SgSuperExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_symbol );
     storageOf_pobj_super =  source->p_pobj_super ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSuperExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSuperExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSuperExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSuperExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52723 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeIdOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52736 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeIdOpStorageClass::pickOutIRNodeData ( SgTypeIdOp* pointer ) 
   { 
     SgTypeIdOp* source = (SgTypeIdOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_for_pointer_to_member_class_length =  source->p_name_qualification_for_pointer_to_member_class_length ;
     storageOf_type_elaboration_for_pointer_to_member_class_required =  source->p_type_elaboration_for_pointer_to_member_class_required ;
     storageOf_global_qualification_for_pointer_to_member_class_required =  source->p_global_qualification_for_pointer_to_member_class_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeIdOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeIdOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeIdOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeIdOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52805 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConditionalExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52818 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgConditionalExpStorageClass::pickOutIRNodeData ( SgConditionalExp* pointer ) 
   { 
     SgConditionalExp* source = (SgConditionalExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_conditional_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_conditional_exp );
     storageOf_true_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_true_exp );
     storageOf_false_exp = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_false_exp );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgConditionalExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConditionalExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConditionalExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConditionalExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52883 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNewExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52896 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNewExpStorageClass::pickOutIRNodeData ( SgNewExp* pointer ) 
   { 
     SgNewExp* source = (SgNewExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_specified_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_specified_type );
     storageOf_placement_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_placement_args );
     storageOf_constructor_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constructor_args );
     storageOf_builtin_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_builtin_args );
     storageOf_need_global_specifier =  source->p_need_global_specifier ;
     storageOf_newOperatorDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_newOperatorDeclaration );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_name_qualification_for_pointer_to_member_class_length =  source->p_name_qualification_for_pointer_to_member_class_length ;
     storageOf_type_elaboration_for_pointer_to_member_class_required =  source->p_type_elaboration_for_pointer_to_member_class_required ;
     storageOf_global_qualification_for_pointer_to_member_class_required =  source->p_global_qualification_for_pointer_to_member_class_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNewExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNewExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNewExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNewExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 52969 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDeleteExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 52982 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDeleteExpStorageClass::pickOutIRNodeData ( SgDeleteExp* pointer ) 
   { 
     SgDeleteExp* source = (SgDeleteExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_variable );
     storageOf_is_array =  source->p_is_array ;
     storageOf_need_global_specifier =  source->p_need_global_specifier ;
     storageOf_deleteOperatorDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_deleteOperatorDeclaration );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDeleteExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDeleteExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDeleteExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDeleteExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53047 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgThisExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53060 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgThisExpStorageClass::pickOutIRNodeData ( SgThisExp* pointer ) 
   { 
     SgThisExp* source = (SgThisExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_symbol );
     storageOf_nonreal_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonreal_symbol );
     storageOf_pobj_this =  source->p_pobj_this ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgThisExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgThisExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgThisExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgThisExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53124 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53137 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRefExpStorageClass::pickOutIRNodeData ( SgRefExp* pointer ) 
   { 
     SgRefExp* source = (SgRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type_name );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53199 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53212 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgInitializerStorageClass::pickOutIRNodeData ( SgInitializer* pointer ) 
   { 
     SgInitializer* source = (SgInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53275 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAggregateInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53288 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAggregateInitializerStorageClass::pickOutIRNodeData ( SgAggregateInitializer* pointer ) 
   { 
     SgAggregateInitializer* source = (SgAggregateInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_initializers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializers );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_explicit_braces =  source->p_need_explicit_braces ;
     storageOf_uses_compound_literal =  source->p_uses_compound_literal ;
     storageOf_requiresGlobalNameQualificationOnType =  source->p_requiresGlobalNameQualificationOnType ;
     storageOf_name_qualification_length_for_type =  source->p_name_qualification_length_for_type ;
     storageOf_type_elaboration_required_for_type =  source->p_type_elaboration_required_for_type ;
     storageOf_global_qualification_required_for_type =  source->p_global_qualification_required_for_type ;
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAggregateInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAggregateInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAggregateInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAggregateInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53360 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCompoundInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53373 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCompoundInitializerStorageClass::pickOutIRNodeData ( SgCompoundInitializer* pointer ) 
   { 
     SgCompoundInitializer* source = (SgCompoundInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_initializers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializers );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCompoundInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCompoundInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCompoundInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCompoundInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53438 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgConstructorInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53451 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgConstructorInitializerStorageClass::pickOutIRNodeData ( SgConstructorInitializer* pointer ) 
   { 
     SgConstructorInitializer* source = (SgConstructorInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_name =  source->p_need_name ;
     storageOf_need_qualifier =  source->p_need_qualifier ;
     storageOf_need_parenthesis_after_name =  source->p_need_parenthesis_after_name ;
     storageOf_associated_class_unknown =  source->p_associated_class_unknown ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_is_used_in_conditional =  source->p_is_used_in_conditional ;
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgConstructorInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgConstructorInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgConstructorInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgConstructorInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53525 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAssignInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53538 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAssignInitializerStorageClass::pickOutIRNodeData ( SgAssignInitializer* pointer ) 
   { 
     SgAssignInitializer* source = (SgAssignInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_i );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAssignInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAssignInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAssignInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAssignInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53603 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDesignatedInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53616 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDesignatedInitializerStorageClass::pickOutIRNodeData ( SgDesignatedInitializer* pointer ) 
   { 
     SgDesignatedInitializer* source = (SgDesignatedInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_designatorList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_designatorList );
     storageOf_memberInit = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_memberInit );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDesignatedInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDesignatedInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDesignatedInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDesignatedInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53681 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgBracedInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53694 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgBracedInitializerStorageClass::pickOutIRNodeData ( SgBracedInitializer* pointer ) 
   { 
     SgBracedInitializer* source = (SgBracedInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_initializers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_initializers );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgBracedInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgBracedInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgBracedInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgBracedInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53759 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaAncestorInitializerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53772 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaAncestorInitializerStorageClass::pickOutIRNodeData ( SgAdaAncestorInitializer* pointer ) 
   { 
     SgAdaAncestorInitializer* source = (SgAdaAncestorInitializer*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_ancestor = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ancestor );
     storageOf_is_explicit_cast =  source->p_is_explicit_cast ;
     storageOf_is_braced_initialized =  source->p_is_braced_initialized ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaAncestorInitializerStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaAncestorInitializerStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaAncestorInitializerStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaAncestorInitializerStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53836 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgStartOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53849 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgStartOpStorageClass::pickOutIRNodeData ( SgVarArgStartOp* pointer ) 
   { 
     SgVarArgStartOp* source = (SgVarArgStartOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand );
     storageOf_rhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVarArgStartOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgStartOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgStartOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgStartOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53913 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 53926 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgOpStorageClass::pickOutIRNodeData ( SgVarArgOp* pointer ) 
   { 
     SgVarArgOp* source = (SgVarArgOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVarArgOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 53989 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgEndOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54002 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgEndOpStorageClass::pickOutIRNodeData ( SgVarArgEndOp* pointer ) 
   { 
     SgVarArgEndOp* source = (SgVarArgEndOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVarArgEndOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgEndOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgEndOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgEndOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54065 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgCopyOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54078 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgCopyOpStorageClass::pickOutIRNodeData ( SgVarArgCopyOp* pointer ) 
   { 
     SgVarArgCopyOp* source = (SgVarArgCopyOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs_operand );
     storageOf_rhs_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs_operand );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVarArgCopyOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgCopyOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgCopyOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgCopyOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54142 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarArgStartOneOperandOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54155 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVarArgStartOneOperandOpStorageClass::pickOutIRNodeData ( SgVarArgStartOneOperandOp* pointer ) 
   { 
     SgVarArgStartOneOperandOp* source = (SgVarArgStartOneOperandOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVarArgStartOneOperandOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarArgStartOneOperandOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarArgStartOneOperandOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarArgStartOneOperandOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54218 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNullExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54231 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNullExpressionStorageClass::pickOutIRNodeData ( SgNullExpression* pointer ) 
   { 
     SgNullExpression* source = (SgNullExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNullExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNullExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNullExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNullExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54292 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariantExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54305 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVariantExpressionStorageClass::pickOutIRNodeData ( SgVariantExpression* pointer ) 
   { 
     SgVariantExpression* source = (SgVariantExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVariantExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariantExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariantExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariantExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54366 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSubscriptExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54379 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSubscriptExpressionStorageClass::pickOutIRNodeData ( SgSubscriptExpression* pointer ) 
   { 
     SgSubscriptExpression* source = (SgSubscriptExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lowerBound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lowerBound );
     storageOf_upperBound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_upperBound );
     storageOf_stride = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stride );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSubscriptExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSubscriptExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSubscriptExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSubscriptExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54443 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgColonShapeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54456 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgColonShapeExpStorageClass::pickOutIRNodeData ( SgColonShapeExp* pointer ) 
   { 
     SgColonShapeExp* source = (SgColonShapeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgColonShapeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgColonShapeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgColonShapeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgColonShapeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54517 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsteriskShapeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54530 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsteriskShapeExpStorageClass::pickOutIRNodeData ( SgAsteriskShapeExp* pointer ) 
   { 
     SgAsteriskShapeExp* source = (SgAsteriskShapeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsteriskShapeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsteriskShapeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsteriskShapeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsteriskShapeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54591 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgImpliedDoStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54604 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgImpliedDoStorageClass::pickOutIRNodeData ( SgImpliedDo* pointer ) 
   { 
     SgImpliedDo* source = (SgImpliedDo*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_do_var_initialization = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_do_var_initialization );
     storageOf_last_val = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_last_val );
     storageOf_increment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_increment );
     storageOf_object_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_object_list );
     storageOf_implied_do_scope = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_implied_do_scope );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgImpliedDoStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgImpliedDoStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgImpliedDoStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgImpliedDoStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54670 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIOItemExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54683 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIOItemExpressionStorageClass::pickOutIRNodeData ( SgIOItemExpression* pointer ) 
   { 
     SgIOItemExpression* source = (SgIOItemExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_io_item = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_io_item );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIOItemExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIOItemExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIOItemExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIOItemExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54750 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgActualArgumentExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54763 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgActualArgumentExpressionStorageClass::pickOutIRNodeData ( SgActualArgumentExpression* pointer ) 
   { 
     SgActualArgumentExpression* source = (SgActualArgumentExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_argument_name.pickOutIRNodeData( &(source->p_argument_name) );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgActualArgumentExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgActualArgumentExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgActualArgumentExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgActualArgumentExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54830 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStatementExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54843 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStatementExpressionStorageClass::pickOutIRNodeData ( SgStatementExpression* pointer ) 
   { 
     SgStatementExpression* source = (SgStatementExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_statement );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStatementExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStatementExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStatementExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStatementExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54905 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 54918 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmOpStorageClass::pickOutIRNodeData ( SgAsmOp* pointer ) 
   { 
     SgAsmOp* source = (SgAsmOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_constraint =  source->p_constraint ;
     storageOf_modifiers =  source->p_modifiers ;
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_recordRawAsmOperandDescriptions =  source->p_recordRawAsmOperandDescriptions ;
     storageOf_isOutputOperand =  source->p_isOutputOperand ;
     storageOf_constraintString.storeDataInEasyStorageClass(source->p_constraintString);
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 54990 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCudaKernelExecConfigStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55003 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCudaKernelExecConfigStorageClass::pickOutIRNodeData ( SgCudaKernelExecConfig* pointer ) 
   { 
     SgCudaKernelExecConfig* source = (SgCudaKernelExecConfig*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_grid = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_grid );
     storageOf_blocks = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_blocks );
     storageOf_shared = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_shared );
     storageOf_stream = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stream );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCudaKernelExecConfigStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCudaKernelExecConfigStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCudaKernelExecConfigStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCudaKernelExecConfigStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55068 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgUnknownArrayOrFunctionReferenceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55081 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgUnknownArrayOrFunctionReferenceStorageClass::pickOutIRNodeData ( SgUnknownArrayOrFunctionReference* pointer ) 
   { 
     SgUnknownArrayOrFunctionReference* source = (SgUnknownArrayOrFunctionReference*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_named_reference = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_named_reference );
     storageOf_expression_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_list );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgUnknownArrayOrFunctionReferenceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgUnknownArrayOrFunctionReferenceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55149 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgPseudoDestructorRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55162 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgPseudoDestructorRefExpStorageClass::pickOutIRNodeData ( SgPseudoDestructorRefExp* pointer ) 
   { 
     SgPseudoDestructorRefExp* source = (SgPseudoDestructorRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_object_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_object_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgPseudoDestructorRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgPseudoDestructorRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgPseudoDestructorRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgPseudoDestructorRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55228 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCAFCoExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55241 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCAFCoExpressionStorageClass::pickOutIRNodeData ( SgCAFCoExpression* pointer ) 
   { 
     SgCAFCoExpression* source = (SgCAFCoExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_teamId = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamId );
     storageOf_teamRank = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_teamRank );
     storageOf_referData = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_referData );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCAFCoExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCAFCoExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCAFCoExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCAFCoExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55305 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSizeOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55318 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSizeOfOpStorageClass::pickOutIRNodeData ( SgSizeOfOp* pointer ) 
   { 
     SgSizeOfOp* source = (SgSizeOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_sizeOfContainsBaseTypeDefiningDeclaration =  source->p_sizeOfContainsBaseTypeDefiningDeclaration ;
     storageOf_is_objectless_nonstatic_data_member_reference =  source->p_is_objectless_nonstatic_data_member_reference ;
     storageOf_name_qualification_for_pointer_to_member_class_length =  source->p_name_qualification_for_pointer_to_member_class_length ;
     storageOf_type_elaboration_for_pointer_to_member_class_required =  source->p_type_elaboration_for_pointer_to_member_class_required ;
     storageOf_global_qualification_for_pointer_to_member_class_required =  source->p_global_qualification_for_pointer_to_member_class_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSizeOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSizeOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSizeOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSizeOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55390 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLambdaRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55403 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLambdaRefExpStorageClass::pickOutIRNodeData ( SgLambdaRefExp* pointer ) 
   { 
     SgLambdaRefExp* source = (SgLambdaRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_functionDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_functionDeclaration );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLambdaRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLambdaRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLambdaRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLambdaRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55465 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDictionaryExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55478 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDictionaryExpStorageClass::pickOutIRNodeData ( SgDictionaryExp* pointer ) 
   { 
     SgDictionaryExp* source = (SgDictionaryExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgKeyDatumPairPtrList::iterator i_key_datum_pairs = source->p_key_datum_pairs.begin() ; 
     unsigned int tempListCountkey_datum_pairs = 0; 
     SgKeyDatumPairPtrList::value_type *  tempListkey_datum_pairs = new SgKeyDatumPairPtrList::value_type[ source->p_key_datum_pairs.size() ]; 
     for ( ; i_key_datum_pairs != source->p_key_datum_pairs.end(); ++i_key_datum_pairs ) 
        {
          tempListkey_datum_pairs[tempListCountkey_datum_pairs] = *i_key_datum_pairs;
          tempListCountkey_datum_pairs++; 
          (*i_key_datum_pairs) = (SgKeyDatumPairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_key_datum_pairs ) );
        }
     storageOf_key_datum_pairs.storeDataInEasyStorageClass(source->p_key_datum_pairs);
     tempListCountkey_datum_pairs = 0; 
     i_key_datum_pairs = source->p_key_datum_pairs.begin() ; 
     for ( ; i_key_datum_pairs != source->p_key_datum_pairs.end(); ++i_key_datum_pairs ) 
        {
          *i_key_datum_pairs = tempListkey_datum_pairs[tempListCountkey_datum_pairs] ;
          tempListCountkey_datum_pairs++; 
        }
      delete [] tempListkey_datum_pairs; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDictionaryExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgKeyDatumPairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDictionaryExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgKeyDatumPairPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDictionaryExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgKeyDatumPairPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDictionaryExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgKeyDatumPairPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55561 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgKeyDatumPairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55574 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgKeyDatumPairStorageClass::pickOutIRNodeData ( SgKeyDatumPair* pointer ) 
   { 
     SgKeyDatumPair* source = (SgKeyDatumPair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_key = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_key );
     storageOf_datum = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_datum );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgKeyDatumPairStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgKeyDatumPairStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgKeyDatumPairStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgKeyDatumPairStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55637 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgReferenceExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55650 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgReferenceExpStorageClass::pickOutIRNodeData ( SgReferenceExp* pointer ) 
   { 
     SgReferenceExp* source = (SgReferenceExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgReferenceExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgReferenceExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgReferenceExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgReferenceExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55711 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVarRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55724 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVarRefExpStorageClass::pickOutIRNodeData ( SgVarRefExp* pointer ) 
   { 
     SgVarRefExp* source = (SgVarRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVarRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVarRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVarRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVarRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55790 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55803 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLabelRefExpStorageClass::pickOutIRNodeData ( SgLabelRefExp* pointer ) 
   { 
     SgLabelRefExp* source = (SgLabelRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLabelRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55865 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassNameRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55878 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClassNameRefExpStorageClass::pickOutIRNodeData ( SgClassNameRefExp* pointer ) 
   { 
     SgClassNameRefExp* source = (SgClassNameRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClassNameRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassNameRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassNameRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassNameRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 55940 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNonrealRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 55953 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNonrealRefExpStorageClass::pickOutIRNodeData ( SgNonrealRefExp* pointer ) 
   { 
     SgNonrealRefExp* source = (SgNonrealRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNonrealRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNonrealRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNonrealRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNonrealRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56018 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgScopedRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56031 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgScopedRefExpStorageClass::pickOutIRNodeData ( SgScopedRefExp* pointer ) 
   { 
     SgScopedRefExp* source = (SgScopedRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgScopedRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgScopedRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgScopedRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgScopedRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56094 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56107 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeRefExpStorageClass::pickOutIRNodeData ( SgTypeRefExp* pointer ) 
   { 
     SgTypeRefExp* source = (SgTypeRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_named_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_named_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56169 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56182 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionRefExpStorageClass::pickOutIRNodeData ( SgFunctionRefExp* pointer ) 
   { 
     SgFunctionRefExp* source = (SgFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_function_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type );
     storageOf_originalExpressionTree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_originalExpressionTree );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56249 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56262 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionRefExpStorageClass::pickOutIRNodeData ( SgMemberFunctionRefExp* pointer ) 
   { 
     SgMemberFunctionRefExp* source = (SgMemberFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_virtual_call =  source->p_virtual_call ;
     storageOf_function_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_function_type );
     storageOf_need_qualifier =  source->p_need_qualifier ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMemberFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56330 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56343 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateFunctionRefExpStorageClass::pickOutIRNodeData ( SgTemplateFunctionRefExp* pointer ) 
   { 
     SgTemplateFunctionRefExp* source = (SgTemplateFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56408 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateMemberFunctionRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56421 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateMemberFunctionRefExpStorageClass::pickOutIRNodeData ( SgTemplateMemberFunctionRefExp* pointer ) 
   { 
     SgTemplateMemberFunctionRefExp* source = (SgTemplateMemberFunctionRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol_i = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol_i );
     storageOf_virtual_call =  source->p_virtual_call ;
     storageOf_need_qualifier =  source->p_need_qualifier ;
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateMemberFunctionRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateMemberFunctionRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateMemberFunctionRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateMemberFunctionRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56488 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56501 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgComprehensionStorageClass::pickOutIRNodeData ( SgComprehension* pointer ) 
   { 
     SgComprehension* source = (SgComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_target = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_target );
     storageOf_iter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_iter );
     storageOf_filters = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_filters );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56565 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgListComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56578 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgListComprehensionStorageClass::pickOutIRNodeData ( SgListComprehension* pointer ) 
   { 
     SgListComprehension* source = (SgListComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_generators = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_generators );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgListComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgListComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgListComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgListComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56641 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSetComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56654 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSetComprehensionStorageClass::pickOutIRNodeData ( SgSetComprehension* pointer ) 
   { 
     SgSetComprehension* source = (SgSetComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_generators = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_generators );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSetComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSetComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSetComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSetComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56717 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDictionaryComprehensionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56730 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDictionaryComprehensionStorageClass::pickOutIRNodeData ( SgDictionaryComprehension* pointer ) 
   { 
     SgDictionaryComprehension* source = (SgDictionaryComprehension*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_element = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_element );
     storageOf_generators = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_generators );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDictionaryComprehensionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDictionaryComprehensionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDictionaryComprehensionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDictionaryComprehensionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56793 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNaryOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56806 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNaryOpStorageClass::pickOutIRNodeData ( SgNaryOp* pointer ) 
   { 
     SgNaryOp* source = (SgNaryOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_operators.storeDataInEasyStorageClass(source->p_operators);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNaryOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < VariantTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNaryOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < VariantTList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNaryOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < VariantTList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNaryOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < VariantTList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56894 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNaryBooleanOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 56907 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNaryBooleanOpStorageClass::pickOutIRNodeData ( SgNaryBooleanOp* pointer ) 
   { 
     SgNaryBooleanOp* source = (SgNaryBooleanOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_operators.storeDataInEasyStorageClass(source->p_operators);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNaryBooleanOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < VariantTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNaryBooleanOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < VariantTList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNaryBooleanOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < VariantTList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNaryBooleanOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < VariantTList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 56995 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNaryComparisonOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57008 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNaryComparisonOpStorageClass::pickOutIRNodeData ( SgNaryComparisonOp* pointer ) 
   { 
     SgNaryComparisonOp* source = (SgNaryComparisonOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgExpressionPtrList::value_type *  tempListoperands = new SgExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_operators.storeDataInEasyStorageClass(source->p_operators);
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNaryComparisonOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < VariantTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNaryComparisonOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < VariantTList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNaryComparisonOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < VariantTList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNaryComparisonOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < VariantTList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57096 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgStringConversionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57109 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgStringConversionStorageClass::pickOutIRNodeData ( SgStringConversion* pointer ) 
   { 
     SgStringConversion* source = (SgStringConversion*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgStringConversionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgStringConversionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgStringConversionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgStringConversionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57171 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgYieldExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57184 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgYieldExpressionStorageClass::pickOutIRNodeData ( SgYieldExpression* pointer ) 
   { 
     SgYieldExpression* source = (SgYieldExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgYieldExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgYieldExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgYieldExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgYieldExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57246 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAlignOfOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57259 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAlignOfOpStorageClass::pickOutIRNodeData ( SgAlignOfOp* pointer ) 
   { 
     SgAlignOfOp* source = (SgAlignOfOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_operand_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_type );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_name_qualification_length =  source->p_name_qualification_length ;
     storageOf_type_elaboration_required =  source->p_type_elaboration_required ;
     storageOf_global_qualification_required =  source->p_global_qualification_required ;
     storageOf_alignOfContainsBaseTypeDefiningDeclaration =  source->p_alignOfContainsBaseTypeDefiningDeclaration ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAlignOfOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAlignOfOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAlignOfOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAlignOfOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57327 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRangeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57340 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRangeExpStorageClass::pickOutIRNodeData ( SgRangeExp* pointer ) 
   { 
     SgRangeExp* source = (SgRangeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_start = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_start );
     storageOf_end = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_end );
     storageOf_stride = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_stride );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRangeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRangeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRangeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRangeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57404 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMagicColonExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57417 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMagicColonExpStorageClass::pickOutIRNodeData ( SgMagicColonExp* pointer ) 
   { 
     SgMagicColonExp* source = (SgMagicColonExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMagicColonExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMagicColonExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMagicColonExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMagicColonExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57478 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeTraitBuiltinOperatorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57491 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeTraitBuiltinOperatorStorageClass::pickOutIRNodeData ( SgTypeTraitBuiltinOperator* pointer ) 
   { 
     SgTypeTraitBuiltinOperator* source = (SgTypeTraitBuiltinOperator*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     SgNodePtrList::iterator i_args = source->p_args.begin() ; 
     unsigned int tempListCountargs = 0; 
     SgNodePtrList::value_type *  tempListargs = new SgNodePtrList::value_type[ source->p_args.size() ]; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          tempListargs[tempListCountargs] = *i_args;
          tempListCountargs++; 
          (*i_args) = (SgNodePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_args ) );
        }
     storageOf_args.storeDataInEasyStorageClass(source->p_args);
     tempListCountargs = 0; 
     i_args = source->p_args.begin() ; 
     for ( ; i_args != source->p_args.end(); ++i_args ) 
        {
          *i_args = tempListargs[tempListCountargs] ;
          tempListCountargs++; 
        }
      delete [] tempListargs; 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeTraitBuiltinOperatorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgNodePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeTraitBuiltinOperatorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgNodePtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeTraitBuiltinOperatorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgNodePtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeTraitBuiltinOperatorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgNodePtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57579 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCompoundLiteralExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57592 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCompoundLiteralExpStorageClass::pickOutIRNodeData ( SgCompoundLiteralExp* pointer ) 
   { 
     SgCompoundLiteralExp* source = (SgCompoundLiteralExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCompoundLiteralExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCompoundLiteralExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCompoundLiteralExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCompoundLiteralExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57654 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaAnnotationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57667 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaAnnotationStorageClass::pickOutIRNodeData ( SgJavaAnnotation* pointer ) 
   { 
     SgJavaAnnotation* source = (SgJavaAnnotation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaAnnotationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaAnnotationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaAnnotationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaAnnotationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57729 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaMarkerAnnotationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57742 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaMarkerAnnotationStorageClass::pickOutIRNodeData ( SgJavaMarkerAnnotation* pointer ) 
   { 
     SgJavaMarkerAnnotation* source = (SgJavaMarkerAnnotation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaMarkerAnnotationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaMarkerAnnotationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaMarkerAnnotationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaMarkerAnnotationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57804 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaSingleMemberAnnotationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57817 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaSingleMemberAnnotationStorageClass::pickOutIRNodeData ( SgJavaSingleMemberAnnotation* pointer ) 
   { 
     SgJavaSingleMemberAnnotation* source = (SgJavaSingleMemberAnnotation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaSingleMemberAnnotationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaSingleMemberAnnotationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaSingleMemberAnnotationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaSingleMemberAnnotationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57880 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaNormalAnnotationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57893 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaNormalAnnotationStorageClass::pickOutIRNodeData ( SgJavaNormalAnnotation* pointer ) 
   { 
     SgJavaNormalAnnotation* source = (SgJavaNormalAnnotation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgJavaMemberValuePairPtrList::iterator i_value_pair_list = source->p_value_pair_list.begin() ; 
     unsigned int tempListCountvalue_pair_list = 0; 
     SgJavaMemberValuePairPtrList::value_type *  tempListvalue_pair_list = new SgJavaMemberValuePairPtrList::value_type[ source->p_value_pair_list.size() ]; 
     for ( ; i_value_pair_list != source->p_value_pair_list.end(); ++i_value_pair_list ) 
        {
          tempListvalue_pair_list[tempListCountvalue_pair_list] = *i_value_pair_list;
          tempListCountvalue_pair_list++; 
          (*i_value_pair_list) = (SgJavaMemberValuePairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_value_pair_list ) );
        }
     storageOf_value_pair_list.storeDataInEasyStorageClass(source->p_value_pair_list);
     tempListCountvalue_pair_list = 0; 
     i_value_pair_list = source->p_value_pair_list.begin() ; 
     for ( ; i_value_pair_list != source->p_value_pair_list.end(); ++i_value_pair_list ) 
        {
          *i_value_pair_list = tempListvalue_pair_list[tempListCountvalue_pair_list] ;
          tempListCountvalue_pair_list++; 
        }
      delete [] tempListvalue_pair_list; 
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaNormalAnnotationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgJavaMemberValuePairPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaNormalAnnotationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgJavaMemberValuePairPtrList > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaNormalAnnotationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgJavaMemberValuePairPtrList > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaNormalAnnotationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgJavaMemberValuePairPtrList > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 57977 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaTypeExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 57990 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaTypeExpressionStorageClass::pickOutIRNodeData ( SgJavaTypeExpression* pointer ) 
   { 
     SgJavaTypeExpression* source = (SgJavaTypeExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaTypeExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaTypeExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaTypeExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaTypeExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58052 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58065 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeExpressionStorageClass::pickOutIRNodeData ( SgTypeExpression* pointer ) 
   { 
     SgTypeExpression* source = (SgTypeExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58127 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58140 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClassExpStorageClass::pickOutIRNodeData ( SgClassExp* pointer ) 
   { 
     SgClassExp* source = (SgClassExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_class_symbol );
     storageOf_pobj_class =  source->p_pobj_class ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClassExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58203 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionParameterRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58216 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionParameterRefExpStorageClass::pickOutIRNodeData ( SgFunctionParameterRefExp* pointer ) 
   { 
     SgFunctionParameterRefExp* source = (SgFunctionParameterRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parameter_number =  source->p_parameter_number ;
     storageOf_parameter_levels_up =  source->p_parameter_levels_up ;
     storageOf_parameter_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameter_expression );
     storageOf_parameter_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parameter_type );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionParameterRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionParameterRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionParameterRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionParameterRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58281 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLambdaExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58294 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLambdaExpStorageClass::pickOutIRNodeData ( SgLambdaExp* pointer ) 
   { 
     SgLambdaExp* source = (SgLambdaExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lambda_capture_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lambda_capture_list );
     storageOf_lambda_closure_class = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lambda_closure_class );
     storageOf_lambda_function = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lambda_function );
     storageOf_is_mutable =  source->p_is_mutable ;
     storageOf_capture_default =  source->p_capture_default ;
     storageOf_default_is_by_reference =  source->p_default_is_by_reference ;
     storageOf_explicit_return_type =  source->p_explicit_return_type ;
     storageOf_has_parameter_decl =  source->p_has_parameter_decl ;
     storageOf_is_device =  source->p_is_device ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLambdaExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLambdaExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLambdaExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLambdaExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58364 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgHereExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58377 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgHereExpStorageClass::pickOutIRNodeData ( SgHereExp* pointer ) 
   { 
     SgHereExp* source = (SgHereExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression_type );
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgHereExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgHereExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgHereExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgHereExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58440 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAtExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58453 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAtExpStorageClass::pickOutIRNodeData ( SgAtExp* pointer ) 
   { 
     SgAtExp* source = (SgAtExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAtExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAtExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAtExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAtExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58516 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFinishExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58529 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFinishExpStorageClass::pickOutIRNodeData ( SgFinishExp* pointer ) 
   { 
     SgFinishExp* source = (SgFinishExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_expression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_expression );
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFinishExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFinishExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFinishExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFinishExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58592 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNoexceptOpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58605 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNoexceptOpStorageClass::pickOutIRNodeData ( SgNoexceptOp* pointer ) 
   { 
     SgNoexceptOp* source = (SgNoexceptOp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand_expr = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand_expr );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNoexceptOpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNoexceptOpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNoexceptOpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNoexceptOpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58667 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58680 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskRefExpStorageClass::pickOutIRNodeData ( SgAdaTaskRefExp* pointer ) 
   { 
     SgAdaTaskRefExp* source = (SgAdaTaskRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58742 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58755 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedRefExpStorageClass::pickOutIRNodeData ( SgAdaProtectedRefExp* pointer ) 
   { 
     SgAdaProtectedRefExp* source = (SgAdaProtectedRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58817 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFoldExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58830 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFoldExpressionStorageClass::pickOutIRNodeData ( SgFoldExpression* pointer ) 
   { 
     SgFoldExpression* source = (SgFoldExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operands = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operands );
     storageOf_operator_token.storeDataInEasyStorageClass(source->p_operator_token);
     storageOf_is_left_associative =  source->p_is_left_associative ;
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFoldExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFoldExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFoldExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFoldExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58898 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAwaitExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58911 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAwaitExpressionStorageClass::pickOutIRNodeData ( SgAwaitExpression* pointer ) 
   { 
     SgAwaitExpression* source = (SgAwaitExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAwaitExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAwaitExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAwaitExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAwaitExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 58973 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgChooseExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 58986 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgChooseExpressionStorageClass::pickOutIRNodeData ( SgChooseExpression* pointer ) 
   { 
     SgChooseExpression* source = (SgChooseExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgChooseExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgChooseExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgChooseExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgChooseExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59048 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaAttributeExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59061 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaAttributeExpStorageClass::pickOutIRNodeData ( SgAdaAttributeExp* pointer ) 
   { 
     SgAdaAttributeExp* source = (SgAdaAttributeExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attribute.pickOutIRNodeData( &(source->p_attribute) );
     storageOf_object = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_object );
     storageOf_args = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_args );
     storageOf_attrType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_attrType );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaAttributeExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaAttributeExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaAttributeExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaAttributeExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59130 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialTablePresetExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59143 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialTablePresetExpStorageClass::pickOutIRNodeData ( SgJovialTablePresetExp* pointer ) 
   { 
     SgJovialTablePresetExp* source = (SgJovialTablePresetExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_preset_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_preset_list );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialTablePresetExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialTablePresetExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialTablePresetExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialTablePresetExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59205 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJovialPresetPositionExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59218 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJovialPresetPositionExpStorageClass::pickOutIRNodeData ( SgJovialPresetPositionExp* pointer ) 
   { 
     SgJovialPresetPositionExp* source = (SgJovialPresetPositionExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_indices = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_indices );
     storageOf_value = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_value );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJovialPresetPositionExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJovialPresetPositionExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJovialPresetPositionExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJovialPresetPositionExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59281 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaOthersExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59294 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaOthersExpStorageClass::pickOutIRNodeData ( SgAdaOthersExp* pointer ) 
   { 
     SgAdaOthersExp* source = (SgAdaOthersExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaOthersExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaOthersExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaOthersExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaOthersExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59355 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaRenamingRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59368 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaRenamingRefExpStorageClass::pickOutIRNodeData ( SgAdaRenamingRefExp* pointer ) 
   { 
     SgAdaRenamingRefExp* source = (SgAdaRenamingRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaRenamingRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaRenamingRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaRenamingRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaRenamingRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59430 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaUnitRefExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59443 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaUnitRefExpStorageClass::pickOutIRNodeData ( SgAdaUnitRefExp* pointer ) 
   { 
     SgAdaUnitRefExp* source = (SgAdaUnitRefExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_need_paren =  source->p_need_paren ;
     storageOf_lvalue =  source->p_lvalue ;
     storageOf_global_qualified_name =  source->p_global_qualified_name ;
     storageOf_operatorPosition = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operatorPosition );
     storageOf_startOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_startOfConstruct );
     storageOf_endOfConstruct = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_endOfConstruct );
     storageOf_attachedPreprocessingInfoPtr.storeDataInEasyStorageClass(source->p_attachedPreprocessingInfoPtr);
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_containsTransformationToSurroundingWhitespace =  source->p_containsTransformationToSurroundingWhitespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaUnitRefExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaUnitRefExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AttachedPreprocessingInfoType* > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaUnitRefExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AttachedPreprocessingInfoType* > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaUnitRefExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AttachedPreprocessingInfoType* > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59505 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59518 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgSymbolStorageClass::pickOutIRNodeData ( SgSymbol* pointer ) 
   { 
     SgSymbol* source = (SgSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59567 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgVariableSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59580 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgVariableSymbolStorageClass::pickOutIRNodeData ( SgVariableSymbol* pointer ) 
   { 
     SgVariableSymbol* source = (SgVariableSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgVariableSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgVariableSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgVariableSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgVariableSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59630 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateVariableSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59643 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateVariableSymbolStorageClass::pickOutIRNodeData ( SgTemplateVariableSymbol* pointer ) 
   { 
     SgTemplateVariableSymbol* source = (SgTemplateVariableSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateVariableSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateVariableSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateVariableSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateVariableSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59693 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNonrealSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59706 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNonrealSymbolStorageClass::pickOutIRNodeData ( SgNonrealSymbol* pointer ) 
   { 
     SgNonrealSymbol* source = (SgNonrealSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNonrealSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNonrealSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNonrealSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNonrealSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59756 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59769 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionSymbolStorageClass::pickOutIRNodeData ( SgFunctionSymbol* pointer ) 
   { 
     SgFunctionSymbol* source = (SgFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59819 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgMemberFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59832 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgMemberFunctionSymbolStorageClass::pickOutIRNodeData ( SgMemberFunctionSymbol* pointer ) 
   { 
     SgMemberFunctionSymbol* source = (SgMemberFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgMemberFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgMemberFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgMemberFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgMemberFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59882 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateMemberFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59895 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateMemberFunctionSymbolStorageClass::pickOutIRNodeData ( SgTemplateMemberFunctionSymbol* pointer ) 
   { 
     SgTemplateMemberFunctionSymbol* source = (SgTemplateMemberFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateMemberFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateMemberFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateMemberFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateMemberFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 59945 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 59958 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateFunctionSymbolStorageClass::pickOutIRNodeData ( SgTemplateFunctionSymbol* pointer ) 
   { 
     SgTemplateFunctionSymbol* source = (SgTemplateFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60008 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgRenameSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60021 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgRenameSymbolStorageClass::pickOutIRNodeData ( SgRenameSymbol* pointer ) 
   { 
     SgRenameSymbol* source = (SgRenameSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_original_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_original_symbol );
     storageOf_new_name.pickOutIRNodeData( &(source->p_new_name) );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgRenameSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgRenameSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgRenameSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgRenameSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60077 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaInheritedFunctionSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60090 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaInheritedFunctionSymbolStorageClass::pickOutIRNodeData ( SgAdaInheritedFunctionSymbol* pointer ) 
   { 
     SgAdaInheritedFunctionSymbol* source = (SgAdaInheritedFunctionSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_derivedFunctionType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_derivedFunctionType );
     storageOf_associatedDerivedType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_associatedDerivedType );
     storageOf_publiclyVisibleFunctionSymbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_publiclyVisibleFunctionSymbol );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaInheritedFunctionSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaInheritedFunctionSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaInheritedFunctionSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaInheritedFunctionSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60143 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgFunctionTypeSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60156 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgFunctionTypeSymbolStorageClass::pickOutIRNodeData ( SgFunctionTypeSymbol* pointer ) 
   { 
     SgFunctionTypeSymbol* source = (SgFunctionTypeSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgFunctionTypeSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgFunctionTypeSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgFunctionTypeSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgFunctionTypeSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60211 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60224 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateSymbolStorageClass::pickOutIRNodeData ( SgTemplateSymbol* pointer ) 
   { 
     SgTemplateSymbol* source = (SgTemplateSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60274 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumFieldSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60287 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEnumFieldSymbolStorageClass::pickOutIRNodeData ( SgEnumFieldSymbol* pointer ) 
   { 
     SgEnumFieldSymbol* source = (SgEnumFieldSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEnumFieldSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumFieldSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumFieldSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumFieldSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60337 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypeSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60350 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypeSymbolStorageClass::pickOutIRNodeData ( SgTypeSymbol* pointer ) 
   { 
     SgTypeSymbol* source = (SgTypeSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypeSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypeSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypeSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypeSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60399 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgClassSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60412 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgClassSymbolStorageClass::pickOutIRNodeData ( SgClassSymbol* pointer ) 
   { 
     SgClassSymbol* source = (SgClassSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgClassSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgClassSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgClassSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgClassSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60462 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateClassSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60475 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateClassSymbolStorageClass::pickOutIRNodeData ( SgTemplateClassSymbol* pointer ) 
   { 
     SgTemplateClassSymbol* source = (SgTemplateClassSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateClassSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateClassSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateClassSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateClassSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60525 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTypedefSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60538 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTypedefSymbolStorageClass::pickOutIRNodeData ( SgTypedefSymbol* pointer ) 
   { 
     SgTypedefSymbol* source = (SgTypedefSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTypedefSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTypedefSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTypedefSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTypedefSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60588 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgTemplateTypedefSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60601 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgTemplateTypedefSymbolStorageClass::pickOutIRNodeData ( SgTemplateTypedefSymbol* pointer ) 
   { 
     SgTemplateTypedefSymbol* source = (SgTemplateTypedefSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgTemplateTypedefSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgTemplateTypedefSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgTemplateTypedefSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgTemplateTypedefSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60651 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgEnumSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60664 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgEnumSymbolStorageClass::pickOutIRNodeData ( SgEnumSymbol* pointer ) 
   { 
     SgEnumSymbol* source = (SgEnumSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgEnumSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgEnumSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgEnumSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgEnumSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60714 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgLabelSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60727 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgLabelSymbolStorageClass::pickOutIRNodeData ( SgLabelSymbol* pointer ) 
   { 
     SgLabelSymbol* source = (SgLabelSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_fortran_statement = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fortran_statement );
     storageOf_fortran_alternate_return_parameter = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fortran_alternate_return_parameter );
     storageOf_numeric_label_value =  source->p_numeric_label_value ;
     storageOf_label_type =  source->p_label_type ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgLabelSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgLabelSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgLabelSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgLabelSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60781 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgDefaultSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60794 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgDefaultSymbolStorageClass::pickOutIRNodeData ( SgDefaultSymbol* pointer ) 
   { 
     SgDefaultSymbol* source = (SgDefaultSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgDefaultSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgDefaultSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgDefaultSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgDefaultSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60844 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgNamespaceSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60857 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgNamespaceSymbolStorageClass::pickOutIRNodeData ( SgNamespaceSymbol* pointer ) 
   { 
     SgNamespaceSymbol* source = (SgNamespaceSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.pickOutIRNodeData( &(source->p_name) );
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_aliasDeclaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_aliasDeclaration );
     storageOf_isAlias =  source->p_isAlias ;
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgNamespaceSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgNamespaceSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgNamespaceSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgNamespaceSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60914 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgIntrinsicSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60927 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgIntrinsicSymbolStorageClass::pickOutIRNodeData ( SgIntrinsicSymbol* pointer ) 
   { 
     SgIntrinsicSymbol* source = (SgIntrinsicSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgIntrinsicSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgIntrinsicSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgIntrinsicSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgIntrinsicSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 60977 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgModuleSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 60990 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgModuleSymbolStorageClass::pickOutIRNodeData ( SgModuleSymbol* pointer ) 
   { 
     SgModuleSymbol* source = (SgModuleSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgModuleSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgModuleSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgModuleSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgModuleSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61040 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgInterfaceSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61053 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgInterfaceSymbolStorageClass::pickOutIRNodeData ( SgInterfaceSymbol* pointer ) 
   { 
     SgInterfaceSymbol* source = (SgInterfaceSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgInterfaceSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgInterfaceSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgInterfaceSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgInterfaceSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61103 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgCommonSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61116 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgCommonSymbolStorageClass::pickOutIRNodeData ( SgCommonSymbol* pointer ) 
   { 
     SgCommonSymbol* source = (SgCommonSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgCommonSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgCommonSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgCommonSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgCommonSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61166 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAliasSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61179 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAliasSymbolStorageClass::pickOutIRNodeData ( SgAliasSymbol* pointer ) 
   { 
     SgAliasSymbol* source = (SgAliasSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_alias = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_alias );
     storageOf_isRenamed =  source->p_isRenamed ;
     storageOf_new_name.pickOutIRNodeData( &(source->p_new_name) );
     SgNodePtrList::iterator i_causal_nodes = source->p_causal_nodes.begin() ; 
     unsigned int tempListCountcausal_nodes = 0; 
     SgNodePtrList::value_type *  tempListcausal_nodes = new SgNodePtrList::value_type[ source->p_causal_nodes.size() ]; 
     for ( ; i_causal_nodes != source->p_causal_nodes.end(); ++i_causal_nodes ) 
        {
          tempListcausal_nodes[tempListCountcausal_nodes] = *i_causal_nodes;
          tempListCountcausal_nodes++; 
          (*i_causal_nodes) = (SgNodePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_causal_nodes ) );
        }
     storageOf_causal_nodes.storeDataInEasyStorageClass(source->p_causal_nodes);
     tempListCountcausal_nodes = 0; 
     i_causal_nodes = source->p_causal_nodes.begin() ; 
     for ( ; i_causal_nodes != source->p_causal_nodes.end(); ++i_causal_nodes ) 
        {
          *i_causal_nodes = tempListcausal_nodes[tempListCountcausal_nodes] ;
          tempListCountcausal_nodes++; 
        }
      delete [] tempListcausal_nodes; 
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAliasSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < SgNodePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAliasSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < SgNodePtrList > :: deleteMemoryPool() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAliasSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < SgNodePtrList > :: writeToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAliasSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < SgNodePtrList > :: readFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61257 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddressSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61270 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddressSymbolStorageClass::pickOutIRNodeData ( SgAsmBinaryAddressSymbol* pointer ) 
   { 
     SgAsmBinaryAddressSymbol* source = (SgAsmBinaryAddressSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_address_name.pickOutIRNodeData( &(source->p_address_name) );
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddressSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddressSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61325 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryDataSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61338 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryDataSymbolStorageClass::pickOutIRNodeData ( SgAsmBinaryDataSymbol* pointer ) 
   { 
     SgAsmBinaryDataSymbol* source = (SgAsmBinaryDataSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_variable_name.pickOutIRNodeData( &(source->p_variable_name) );
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryDataSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     SgNameStorageClass :: arrangeStaticDataOfEasyStorageClassesInOneBlock() ;
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryDataSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     SgNameStorageClass :: deleteStaticDataOfEasyStorageClasses() ;
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryDataSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     SgNameStorageClass :: writeEasyStorageDataToFile(out) ;
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAsmBinaryDataSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     SgNameStorageClass :: readEasyStorageDataFromFile(in) ;
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61393 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgJavaLabelSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61406 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgJavaLabelSymbolStorageClass::pickOutIRNodeData ( SgJavaLabelSymbol* pointer ) 
   { 
     SgJavaLabelSymbol* source = (SgJavaLabelSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgJavaLabelSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgJavaLabelSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgJavaLabelSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgJavaLabelSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61456 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaPackageSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61469 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaPackageSymbolStorageClass::pickOutIRNodeData ( SgAdaPackageSymbol* pointer ) 
   { 
     SgAdaPackageSymbol* source = (SgAdaPackageSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaPackageSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaPackageSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaPackageSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaPackageSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61519 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaTaskSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61532 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaTaskSymbolStorageClass::pickOutIRNodeData ( SgAdaTaskSymbol* pointer ) 
   { 
     SgAdaTaskSymbol* source = (SgAdaTaskSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaTaskSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaTaskSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaTaskSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaTaskSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61582 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaProtectedSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61595 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaProtectedSymbolStorageClass::pickOutIRNodeData ( SgAdaProtectedSymbol* pointer ) 
   { 
     SgAdaProtectedSymbol* source = (SgAdaProtectedSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaProtectedSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaProtectedSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaProtectedSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaProtectedSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61645 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaRenamingSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61658 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaRenamingSymbolStorageClass::pickOutIRNodeData ( SgAdaRenamingSymbol* pointer ) 
   { 
     SgAdaRenamingSymbol* source = (SgAdaRenamingSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaRenamingSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaRenamingSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaRenamingSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaRenamingSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61708 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaGenericSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61721 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaGenericSymbolStorageClass::pickOutIRNodeData ( SgAdaGenericSymbol* pointer ) 
   { 
     SgAdaGenericSymbol* source = (SgAdaGenericSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaGenericSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaGenericSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaGenericSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaGenericSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61771 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaGenericInstanceSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61784 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaGenericInstanceSymbolStorageClass::pickOutIRNodeData ( SgAdaGenericInstanceSymbol* pointer ) 
   { 
     SgAdaGenericInstanceSymbol* source = (SgAdaGenericInstanceSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaGenericInstanceSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaGenericInstanceSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaGenericInstanceSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaGenericInstanceSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61834 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAdaFormalPackageSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61847 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAdaFormalPackageSymbolStorageClass::pickOutIRNodeData ( SgAdaFormalPackageSymbol* pointer ) 
   { 
     SgAdaFormalPackageSymbol* source = (SgAdaFormalPackageSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_declaration = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_declaration );
     storageOf_attributeMechanism.storeDataInEasyStorageClass(source->p_attributeMechanism);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAdaFormalPackageSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < AstAttributeMechanism* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAdaFormalPackageSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < AstAttributeMechanism* > :: deleteMemoryPool() ;
   }

void
SgAdaFormalPackageSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < AstAttributeMechanism* > :: writeToFile(out) ;
   }


void
SgAdaFormalPackageSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < AstAttributeMechanism* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61897 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61910 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNodeStorageClass::pickOutIRNodeData ( SgAsmNode* pointer ) 
   { 
     SgAsmNode* source = (SgAsmNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61932 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61945 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilNodeStorageClass::pickOutIRNodeData ( SgAsmCilNode* pointer ) 
   { 
     SgAsmCilNode* source = (SgAsmCilNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 61967 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilDataStreamStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 61980 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilDataStreamStorageClass::pickOutIRNodeData ( SgAsmCilDataStream* pointer ) 
   { 
     SgAsmCilDataStream* source = (SgAsmCilDataStream*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Offset =  source->p_Offset ;
     storageOf_Size =  source->p_Size ;
     storageOf_Name.storeDataInEasyStorageClass(source->p_Name);
     storageOf_NamePadding =  source->p_NamePadding ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilDataStreamStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilDataStreamStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCilDataStreamStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCilDataStreamStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62032 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilErrorHeapStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62045 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilErrorHeapStorageClass::pickOutIRNodeData ( SgAsmCilErrorHeap* pointer ) 
   { 
     SgAsmCilErrorHeap* source = (SgAsmCilErrorHeap*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Offset =  source->p_Offset ;
     storageOf_Size =  source->p_Size ;
     storageOf_Name.storeDataInEasyStorageClass(source->p_Name);
     storageOf_NamePadding =  source->p_NamePadding ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilErrorHeapStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilErrorHeapStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCilErrorHeapStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCilErrorHeapStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62097 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMetadataHeapStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62110 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMetadataHeapStorageClass::pickOutIRNodeData ( SgAsmCilMetadataHeap* pointer ) 
   { 
     SgAsmCilMetadataHeap* source = (SgAsmCilMetadataHeap*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_ReservedAlwaysZero =  source->p_ReservedAlwaysZero ;
     storageOf_MajorVersion =  source->p_MajorVersion ;
     storageOf_MinorVersion =  source->p_MinorVersion ;
     storageOf_HeapSizes =  source->p_HeapSizes ;
     storageOf_ReservedAlwaysOne =  source->p_ReservedAlwaysOne ;
     storageOf_Valid =  source->p_Valid ;
     storageOf_Sorted =  source->p_Sorted ;
     storageOf_NumberOfRows.storeDataInEasyStorageClass(source->p_NumberOfRows);
     storageOf_DataSizeFlags =  source->p_DataSizeFlags ;
     storageOf_AssemblyTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_AssemblyTable );
     storageOf_AssemblyOSTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_AssemblyOSTable );
     storageOf_AssemblyProcessorTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_AssemblyProcessorTable );
     storageOf_AssemblyRefTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_AssemblyRefTable );
     storageOf_AssemblyRefOSTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_AssemblyRefOSTable );
     storageOf_AssemblyRefProcessorTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_AssemblyRefProcessorTable );
     storageOf_ClassLayoutTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ClassLayoutTable );
     storageOf_ConstantTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ConstantTable );
     storageOf_CustomAttributeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_CustomAttributeTable );
     storageOf_DeclSecurityTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_DeclSecurityTable );
     storageOf_EventTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_EventTable );
     storageOf_EventMapTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_EventMapTable );
     storageOf_ExportedTypeTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ExportedTypeTable );
     storageOf_FieldTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_FieldTable );
     storageOf_FieldLayoutTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_FieldLayoutTable );
     storageOf_FieldMarshalTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_FieldMarshalTable );
     storageOf_FieldRVATable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_FieldRVATable );
     storageOf_FileTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_FileTable );
     storageOf_GenericParamTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_GenericParamTable );
     storageOf_GenericParamConstraintTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_GenericParamConstraintTable );
     storageOf_ImplMapTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ImplMapTable );
     storageOf_InterfaceImplTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_InterfaceImplTable );
     storageOf_ManifestResourceTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ManifestResourceTable );
     storageOf_MemberRefTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_MemberRefTable );
     storageOf_MethodDefTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_MethodDefTable );
     storageOf_MethodImplTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_MethodImplTable );
     storageOf_MethodSemanticsTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_MethodSemanticsTable );
     storageOf_MethodSpecTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_MethodSpecTable );
     storageOf_ModuleTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ModuleTable );
     storageOf_ModuleRefTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ModuleRefTable );
     storageOf_NestedClassTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_NestedClassTable );
     storageOf_ParamTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ParamTable );
     storageOf_PropertyTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_PropertyTable );
     storageOf_PropertyMapTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_PropertyMapTable );
     storageOf_StandAloneSigTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_StandAloneSigTable );
     storageOf_TypeDefTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_TypeDefTable );
     storageOf_TypeRefTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_TypeRefTable );
     storageOf_TypeSpecTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_TypeSpecTable );
     storageOf_Offset =  source->p_Offset ;
     storageOf_Size =  source->p_Size ;
     storageOf_Name.storeDataInEasyStorageClass(source->p_Name);
     storageOf_NamePadding =  source->p_NamePadding ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMetadataHeapStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<uint32_t> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMetadataHeapStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<uint32_t> > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCilMetadataHeapStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<uint32_t> > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCilMetadataHeapStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<uint32_t> > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62213 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilUint32HeapStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62226 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilUint32HeapStorageClass::pickOutIRNodeData ( SgAsmCilUint32Heap* pointer ) 
   { 
     SgAsmCilUint32Heap* source = (SgAsmCilUint32Heap*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Stream.storeDataInEasyStorageClass(source->p_Stream);
     storageOf_Offset =  source->p_Offset ;
     storageOf_Size =  source->p_Size ;
     storageOf_Name.storeDataInEasyStorageClass(source->p_Name);
     storageOf_NamePadding =  source->p_NamePadding ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilUint32HeapStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<uint32_t> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilUint32HeapStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<uint32_t> > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCilUint32HeapStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<uint32_t> > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCilUint32HeapStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<uint32_t> > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62283 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilUint8HeapStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62296 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilUint8HeapStorageClass::pickOutIRNodeData ( SgAsmCilUint8Heap* pointer ) 
   { 
     SgAsmCilUint8Heap* source = (SgAsmCilUint8Heap*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Stream.storeDataInEasyStorageClass(source->p_Stream);
     storageOf_Offset =  source->p_Offset ;
     storageOf_Size =  source->p_Size ;
     storageOf_Name.storeDataInEasyStorageClass(source->p_Name);
     storageOf_NamePadding =  source->p_NamePadding ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilUint8HeapStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<uint8_t> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilUint8HeapStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<uint8_t> > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCilUint8HeapStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<uint8_t> > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCilUint8HeapStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<uint8_t> > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62353 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilExceptionDataStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62366 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilExceptionDataStorageClass::pickOutIRNodeData ( SgAsmCilExceptionData* pointer ) 
   { 
     SgAsmCilExceptionData* source = (SgAsmCilExceptionData*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_tryOffset =  source->p_tryOffset ;
     storageOf_tryLength =  source->p_tryLength ;
     storageOf_handlerOffset =  source->p_handlerOffset ;
     storageOf_handlerLength =  source->p_handlerLength ;
     storageOf_classTokenOrFilterOffset =  source->p_classTokenOrFilterOffset ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62394 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMetadataStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62407 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMetadataStorageClass::pickOutIRNodeData ( SgAsmCilMetadata* pointer ) 
   { 
     SgAsmCilMetadata* source = (SgAsmCilMetadata*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62429 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62442 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyStorageClass::pickOutIRNodeData ( SgAsmCilAssembly* pointer ) 
   { 
     SgAsmCilAssembly* source = (SgAsmCilAssembly*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_HashAlgId =  source->p_HashAlgId ;
     storageOf_MajorVersion =  source->p_MajorVersion ;
     storageOf_MinorVersion =  source->p_MinorVersion ;
     storageOf_BuildNumber =  source->p_BuildNumber ;
     storageOf_RevisionNumber =  source->p_RevisionNumber ;
     storageOf_Flags =  source->p_Flags ;
     storageOf_PublicKey =  source->p_PublicKey ;
     storageOf_Name =  source->p_Name ;
     storageOf_Culture =  source->p_Culture ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62473 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyOSStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62486 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyOSStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyOS* pointer ) 
   { 
     SgAsmCilAssemblyOS* source = (SgAsmCilAssemblyOS*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_OSPlatformID =  source->p_OSPlatformID ;
     storageOf_OSMajorVersion =  source->p_OSMajorVersion ;
     storageOf_OSMinorVersion =  source->p_OSMinorVersion ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62511 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyOSTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62524 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyOSTableStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyOSTable* pointer ) 
   { 
     SgAsmCilAssemblyOSTable* source = (SgAsmCilAssemblyOSTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilAssemblyOSTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyOS*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilAssemblyOSTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyOS*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilAssemblyOSTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilAssemblyOS*> > :: writeToFile(out) ;
   }


void
SgAsmCilAssemblyOSTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilAssemblyOS*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62573 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyProcessorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62586 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyProcessorStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyProcessor* pointer ) 
   { 
     SgAsmCilAssemblyProcessor* source = (SgAsmCilAssemblyProcessor*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Processor =  source->p_Processor ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62609 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyProcessorTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62622 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyProcessorTableStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyProcessorTable* pointer ) 
   { 
     SgAsmCilAssemblyProcessorTable* source = (SgAsmCilAssemblyProcessorTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilAssemblyProcessorTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyProcessor*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilAssemblyProcessorTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyProcessor*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilAssemblyProcessorTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilAssemblyProcessor*> > :: writeToFile(out) ;
   }


void
SgAsmCilAssemblyProcessorTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilAssemblyProcessor*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62671 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyRefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62684 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyRefStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyRef* pointer ) 
   { 
     SgAsmCilAssemblyRef* source = (SgAsmCilAssemblyRef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_MajorVersion =  source->p_MajorVersion ;
     storageOf_MinorVersion =  source->p_MinorVersion ;
     storageOf_BuildNumber =  source->p_BuildNumber ;
     storageOf_RevisionNumber =  source->p_RevisionNumber ;
     storageOf_Flags =  source->p_Flags ;
     storageOf_PublicKeyOrToken =  source->p_PublicKeyOrToken ;
     storageOf_Name =  source->p_Name ;
     storageOf_Culture =  source->p_Culture ;
     storageOf_HashValue =  source->p_HashValue ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62715 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyRefOSStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62728 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyRefOSStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyRefOS* pointer ) 
   { 
     SgAsmCilAssemblyRefOS* source = (SgAsmCilAssemblyRefOS*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_OSPlatformID =  source->p_OSPlatformID ;
     storageOf_OSMajorVersion =  source->p_OSMajorVersion ;
     storageOf_OSMinorVersion =  source->p_OSMinorVersion ;
     storageOf_AssemblyRefOS =  source->p_AssemblyRefOS ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62754 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyRefOSTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62767 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyRefOSTableStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyRefOSTable* pointer ) 
   { 
     SgAsmCilAssemblyRefOSTable* source = (SgAsmCilAssemblyRefOSTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilAssemblyRefOSTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyRefOS*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilAssemblyRefOSTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyRefOS*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilAssemblyRefOSTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilAssemblyRefOS*> > :: writeToFile(out) ;
   }


void
SgAsmCilAssemblyRefOSTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilAssemblyRefOS*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62816 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyRefProcessorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62829 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyRefProcessorStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyRefProcessor* pointer ) 
   { 
     SgAsmCilAssemblyRefProcessor* source = (SgAsmCilAssemblyRefProcessor*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Processor =  source->p_Processor ;
     storageOf_AssemblyRef =  source->p_AssemblyRef ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62853 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyRefProcessorTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62866 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyRefProcessorTableStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyRefProcessorTable* pointer ) 
   { 
     SgAsmCilAssemblyRefProcessorTable* source = (SgAsmCilAssemblyRefProcessorTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilAssemblyRefProcessorTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyRefProcessor*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilAssemblyRefProcessorTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyRefProcessor*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilAssemblyRefProcessorTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilAssemblyRefProcessor*> > :: writeToFile(out) ;
   }


void
SgAsmCilAssemblyRefProcessorTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilAssemblyRefProcessor*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62915 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyRefTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62928 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyRefTableStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyRefTable* pointer ) 
   { 
     SgAsmCilAssemblyRefTable* source = (SgAsmCilAssemblyRefTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilAssemblyRefTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyRef*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilAssemblyRefTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilAssemblyRef*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilAssemblyRefTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilAssemblyRef*> > :: writeToFile(out) ;
   }


void
SgAsmCilAssemblyRefTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilAssemblyRef*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 62977 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilAssemblyTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 62990 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilAssemblyTableStorageClass::pickOutIRNodeData ( SgAsmCilAssemblyTable* pointer ) 
   { 
     SgAsmCilAssemblyTable* source = (SgAsmCilAssemblyTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilAssemblyTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilAssembly*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilAssemblyTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilAssembly*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilAssemblyTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilAssembly*> > :: writeToFile(out) ;
   }


void
SgAsmCilAssemblyTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilAssembly*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63039 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilClassLayoutStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63052 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilClassLayoutStorageClass::pickOutIRNodeData ( SgAsmCilClassLayout* pointer ) 
   { 
     SgAsmCilClassLayout* source = (SgAsmCilClassLayout*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_PackingSize =  source->p_PackingSize ;
     storageOf_ClassSize =  source->p_ClassSize ;
     storageOf_Parent =  source->p_Parent ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63077 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilClassLayoutTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63090 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilClassLayoutTableStorageClass::pickOutIRNodeData ( SgAsmCilClassLayoutTable* pointer ) 
   { 
     SgAsmCilClassLayoutTable* source = (SgAsmCilClassLayoutTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilClassLayoutTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilClassLayout*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilClassLayoutTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilClassLayout*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilClassLayoutTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilClassLayout*> > :: writeToFile(out) ;
   }


void
SgAsmCilClassLayoutTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilClassLayout*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63139 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilConstantStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63152 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilConstantStorageClass::pickOutIRNodeData ( SgAsmCilConstant* pointer ) 
   { 
     SgAsmCilConstant* source = (SgAsmCilConstant*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Type =  source->p_Type ;
     storageOf_Padding =  source->p_Padding ;
     storageOf_Parent =  source->p_Parent ;
     storageOf_Value =  source->p_Value ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63178 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilConstantTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63191 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilConstantTableStorageClass::pickOutIRNodeData ( SgAsmCilConstantTable* pointer ) 
   { 
     SgAsmCilConstantTable* source = (SgAsmCilConstantTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilConstantTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilConstant*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilConstantTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilConstant*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilConstantTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilConstant*> > :: writeToFile(out) ;
   }


void
SgAsmCilConstantTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilConstant*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63240 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilCustomAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63253 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilCustomAttributeStorageClass::pickOutIRNodeData ( SgAsmCilCustomAttribute* pointer ) 
   { 
     SgAsmCilCustomAttribute* source = (SgAsmCilCustomAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Parent =  source->p_Parent ;
     storageOf_Type =  source->p_Type ;
     storageOf_Value =  source->p_Value ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63278 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilCustomAttributeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63291 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilCustomAttributeTableStorageClass::pickOutIRNodeData ( SgAsmCilCustomAttributeTable* pointer ) 
   { 
     SgAsmCilCustomAttributeTable* source = (SgAsmCilCustomAttributeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilCustomAttributeTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilCustomAttribute*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilCustomAttributeTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilCustomAttribute*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilCustomAttributeTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilCustomAttribute*> > :: writeToFile(out) ;
   }


void
SgAsmCilCustomAttributeTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilCustomAttribute*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63340 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilDeclSecurityStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63353 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilDeclSecurityStorageClass::pickOutIRNodeData ( SgAsmCilDeclSecurity* pointer ) 
   { 
     SgAsmCilDeclSecurity* source = (SgAsmCilDeclSecurity*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Action =  source->p_Action ;
     storageOf_Parent =  source->p_Parent ;
     storageOf_PermissionSet =  source->p_PermissionSet ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63378 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilDeclSecurityTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63391 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilDeclSecurityTableStorageClass::pickOutIRNodeData ( SgAsmCilDeclSecurityTable* pointer ) 
   { 
     SgAsmCilDeclSecurityTable* source = (SgAsmCilDeclSecurityTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilDeclSecurityTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilDeclSecurity*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilDeclSecurityTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilDeclSecurity*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilDeclSecurityTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilDeclSecurity*> > :: writeToFile(out) ;
   }


void
SgAsmCilDeclSecurityTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilDeclSecurity*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63440 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilEventStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63453 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilEventStorageClass::pickOutIRNodeData ( SgAsmCilEvent* pointer ) 
   { 
     SgAsmCilEvent* source = (SgAsmCilEvent*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_EventFlags =  source->p_EventFlags ;
     storageOf_Name =  source->p_Name ;
     storageOf_EventType =  source->p_EventType ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63478 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilEventMapStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63491 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilEventMapStorageClass::pickOutIRNodeData ( SgAsmCilEventMap* pointer ) 
   { 
     SgAsmCilEventMap* source = (SgAsmCilEventMap*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Parent =  source->p_Parent ;
     storageOf_EventList =  source->p_EventList ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63515 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilEventMapTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63528 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilEventMapTableStorageClass::pickOutIRNodeData ( SgAsmCilEventMapTable* pointer ) 
   { 
     SgAsmCilEventMapTable* source = (SgAsmCilEventMapTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilEventMapTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilEventMap*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilEventMapTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilEventMap*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilEventMapTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilEventMap*> > :: writeToFile(out) ;
   }


void
SgAsmCilEventMapTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilEventMap*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63577 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilEventTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63590 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilEventTableStorageClass::pickOutIRNodeData ( SgAsmCilEventTable* pointer ) 
   { 
     SgAsmCilEventTable* source = (SgAsmCilEventTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilEventTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilEvent*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilEventTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilEvent*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilEventTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilEvent*> > :: writeToFile(out) ;
   }


void
SgAsmCilEventTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilEvent*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63639 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilExportedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63652 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilExportedTypeStorageClass::pickOutIRNodeData ( SgAsmCilExportedType* pointer ) 
   { 
     SgAsmCilExportedType* source = (SgAsmCilExportedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_EventFlags =  source->p_EventFlags ;
     storageOf_TypeDefIdName =  source->p_TypeDefIdName ;
     storageOf_TypeName =  source->p_TypeName ;
     storageOf_TypeNamespace =  source->p_TypeNamespace ;
     storageOf_Implementation =  source->p_Implementation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63679 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilExportedTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63692 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilExportedTypeTableStorageClass::pickOutIRNodeData ( SgAsmCilExportedTypeTable* pointer ) 
   { 
     SgAsmCilExportedTypeTable* source = (SgAsmCilExportedTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilExportedTypeTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilExportedType*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilExportedTypeTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilExportedType*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilExportedTypeTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilExportedType*> > :: writeToFile(out) ;
   }


void
SgAsmCilExportedTypeTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilExportedType*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63741 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63754 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldStorageClass::pickOutIRNodeData ( SgAsmCilField* pointer ) 
   { 
     SgAsmCilField* source = (SgAsmCilField*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Flags =  source->p_Flags ;
     storageOf_Name =  source->p_Name ;
     storageOf_Signature =  source->p_Signature ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63779 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldLayoutStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63792 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldLayoutStorageClass::pickOutIRNodeData ( SgAsmCilFieldLayout* pointer ) 
   { 
     SgAsmCilFieldLayout* source = (SgAsmCilFieldLayout*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Offset =  source->p_Offset ;
     storageOf_Field =  source->p_Field ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63816 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldLayoutTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63829 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldLayoutTableStorageClass::pickOutIRNodeData ( SgAsmCilFieldLayoutTable* pointer ) 
   { 
     SgAsmCilFieldLayoutTable* source = (SgAsmCilFieldLayoutTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilFieldLayoutTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilFieldLayout*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilFieldLayoutTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilFieldLayout*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilFieldLayoutTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilFieldLayout*> > :: writeToFile(out) ;
   }


void
SgAsmCilFieldLayoutTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilFieldLayout*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63878 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldMarshalStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63891 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldMarshalStorageClass::pickOutIRNodeData ( SgAsmCilFieldMarshal* pointer ) 
   { 
     SgAsmCilFieldMarshal* source = (SgAsmCilFieldMarshal*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Parent =  source->p_Parent ;
     storageOf_NativeType =  source->p_NativeType ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63915 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldMarshalTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63928 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldMarshalTableStorageClass::pickOutIRNodeData ( SgAsmCilFieldMarshalTable* pointer ) 
   { 
     SgAsmCilFieldMarshalTable* source = (SgAsmCilFieldMarshalTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilFieldMarshalTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilFieldMarshal*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilFieldMarshalTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilFieldMarshal*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilFieldMarshalTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilFieldMarshal*> > :: writeToFile(out) ;
   }


void
SgAsmCilFieldMarshalTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilFieldMarshal*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 63977 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldRVAStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 63990 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldRVAStorageClass::pickOutIRNodeData ( SgAsmCilFieldRVA* pointer ) 
   { 
     SgAsmCilFieldRVA* source = (SgAsmCilFieldRVA*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_RVA =  source->p_RVA ;
     storageOf_Field =  source->p_Field ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64014 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldRVATableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64027 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldRVATableStorageClass::pickOutIRNodeData ( SgAsmCilFieldRVATable* pointer ) 
   { 
     SgAsmCilFieldRVATable* source = (SgAsmCilFieldRVATable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilFieldRVATableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilFieldRVA*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilFieldRVATableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilFieldRVA*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilFieldRVATableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilFieldRVA*> > :: writeToFile(out) ;
   }


void
SgAsmCilFieldRVATableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilFieldRVA*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64076 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFieldTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64089 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFieldTableStorageClass::pickOutIRNodeData ( SgAsmCilFieldTable* pointer ) 
   { 
     SgAsmCilFieldTable* source = (SgAsmCilFieldTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilFieldTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilField*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilFieldTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilField*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilFieldTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilField*> > :: writeToFile(out) ;
   }


void
SgAsmCilFieldTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilField*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64138 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64151 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFileStorageClass::pickOutIRNodeData ( SgAsmCilFile* pointer ) 
   { 
     SgAsmCilFile* source = (SgAsmCilFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Flags =  source->p_Flags ;
     storageOf_Name =  source->p_Name ;
     storageOf_HashValue =  source->p_HashValue ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64176 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilFileTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64189 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilFileTableStorageClass::pickOutIRNodeData ( SgAsmCilFileTable* pointer ) 
   { 
     SgAsmCilFileTable* source = (SgAsmCilFileTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilFileTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilFile*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilFileTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilFile*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilFileTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilFile*> > :: writeToFile(out) ;
   }


void
SgAsmCilFileTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilFile*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64238 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilGenericParamConstraintStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64251 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilGenericParamConstraintStorageClass::pickOutIRNodeData ( SgAsmCilGenericParamConstraint* pointer ) 
   { 
     SgAsmCilGenericParamConstraint* source = (SgAsmCilGenericParamConstraint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Owner =  source->p_Owner ;
     storageOf_Constraint =  source->p_Constraint ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64275 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilGenericParamConstraintTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64288 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilGenericParamConstraintTableStorageClass::pickOutIRNodeData ( SgAsmCilGenericParamConstraintTable* pointer ) 
   { 
     SgAsmCilGenericParamConstraintTable* source = (SgAsmCilGenericParamConstraintTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilGenericParamConstraintTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilGenericParamConstraint*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilGenericParamConstraintTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilGenericParamConstraint*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilGenericParamConstraintTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilGenericParamConstraint*> > :: writeToFile(out) ;
   }


void
SgAsmCilGenericParamConstraintTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilGenericParamConstraint*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64337 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilGenericParamStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64350 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilGenericParamStorageClass::pickOutIRNodeData ( SgAsmCilGenericParam* pointer ) 
   { 
     SgAsmCilGenericParam* source = (SgAsmCilGenericParam*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Number =  source->p_Number ;
     storageOf_Flags =  source->p_Flags ;
     storageOf_Owner =  source->p_Owner ;
     storageOf_Name =  source->p_Name ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64376 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilGenericParamTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64389 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilGenericParamTableStorageClass::pickOutIRNodeData ( SgAsmCilGenericParamTable* pointer ) 
   { 
     SgAsmCilGenericParamTable* source = (SgAsmCilGenericParamTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilGenericParamTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilGenericParam*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilGenericParamTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilGenericParam*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilGenericParamTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilGenericParam*> > :: writeToFile(out) ;
   }


void
SgAsmCilGenericParamTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilGenericParam*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64438 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilImplMapStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64451 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilImplMapStorageClass::pickOutIRNodeData ( SgAsmCilImplMap* pointer ) 
   { 
     SgAsmCilImplMap* source = (SgAsmCilImplMap*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_MappingFlags =  source->p_MappingFlags ;
     storageOf_MemberForwarded =  source->p_MemberForwarded ;
     storageOf_ImportName =  source->p_ImportName ;
     storageOf_ImportScope =  source->p_ImportScope ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64477 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilImplMapTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64490 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilImplMapTableStorageClass::pickOutIRNodeData ( SgAsmCilImplMapTable* pointer ) 
   { 
     SgAsmCilImplMapTable* source = (SgAsmCilImplMapTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilImplMapTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilImplMap*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilImplMapTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilImplMap*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilImplMapTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilImplMap*> > :: writeToFile(out) ;
   }


void
SgAsmCilImplMapTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilImplMap*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64539 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilInterfaceImplStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64552 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilInterfaceImplStorageClass::pickOutIRNodeData ( SgAsmCilInterfaceImpl* pointer ) 
   { 
     SgAsmCilInterfaceImpl* source = (SgAsmCilInterfaceImpl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Class =  source->p_Class ;
     storageOf_Interface =  source->p_Interface ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64576 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilInterfaceImplTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64589 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilInterfaceImplTableStorageClass::pickOutIRNodeData ( SgAsmCilInterfaceImplTable* pointer ) 
   { 
     SgAsmCilInterfaceImplTable* source = (SgAsmCilInterfaceImplTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilInterfaceImplTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilInterfaceImpl*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilInterfaceImplTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilInterfaceImpl*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilInterfaceImplTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilInterfaceImpl*> > :: writeToFile(out) ;
   }


void
SgAsmCilInterfaceImplTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilInterfaceImpl*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64638 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilManifestResourceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64651 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilManifestResourceStorageClass::pickOutIRNodeData ( SgAsmCilManifestResource* pointer ) 
   { 
     SgAsmCilManifestResource* source = (SgAsmCilManifestResource*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Offset =  source->p_Offset ;
     storageOf_Flags =  source->p_Flags ;
     storageOf_Name =  source->p_Name ;
     storageOf_Implementation =  source->p_Implementation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64677 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilManifestResourceTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64690 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilManifestResourceTableStorageClass::pickOutIRNodeData ( SgAsmCilManifestResourceTable* pointer ) 
   { 
     SgAsmCilManifestResourceTable* source = (SgAsmCilManifestResourceTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilManifestResourceTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilManifestResource*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilManifestResourceTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilManifestResource*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilManifestResourceTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilManifestResource*> > :: writeToFile(out) ;
   }


void
SgAsmCilManifestResourceTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilManifestResource*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64739 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMemberRefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64752 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMemberRefStorageClass::pickOutIRNodeData ( SgAsmCilMemberRef* pointer ) 
   { 
     SgAsmCilMemberRef* source = (SgAsmCilMemberRef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Class =  source->p_Class ;
     storageOf_Name =  source->p_Name ;
     storageOf_Signature =  source->p_Signature ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64777 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMemberRefTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64790 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMemberRefTableStorageClass::pickOutIRNodeData ( SgAsmCilMemberRefTable* pointer ) 
   { 
     SgAsmCilMemberRefTable* source = (SgAsmCilMemberRefTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMemberRefTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilMemberRef*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMemberRefTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilMemberRef*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMemberRefTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilMemberRef*> > :: writeToFile(out) ;
   }


void
SgAsmCilMemberRefTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilMemberRef*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64839 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodDefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64852 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodDefStorageClass::pickOutIRNodeData ( SgAsmCilMethodDef* pointer ) 
   { 
     SgAsmCilMethodDef* source = (SgAsmCilMethodDef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_RVA =  source->p_RVA ;
     storageOf_ImplFlags =  source->p_ImplFlags ;
     storageOf_Flags =  source->p_Flags ;
     storageOf_Name =  source->p_Name ;
     storageOf_Signature =  source->p_Signature ;
     storageOf_ParamList =  source->p_ParamList ;
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_initLocals =  source->p_initLocals ;
     storageOf_stackSize =  source->p_stackSize ;
     storageOf_hasMoreSections =  source->p_hasMoreSections ;
     storageOf_localVarSigTok =  source->p_localVarSigTok ;
     storageOf_methodData.storeDataInEasyStorageClass(source->p_methodData);
     storageOf_bodyState =  source->p_bodyState ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMethodDefStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilMethodData*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMethodDefStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilMethodData*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMethodDefStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilMethodData*> > :: writeToFile(out) ;
   }


void
SgAsmCilMethodDefStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilMethodData*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64913 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodDefTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64926 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodDefTableStorageClass::pickOutIRNodeData ( SgAsmCilMethodDefTable* pointer ) 
   { 
     SgAsmCilMethodDefTable* source = (SgAsmCilMethodDefTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMethodDefTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilMethodDef*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMethodDefTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilMethodDef*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMethodDefTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilMethodDef*> > :: writeToFile(out) ;
   }


void
SgAsmCilMethodDefTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilMethodDef*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 64975 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodImplStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 64988 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodImplStorageClass::pickOutIRNodeData ( SgAsmCilMethodImpl* pointer ) 
   { 
     SgAsmCilMethodImpl* source = (SgAsmCilMethodImpl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Class =  source->p_Class ;
     storageOf_MethodBody =  source->p_MethodBody ;
     storageOf_MethodDeclaration =  source->p_MethodDeclaration ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65013 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodImplTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65026 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodImplTableStorageClass::pickOutIRNodeData ( SgAsmCilMethodImplTable* pointer ) 
   { 
     SgAsmCilMethodImplTable* source = (SgAsmCilMethodImplTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMethodImplTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilMethodImpl*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMethodImplTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilMethodImpl*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMethodImplTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilMethodImpl*> > :: writeToFile(out) ;
   }


void
SgAsmCilMethodImplTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilMethodImpl*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65075 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodSemanticsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65088 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodSemanticsStorageClass::pickOutIRNodeData ( SgAsmCilMethodSemantics* pointer ) 
   { 
     SgAsmCilMethodSemantics* source = (SgAsmCilMethodSemantics*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Semantics =  source->p_Semantics ;
     storageOf_Method =  source->p_Method ;
     storageOf_Association =  source->p_Association ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65113 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodSemanticsTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65126 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodSemanticsTableStorageClass::pickOutIRNodeData ( SgAsmCilMethodSemanticsTable* pointer ) 
   { 
     SgAsmCilMethodSemanticsTable* source = (SgAsmCilMethodSemanticsTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMethodSemanticsTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilMethodSemantics*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMethodSemanticsTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilMethodSemantics*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMethodSemanticsTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilMethodSemantics*> > :: writeToFile(out) ;
   }


void
SgAsmCilMethodSemanticsTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilMethodSemantics*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65175 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodSpecStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65188 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodSpecStorageClass::pickOutIRNodeData ( SgAsmCilMethodSpec* pointer ) 
   { 
     SgAsmCilMethodSpec* source = (SgAsmCilMethodSpec*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Method =  source->p_Method ;
     storageOf_Instantiation =  source->p_Instantiation ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65212 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodSpecTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65225 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodSpecTableStorageClass::pickOutIRNodeData ( SgAsmCilMethodSpecTable* pointer ) 
   { 
     SgAsmCilMethodSpecTable* source = (SgAsmCilMethodSpecTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMethodSpecTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilMethodSpec*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMethodSpecTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilMethodSpec*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMethodSpecTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilMethodSpec*> > :: writeToFile(out) ;
   }


void
SgAsmCilMethodSpecTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilMethodSpec*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65274 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilModuleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65287 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilModuleStorageClass::pickOutIRNodeData ( SgAsmCilModule* pointer ) 
   { 
     SgAsmCilModule* source = (SgAsmCilModule*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Generation =  source->p_Generation ;
     storageOf_Name =  source->p_Name ;
     storageOf_Mvid =  source->p_Mvid ;
     storageOf_Encld =  source->p_Encld ;
     storageOf_EncBaseId =  source->p_EncBaseId ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65314 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilModuleRefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65327 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilModuleRefStorageClass::pickOutIRNodeData ( SgAsmCilModuleRef* pointer ) 
   { 
     SgAsmCilModuleRef* source = (SgAsmCilModuleRef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Name =  source->p_Name ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65350 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilModuleRefTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65363 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilModuleRefTableStorageClass::pickOutIRNodeData ( SgAsmCilModuleRefTable* pointer ) 
   { 
     SgAsmCilModuleRefTable* source = (SgAsmCilModuleRefTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilModuleRefTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilModuleRef*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilModuleRefTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilModuleRef*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilModuleRefTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilModuleRef*> > :: writeToFile(out) ;
   }


void
SgAsmCilModuleRefTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilModuleRef*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65412 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilModuleTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65425 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilModuleTableStorageClass::pickOutIRNodeData ( SgAsmCilModuleTable* pointer ) 
   { 
     SgAsmCilModuleTable* source = (SgAsmCilModuleTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilModuleTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilModule*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilModuleTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilModule*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilModuleTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilModule*> > :: writeToFile(out) ;
   }


void
SgAsmCilModuleTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilModule*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65474 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilNestedClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65487 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilNestedClassStorageClass::pickOutIRNodeData ( SgAsmCilNestedClass* pointer ) 
   { 
     SgAsmCilNestedClass* source = (SgAsmCilNestedClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_NestedClass =  source->p_NestedClass ;
     storageOf_EnclosingClass =  source->p_EnclosingClass ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65511 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilNestedClassTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65524 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilNestedClassTableStorageClass::pickOutIRNodeData ( SgAsmCilNestedClassTable* pointer ) 
   { 
     SgAsmCilNestedClassTable* source = (SgAsmCilNestedClassTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilNestedClassTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilNestedClass*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilNestedClassTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilNestedClass*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilNestedClassTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilNestedClass*> > :: writeToFile(out) ;
   }


void
SgAsmCilNestedClassTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilNestedClass*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65573 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilParamStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65586 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilParamStorageClass::pickOutIRNodeData ( SgAsmCilParam* pointer ) 
   { 
     SgAsmCilParam* source = (SgAsmCilParam*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Flags =  source->p_Flags ;
     storageOf_Sequence =  source->p_Sequence ;
     storageOf_Name =  source->p_Name ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65611 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilParamTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65624 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilParamTableStorageClass::pickOutIRNodeData ( SgAsmCilParamTable* pointer ) 
   { 
     SgAsmCilParamTable* source = (SgAsmCilParamTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilParamTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilParam*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilParamTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilParam*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilParamTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilParam*> > :: writeToFile(out) ;
   }


void
SgAsmCilParamTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilParam*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65673 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilPropertyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65686 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilPropertyStorageClass::pickOutIRNodeData ( SgAsmCilProperty* pointer ) 
   { 
     SgAsmCilProperty* source = (SgAsmCilProperty*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Flags =  source->p_Flags ;
     storageOf_Name =  source->p_Name ;
     storageOf_Type =  source->p_Type ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65711 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilPropertyMapStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65724 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilPropertyMapStorageClass::pickOutIRNodeData ( SgAsmCilPropertyMap* pointer ) 
   { 
     SgAsmCilPropertyMap* source = (SgAsmCilPropertyMap*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Parent =  source->p_Parent ;
     storageOf_PropertyList =  source->p_PropertyList ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65748 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilPropertyMapTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65761 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilPropertyMapTableStorageClass::pickOutIRNodeData ( SgAsmCilPropertyMapTable* pointer ) 
   { 
     SgAsmCilPropertyMapTable* source = (SgAsmCilPropertyMapTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilPropertyMapTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilPropertyMap*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilPropertyMapTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilPropertyMap*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilPropertyMapTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilPropertyMap*> > :: writeToFile(out) ;
   }


void
SgAsmCilPropertyMapTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilPropertyMap*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65810 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilPropertyTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65823 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilPropertyTableStorageClass::pickOutIRNodeData ( SgAsmCilPropertyTable* pointer ) 
   { 
     SgAsmCilPropertyTable* source = (SgAsmCilPropertyTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilPropertyTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilProperty*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilPropertyTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilProperty*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilPropertyTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilProperty*> > :: writeToFile(out) ;
   }


void
SgAsmCilPropertyTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilProperty*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65872 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilStandAloneSigStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65885 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilStandAloneSigStorageClass::pickOutIRNodeData ( SgAsmCilStandAloneSig* pointer ) 
   { 
     SgAsmCilStandAloneSig* source = (SgAsmCilStandAloneSig*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Signature =  source->p_Signature ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65908 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilStandAloneSigTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65921 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilStandAloneSigTableStorageClass::pickOutIRNodeData ( SgAsmCilStandAloneSigTable* pointer ) 
   { 
     SgAsmCilStandAloneSigTable* source = (SgAsmCilStandAloneSigTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilStandAloneSigTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilStandAloneSig*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilStandAloneSigTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilStandAloneSig*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilStandAloneSigTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilStandAloneSig*> > :: writeToFile(out) ;
   }


void
SgAsmCilStandAloneSigTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilStandAloneSig*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 65970 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilTypeDefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 65983 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilTypeDefStorageClass::pickOutIRNodeData ( SgAsmCilTypeDef* pointer ) 
   { 
     SgAsmCilTypeDef* source = (SgAsmCilTypeDef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Flags =  source->p_Flags ;
     storageOf_TypeName =  source->p_TypeName ;
     storageOf_TypeNamespace =  source->p_TypeNamespace ;
     storageOf_Extends =  source->p_Extends ;
     storageOf_FieldList =  source->p_FieldList ;
     storageOf_MethodList =  source->p_MethodList ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66011 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilTypeDefTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66024 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilTypeDefTableStorageClass::pickOutIRNodeData ( SgAsmCilTypeDefTable* pointer ) 
   { 
     SgAsmCilTypeDefTable* source = (SgAsmCilTypeDefTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilTypeDefTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilTypeDef*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilTypeDefTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilTypeDef*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilTypeDefTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilTypeDef*> > :: writeToFile(out) ;
   }


void
SgAsmCilTypeDefTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilTypeDef*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66073 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilTypeRefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66086 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilTypeRefStorageClass::pickOutIRNodeData ( SgAsmCilTypeRef* pointer ) 
   { 
     SgAsmCilTypeRef* source = (SgAsmCilTypeRef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_ResolutionScope =  source->p_ResolutionScope ;
     storageOf_TypeName =  source->p_TypeName ;
     storageOf_TypeNamespace =  source->p_TypeNamespace ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66111 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilTypeRefTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66124 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilTypeRefTableStorageClass::pickOutIRNodeData ( SgAsmCilTypeRefTable* pointer ) 
   { 
     SgAsmCilTypeRefTable* source = (SgAsmCilTypeRefTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilTypeRefTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilTypeRef*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilTypeRefTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilTypeRef*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilTypeRefTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilTypeRef*> > :: writeToFile(out) ;
   }


void
SgAsmCilTypeRefTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilTypeRef*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66173 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilTypeSpecStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilTypeSpecStorageClass::pickOutIRNodeData ( SgAsmCilTypeSpec* pointer ) 
   { 
     SgAsmCilTypeSpec* source = (SgAsmCilTypeSpec*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Signature =  source->p_Signature ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66209 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilTypeSpecTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66222 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilTypeSpecTableStorageClass::pickOutIRNodeData ( SgAsmCilTypeSpecTable* pointer ) 
   { 
     SgAsmCilTypeSpecTable* source = (SgAsmCilTypeSpecTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_elements.storeDataInEasyStorageClass(source->p_elements);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilTypeSpecTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilTypeSpec*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilTypeSpecTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilTypeSpec*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilTypeSpecTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilTypeSpec*> > :: writeToFile(out) ;
   }


void
SgAsmCilTypeSpecTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilTypeSpec*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66271 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMetadataRootStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66284 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMetadataRootStorageClass::pickOutIRNodeData ( SgAsmCilMetadataRoot* pointer ) 
   { 
     SgAsmCilMetadataRoot* source = (SgAsmCilMetadataRoot*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_Signature =  source->p_Signature ;
     storageOf_MajorVersion =  source->p_MajorVersion ;
     storageOf_MinorVersion =  source->p_MinorVersion ;
     storageOf_Reserved0 =  source->p_Reserved0 ;
     storageOf_Length =  source->p_Length ;
     storageOf_Version.storeDataInEasyStorageClass(source->p_Version);
     storageOf_VersionPadding =  source->p_VersionPadding ;
     storageOf_Flags =  source->p_Flags ;
     storageOf_NumberOfStreams =  source->p_NumberOfStreams ;
     storageOf_Streams.storeDataInEasyStorageClass(source->p_Streams);
     storageOf_ErrorFree =  source->p_ErrorFree ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMetadataRootStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::vector<SgAsmCilDataStream*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMetadataRootStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < std::vector<SgAsmCilDataStream*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMetadataRootStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < std::vector<SgAsmCilDataStream*> > :: writeToFile(out) ;
   }


void
SgAsmCilMetadataRootStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < std::vector<SgAsmCilDataStream*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66347 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilMethodDataStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66360 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilMethodDataStorageClass::pickOutIRNodeData ( SgAsmCilMethodData* pointer ) 
   { 
     SgAsmCilMethodData* source = (SgAsmCilMethodData*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_dataSize =  source->p_dataSize ;
     storageOf_clauses.storeDataInEasyStorageClass(source->p_clauses);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilMethodDataStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::vector<SgAsmCilExceptionData*> > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilMethodDataStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::vector<SgAsmCilExceptionData*> > :: deleteMemoryPool() ;
   }

void
SgAsmCilMethodDataStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::vector<SgAsmCilExceptionData*> > :: writeToFile(out) ;
   }


void
SgAsmCilMethodDataStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::vector<SgAsmCilExceptionData*> > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66411 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExecutableFileFormatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66424 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExecutableFileFormatStorageClass::pickOutIRNodeData ( SgAsmExecutableFileFormat* pointer ) 
   { 
     SgAsmExecutableFileFormat* source = (SgAsmExecutableFileFormat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66446 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66459 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolListStorageClass::pickOutIRNodeData ( SgAsmCoffSymbolList* pointer ) 
   { 
     SgAsmCoffSymbolList* source = (SgAsmCoffSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmCoffSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmCoffSymbolPtrList::value_type *  tempListsymbols = new SgAsmCoffSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmCoffSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCoffSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmCoffSymbolPtrList > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmCoffSymbolPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66525 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInformationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66538 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInformationStorageClass::pickOutIRNodeData ( SgAsmDwarfInformation* pointer ) 
   { 
     SgAsmDwarfInformation* source = (SgAsmDwarfInformation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66560 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCompilationUnitListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66573 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCompilationUnitListStorageClass::pickOutIRNodeData ( SgAsmDwarfCompilationUnitList* pointer ) 
   { 
     SgAsmDwarfCompilationUnitList* source = (SgAsmDwarfCompilationUnitList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmDwarfCompilationUnitPtrList::iterator i_cu_list = source->p_cu_list.begin() ; 
     unsigned int tempListCountcu_list = 0; 
     SgAsmDwarfCompilationUnitPtrList::value_type *  tempListcu_list = new SgAsmDwarfCompilationUnitPtrList::value_type[ source->p_cu_list.size() ]; 
     for ( ; i_cu_list != source->p_cu_list.end(); ++i_cu_list ) 
        {
          tempListcu_list[tempListCountcu_list] = *i_cu_list;
          tempListCountcu_list++; 
          (*i_cu_list) = (SgAsmDwarfCompilationUnitPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_cu_list ) );
        }
     storageOf_cu_list.storeDataInEasyStorageClass(source->p_cu_list);
     tempListCountcu_list = 0; 
     i_cu_list = source->p_cu_list.begin() ; 
     for ( ; i_cu_list != source->p_cu_list.end(); ++i_cu_list ) 
        {
          *i_cu_list = tempListcu_list[tempListCountcu_list] ;
          tempListCountcu_list++; 
        }
      delete [] tempListcu_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCompilationUnitListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: writeToFile(out) ;
   }


void
SgAsmDwarfCompilationUnitListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfCompilationUnitPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66639 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstructStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66652 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstructStorageClass::pickOutIRNodeData ( SgAsmDwarfConstruct* pointer ) 
   { 
     SgAsmDwarfConstruct* source = (SgAsmDwarfConstruct*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfConstructStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstructStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstructStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstructStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66705 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfAccessDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66718 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfAccessDeclarationStorageClass::pickOutIRNodeData ( SgAsmDwarfAccessDeclaration* pointer ) 
   { 
     SgAsmDwarfAccessDeclaration* source = (SgAsmDwarfAccessDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfAccessDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfAccessDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66771 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfArrayTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66784 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfArrayTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfArrayType* pointer ) 
   { 
     SgAsmDwarfArrayType* source = (SgAsmDwarfArrayType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfArrayTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfArrayTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfArrayTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfArrayTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66838 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfBaseTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66851 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfBaseTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfBaseType* pointer ) 
   { 
     SgAsmDwarfBaseType* source = (SgAsmDwarfBaseType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfBaseTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfBaseTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfBaseTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfBaseTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66904 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCatchBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66917 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCatchBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfCatchBlock* pointer ) 
   { 
     SgAsmDwarfCatchBlock* source = (SgAsmDwarfCatchBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfCatchBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCatchBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCatchBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfCatchBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 66970 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfClassTemplateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 66983 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfClassTemplateStorageClass::pickOutIRNodeData ( SgAsmDwarfClassTemplate* pointer ) 
   { 
     SgAsmDwarfClassTemplate* source = (SgAsmDwarfClassTemplate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfClassTemplateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfClassTemplateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfClassTemplateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfClassTemplateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67036 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfClassTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67049 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfClassTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfClassType* pointer ) 
   { 
     SgAsmDwarfClassType* source = (SgAsmDwarfClassType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfClassTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfClassTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfClassTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfClassTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67103 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCommonBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67116 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCommonBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfCommonBlock* pointer ) 
   { 
     SgAsmDwarfCommonBlock* source = (SgAsmDwarfCommonBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfCommonBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCommonBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCommonBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfCommonBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67170 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCommonInclusionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67183 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCommonInclusionStorageClass::pickOutIRNodeData ( SgAsmDwarfCommonInclusion* pointer ) 
   { 
     SgAsmDwarfCommonInclusion* source = (SgAsmDwarfCommonInclusion*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCommonInclusionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfCommonInclusionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67236 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfCompilationUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67249 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfCompilationUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfCompilationUnit* pointer ) 
   { 
     SgAsmDwarfCompilationUnit* source = (SgAsmDwarfCompilationUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_producer.storeDataInEasyStorageClass(source->p_producer);
     storageOf_language.storeDataInEasyStorageClass(source->p_language);
     storageOf_low_pc =  source->p_low_pc ;
     storageOf_hi_pc =  source->p_hi_pc ;
     storageOf_version_stamp =  source->p_version_stamp ;
     storageOf_abbrev_offset =  source->p_abbrev_offset ;
     storageOf_address_size =  source->p_address_size ;
     storageOf_offset_length =  source->p_offset_length ;
     storageOf_line_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_line_info );
     storageOf_language_constructs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_language_constructs );
     storageOf_macro_info = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_macro_info );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfCompilationUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfCompilationUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67313 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConditionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67326 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConditionStorageClass::pickOutIRNodeData ( SgAsmDwarfCondition* pointer ) 
   { 
     SgAsmDwarfCondition* source = (SgAsmDwarfCondition*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfConditionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConditionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConditionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfConditionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67379 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstantStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67392 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstantStorageClass::pickOutIRNodeData ( SgAsmDwarfConstant* pointer ) 
   { 
     SgAsmDwarfConstant* source = (SgAsmDwarfConstant*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfConstantStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstantStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstantStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstantStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67445 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67458 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfConstType* pointer ) 
   { 
     SgAsmDwarfConstType* source = (SgAsmDwarfConstType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfConstTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67511 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfDwarfProcedureStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67524 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfDwarfProcedureStorageClass::pickOutIRNodeData ( SgAsmDwarfDwarfProcedure* pointer ) 
   { 
     SgAsmDwarfDwarfProcedure* source = (SgAsmDwarfDwarfProcedure*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfDwarfProcedureStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfDwarfProcedureStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67577 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67590 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEntryPointStorageClass::pickOutIRNodeData ( SgAsmDwarfEntryPoint* pointer ) 
   { 
     SgAsmDwarfEntryPoint* source = (SgAsmDwarfEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67643 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEnumerationTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67656 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEnumerationTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfEnumerationType* pointer ) 
   { 
     SgAsmDwarfEnumerationType* source = (SgAsmDwarfEnumerationType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEnumerationTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfEnumerationTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67710 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfEnumeratorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67723 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfEnumeratorStorageClass::pickOutIRNodeData ( SgAsmDwarfEnumerator* pointer ) 
   { 
     SgAsmDwarfEnumerator* source = (SgAsmDwarfEnumerator*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfEnumeratorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfEnumeratorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfEnumeratorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfEnumeratorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67776 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFileTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67789 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFileTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfFileType* pointer ) 
   { 
     SgAsmDwarfFileType* source = (SgAsmDwarfFileType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfFileTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFileTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFileTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfFileTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67842 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFormalParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67855 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFormalParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfFormalParameter* pointer ) 
   { 
     SgAsmDwarfFormalParameter* source = (SgAsmDwarfFormalParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfFormalParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFormalParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFormalParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfFormalParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67908 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFormatLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67921 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFormatLabelStorageClass::pickOutIRNodeData ( SgAsmDwarfFormatLabel* pointer ) 
   { 
     SgAsmDwarfFormatLabel* source = (SgAsmDwarfFormatLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfFormatLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFormatLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFormatLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfFormatLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 67974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFriendStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 67987 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFriendStorageClass::pickOutIRNodeData ( SgAsmDwarfFriend* pointer ) 
   { 
     SgAsmDwarfFriend* source = (SgAsmDwarfFriend*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfFriendStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFriendStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFriendStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfFriendStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68040 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfFunctionTemplateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68053 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfFunctionTemplateStorageClass::pickOutIRNodeData ( SgAsmDwarfFunctionTemplate* pointer ) 
   { 
     SgAsmDwarfFunctionTemplate* source = (SgAsmDwarfFunctionTemplate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfFunctionTemplateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfFunctionTemplateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68106 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68119 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedDeclarationStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedDeclaration* pointer ) 
   { 
     SgAsmDwarfImportedDeclaration* source = (SgAsmDwarfImportedDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68172 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedModuleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68185 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedModuleStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedModule* pointer ) 
   { 
     SgAsmDwarfImportedModule* source = (SgAsmDwarfImportedModule*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfImportedModuleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedModuleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedModuleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedModuleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68238 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfImportedUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68251 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfImportedUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfImportedUnit* pointer ) 
   { 
     SgAsmDwarfImportedUnit* source = (SgAsmDwarfImportedUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfImportedUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfImportedUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfImportedUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfImportedUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68304 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInheritanceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68317 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInheritanceStorageClass::pickOutIRNodeData ( SgAsmDwarfInheritance* pointer ) 
   { 
     SgAsmDwarfInheritance* source = (SgAsmDwarfInheritance*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfInheritanceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInheritanceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInheritanceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfInheritanceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68370 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInlinedSubroutineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68383 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInlinedSubroutineStorageClass::pickOutIRNodeData ( SgAsmDwarfInlinedSubroutine* pointer ) 
   { 
     SgAsmDwarfInlinedSubroutine* source = (SgAsmDwarfInlinedSubroutine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInlinedSubroutineStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfInlinedSubroutineStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68437 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfInterfaceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68450 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfInterfaceTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfInterfaceType* pointer ) 
   { 
     SgAsmDwarfInterfaceType* source = (SgAsmDwarfInterfaceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfInterfaceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfInterfaceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68503 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLabelStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68516 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLabelStorageClass::pickOutIRNodeData ( SgAsmDwarfLabel* pointer ) 
   { 
     SgAsmDwarfLabel* source = (SgAsmDwarfLabel*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfLabelStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLabelStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLabelStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfLabelStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68569 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLexicalBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68582 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLexicalBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfLexicalBlock* pointer ) 
   { 
     SgAsmDwarfLexicalBlock* source = (SgAsmDwarfLexicalBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLexicalBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfLexicalBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68636 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMemberStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68649 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMemberStorageClass::pickOutIRNodeData ( SgAsmDwarfMember* pointer ) 
   { 
     SgAsmDwarfMember* source = (SgAsmDwarfMember*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfMemberStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMemberStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMemberStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfMemberStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68702 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfModuleStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68715 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfModuleStorageClass::pickOutIRNodeData ( SgAsmDwarfModule* pointer ) 
   { 
     SgAsmDwarfModule* source = (SgAsmDwarfModule*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfModuleStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfModuleStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfModuleStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfModuleStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68768 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMutableTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68781 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMutableTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfMutableType* pointer ) 
   { 
     SgAsmDwarfMutableType* source = (SgAsmDwarfMutableType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfMutableTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMutableTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMutableTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfMutableTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68834 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamelistStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68847 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamelistStorageClass::pickOutIRNodeData ( SgAsmDwarfNamelist* pointer ) 
   { 
     SgAsmDwarfNamelist* source = (SgAsmDwarfNamelist*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfNamelistStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamelistStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamelistStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamelistStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68900 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamelistItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68913 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamelistItemStorageClass::pickOutIRNodeData ( SgAsmDwarfNamelistItem* pointer ) 
   { 
     SgAsmDwarfNamelistItem* source = (SgAsmDwarfNamelistItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfNamelistItemStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamelistItemStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamelistItemStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamelistItemStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 68966 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfNamespaceStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 68979 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfNamespaceStorageClass::pickOutIRNodeData ( SgAsmDwarfNamespace* pointer ) 
   { 
     SgAsmDwarfNamespace* source = (SgAsmDwarfNamespace*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfNamespaceStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfNamespaceStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfNamespaceStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfNamespaceStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69033 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPackedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69046 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPackedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPackedType* pointer ) 
   { 
     SgAsmDwarfPackedType* source = (SgAsmDwarfPackedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfPackedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPackedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPackedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfPackedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69099 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPartialUnitStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69112 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPartialUnitStorageClass::pickOutIRNodeData ( SgAsmDwarfPartialUnit* pointer ) 
   { 
     SgAsmDwarfPartialUnit* source = (SgAsmDwarfPartialUnit*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfPartialUnitStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPartialUnitStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPartialUnitStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfPartialUnitStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69165 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPointerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69178 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPointerTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPointerType* pointer ) 
   { 
     SgAsmDwarfPointerType* source = (SgAsmDwarfPointerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfPointerTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPointerTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPointerTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfPointerTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69231 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfPtrToMemberTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69244 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfPtrToMemberTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfPtrToMemberType* pointer ) 
   { 
     SgAsmDwarfPtrToMemberType* source = (SgAsmDwarfPtrToMemberType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfPtrToMemberTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfPtrToMemberTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69297 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfReferenceTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69310 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfReferenceTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfReferenceType* pointer ) 
   { 
     SgAsmDwarfReferenceType* source = (SgAsmDwarfReferenceType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfReferenceTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfReferenceTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69363 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfRestrictTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69376 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfRestrictTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfRestrictType* pointer ) 
   { 
     SgAsmDwarfRestrictType* source = (SgAsmDwarfRestrictType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfRestrictTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfRestrictTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69429 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSetTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69442 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSetTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSetType* pointer ) 
   { 
     SgAsmDwarfSetType* source = (SgAsmDwarfSetType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfSetTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSetTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSetTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfSetTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69495 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSharedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69508 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSharedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSharedType* pointer ) 
   { 
     SgAsmDwarfSharedType* source = (SgAsmDwarfSharedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfSharedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSharedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSharedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfSharedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69561 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfStringTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69574 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfStringTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfStringType* pointer ) 
   { 
     SgAsmDwarfStringType* source = (SgAsmDwarfStringType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfStringTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfStringTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfStringTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfStringTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69627 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfStructureTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69640 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfStructureTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfStructureType* pointer ) 
   { 
     SgAsmDwarfStructureType* source = (SgAsmDwarfStructureType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfStructureTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfStructureTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfStructureTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfStructureTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69694 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubprogramStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69707 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubprogramStorageClass::pickOutIRNodeData ( SgAsmDwarfSubprogram* pointer ) 
   { 
     SgAsmDwarfSubprogram* source = (SgAsmDwarfSubprogram*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfSubprogramStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubprogramStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubprogramStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubprogramStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69761 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubrangeTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69774 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubrangeTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSubrangeType* pointer ) 
   { 
     SgAsmDwarfSubrangeType* source = (SgAsmDwarfSubrangeType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubrangeTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubrangeTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69827 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfSubroutineTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69840 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfSubroutineTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfSubroutineType* pointer ) 
   { 
     SgAsmDwarfSubroutineType* source = (SgAsmDwarfSubroutineType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfSubroutineTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfSubroutineTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69894 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTemplateTypeParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69907 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTemplateTypeParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfTemplateTypeParameter* pointer ) 
   { 
     SgAsmDwarfTemplateTypeParameter* source = (SgAsmDwarfTemplateTypeParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTemplateTypeParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfTemplateTypeParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 69960 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTemplateValueParameterStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 69973 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTemplateValueParameterStorageClass::pickOutIRNodeData ( SgAsmDwarfTemplateValueParameter* pointer ) 
   { 
     SgAsmDwarfTemplateValueParameter* source = (SgAsmDwarfTemplateValueParameter*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTemplateValueParameterStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfTemplateValueParameterStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70026 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfThrownTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70039 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfThrownTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfThrownType* pointer ) 
   { 
     SgAsmDwarfThrownType* source = (SgAsmDwarfThrownType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfThrownTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfThrownTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfThrownTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfThrownTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70092 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTryBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70105 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTryBlockStorageClass::pickOutIRNodeData ( SgAsmDwarfTryBlock* pointer ) 
   { 
     SgAsmDwarfTryBlock* source = (SgAsmDwarfTryBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfTryBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTryBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTryBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfTryBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70158 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfTypedefStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70171 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfTypedefStorageClass::pickOutIRNodeData ( SgAsmDwarfTypedef* pointer ) 
   { 
     SgAsmDwarfTypedef* source = (SgAsmDwarfTypedef*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfTypedefStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfTypedefStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfTypedefStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfTypedefStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70224 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnionTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70237 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnionTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUnionType* pointer ) 
   { 
     SgAsmDwarfUnionType* source = (SgAsmDwarfUnionType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_body = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_body );
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfUnionTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnionTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnionTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnionTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70291 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnknownConstructStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70304 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnknownConstructStorageClass::pickOutIRNodeData ( SgAsmDwarfUnknownConstruct* pointer ) 
   { 
     SgAsmDwarfUnknownConstruct* source = (SgAsmDwarfUnknownConstruct*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnknownConstructStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnknownConstructStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70357 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnspecifiedParametersStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70370 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnspecifiedParametersStorageClass::pickOutIRNodeData ( SgAsmDwarfUnspecifiedParameters* pointer ) 
   { 
     SgAsmDwarfUnspecifiedParameters* source = (SgAsmDwarfUnspecifiedParameters*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnspecifiedParametersStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnspecifiedParametersStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70423 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUnspecifiedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70436 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUnspecifiedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUnspecifiedType* pointer ) 
   { 
     SgAsmDwarfUnspecifiedType* source = (SgAsmDwarfUnspecifiedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUnspecifiedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfUnspecifiedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70489 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcRelaxedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70502 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcRelaxedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcRelaxedType* pointer ) 
   { 
     SgAsmDwarfUpcRelaxedType* source = (SgAsmDwarfUpcRelaxedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcRelaxedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcRelaxedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70555 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcSharedTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70568 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcSharedTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcSharedType* pointer ) 
   { 
     SgAsmDwarfUpcSharedType* source = (SgAsmDwarfUpcSharedType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcSharedTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcSharedTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70621 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfUpcStrictTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70634 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfUpcStrictTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfUpcStrictType* pointer ) 
   { 
     SgAsmDwarfUpcStrictType* source = (SgAsmDwarfUpcStrictType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfUpcStrictTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfUpcStrictTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70687 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70700 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariableStorageClass::pickOutIRNodeData ( SgAsmDwarfVariable* pointer ) 
   { 
     SgAsmDwarfVariable* source = (SgAsmDwarfVariable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfVariableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70753 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariantStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70766 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariantStorageClass::pickOutIRNodeData ( SgAsmDwarfVariant* pointer ) 
   { 
     SgAsmDwarfVariant* source = (SgAsmDwarfVariant*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfVariantStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariantStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariantStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariantStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70819 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVariantPartStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70832 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVariantPartStorageClass::pickOutIRNodeData ( SgAsmDwarfVariantPart* pointer ) 
   { 
     SgAsmDwarfVariantPart* source = (SgAsmDwarfVariantPart*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfVariantPartStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVariantPartStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVariantPartStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfVariantPartStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70885 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfVolatileTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70898 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfVolatileTypeStorageClass::pickOutIRNodeData ( SgAsmDwarfVolatileType* pointer ) 
   { 
     SgAsmDwarfVolatileType* source = (SgAsmDwarfVolatileType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfVolatileTypeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfVolatileTypeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 70951 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfWithStmtStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 70964 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfWithStmtStorageClass::pickOutIRNodeData ( SgAsmDwarfWithStmt* pointer ) 
   { 
     SgAsmDwarfWithStmt* source = (SgAsmDwarfWithStmt*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nesting_level =  source->p_nesting_level ;
     storageOf_offset =  source->p_offset ;
     storageOf_overall_offset =  source->p_overall_offset ;
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_source_position = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_source_position );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfWithStmtStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfWithStmtStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfWithStmtStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfWithStmtStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71017 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfConstructListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71030 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfConstructListStorageClass::pickOutIRNodeData ( SgAsmDwarfConstructList* pointer ) 
   { 
     SgAsmDwarfConstructList* source = (SgAsmDwarfConstructList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmDwarfConstructPtrList::iterator i_list = source->p_list.begin() ; 
     unsigned int tempListCountlist = 0; 
     SgAsmDwarfConstructPtrList::value_type *  tempListlist = new SgAsmDwarfConstructPtrList::value_type[ source->p_list.size() ]; 
     for ( ; i_list != source->p_list.end(); ++i_list ) 
        {
          tempListlist[tempListCountlist] = *i_list;
          tempListCountlist++; 
          (*i_list) = (SgAsmDwarfConstructPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_list ) );
        }
     storageOf_list.storeDataInEasyStorageClass(source->p_list);
     tempListCountlist = 0; 
     i_list = source->p_list.begin() ; 
     for ( ; i_list != source->p_list.end(); ++i_list ) 
        {
          *i_list = tempListlist[tempListCountlist] ;
          tempListCountlist++; 
        }
      delete [] tempListlist; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfConstructListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfConstructListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfConstructListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfConstructPtrList > :: writeToFile(out) ;
   }


void
SgAsmDwarfConstructListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfConstructPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71096 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLineStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71109 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLineStorageClass::pickOutIRNodeData ( SgAsmDwarfLine* pointer ) 
   { 
     SgAsmDwarfLine* source = (SgAsmDwarfLine*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_file_id =  source->p_file_id ;
     storageOf_line =  source->p_line ;
     storageOf_column =  source->p_column ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71135 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfLineListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71148 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfLineListStorageClass::pickOutIRNodeData ( SgAsmDwarfLineList* pointer ) 
   { 
     SgAsmDwarfLineList* source = (SgAsmDwarfLineList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmDwarfLinePtrList::iterator i_line_list = source->p_line_list.begin() ; 
     unsigned int tempListCountline_list = 0; 
     SgAsmDwarfLinePtrList::value_type *  tempListline_list = new SgAsmDwarfLinePtrList::value_type[ source->p_line_list.size() ]; 
     for ( ; i_line_list != source->p_line_list.end(); ++i_line_list ) 
        {
          tempListline_list[tempListCountline_list] = *i_line_list;
          tempListCountline_list++; 
          (*i_line_list) = (SgAsmDwarfLinePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_line_list ) );
        }
     storageOf_line_list.storeDataInEasyStorageClass(source->p_line_list);
     tempListCountline_list = 0; 
     i_line_list = source->p_line_list.begin() ; 
     for ( ; i_line_list != source->p_line_list.end(); ++i_line_list ) 
        {
          *i_line_list = tempListline_list[tempListCountline_list] ;
          tempListCountline_list++; 
        }
      delete [] tempListline_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfLineListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfLinePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfLineListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfLinePtrList > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfLineListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfLinePtrList > :: writeToFile(out) ;
   }


void
SgAsmDwarfLineListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfLinePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71214 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMacroStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71227 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMacroStorageClass::pickOutIRNodeData ( SgAsmDwarfMacro* pointer ) 
   { 
     SgAsmDwarfMacro* source = (SgAsmDwarfMacro*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_macro_string.storeDataInEasyStorageClass(source->p_macro_string);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfMacroStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMacroStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMacroStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDwarfMacroStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71276 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDwarfMacroListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71289 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDwarfMacroListStorageClass::pickOutIRNodeData ( SgAsmDwarfMacroList* pointer ) 
   { 
     SgAsmDwarfMacroList* source = (SgAsmDwarfMacroList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmDwarfMacroPtrList::iterator i_macro_list = source->p_macro_list.begin() ; 
     unsigned int tempListCountmacro_list = 0; 
     SgAsmDwarfMacroPtrList::value_type *  tempListmacro_list = new SgAsmDwarfMacroPtrList::value_type[ source->p_macro_list.size() ]; 
     for ( ; i_macro_list != source->p_macro_list.end(); ++i_macro_list ) 
        {
          tempListmacro_list[tempListCountmacro_list] = *i_macro_list;
          tempListCountmacro_list++; 
          (*i_macro_list) = (SgAsmDwarfMacroPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_macro_list ) );
        }
     storageOf_macro_list.storeDataInEasyStorageClass(source->p_macro_list);
     tempListCountmacro_list = 0; 
     i_macro_list = source->p_macro_list.begin() ; 
     for ( ; i_macro_list != source->p_macro_list.end(); ++i_macro_list ) 
        {
          *i_macro_list = tempListmacro_list[tempListCountmacro_list] ;
          tempListCountmacro_list++; 
        }
      delete [] tempListmacro_list; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDwarfMacroListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDwarfMacroListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmDwarfMacroListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmDwarfMacroPtrList > :: writeToFile(out) ;
   }


void
SgAsmDwarfMacroListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmDwarfMacroPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71355 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71368 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicEntryStorageClass::pickOutIRNodeData ( SgAsmElfDynamicEntry* pointer ) 
   { 
     SgAsmElfDynamicEntry* source = (SgAsmElfDynamicEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_d_tag =  source->p_d_tag ;
     storageOf_d_val =  source->p_d_val ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfDynamicEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71420 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71433 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicEntryListStorageClass::pickOutIRNodeData ( SgAsmElfDynamicEntryList* pointer ) 
   { 
     SgAsmElfDynamicEntryList* source = (SgAsmElfDynamicEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfDynamicEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfDynamicEntryPtrList::value_type *  tempListentries = new SgAsmElfDynamicEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfDynamicEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfDynamicEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfDynamicEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71499 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryCIStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71512 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryCIStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryCI* pointer ) 
   { 
     SgAsmElfEHFrameEntryCI* source = (SgAsmElfEHFrameEntryCI*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_augmentation_string.storeDataInEasyStorageClass(source->p_augmentation_string);
     storageOf_eh_data =  source->p_eh_data ;
     storageOf_code_alignment_factor =  source->p_code_alignment_factor ;
     storageOf_data_alignment_factor =  source->p_data_alignment_factor ;
     storageOf_augmentation_data_length =  source->p_augmentation_data_length ;
     storageOf_lsda_encoding =  source->p_lsda_encoding ;
     storageOf_prh_encoding =  source->p_prh_encoding ;
     storageOf_prh_arg =  source->p_prh_arg ;
     storageOf_prh_addr =  source->p_prh_addr ;
     storageOf_addr_encoding =  source->p_addr_encoding ;
     storageOf_sig_frame =  source->p_sig_frame ;
     storageOf_instructions.storeDataInEasyStorageClass(source->p_instructions);
     storageOf_fd_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fd_entries );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryCIStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryCIStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71578 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryCIListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71591 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryCIListStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryCIList* pointer ) 
   { 
     SgAsmElfEHFrameEntryCIList* source = (SgAsmElfEHFrameEntryCIList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfEHFrameEntryCIPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfEHFrameEntryCIPtrList::value_type *  tempListentries = new SgAsmElfEHFrameEntryCIPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfEHFrameEntryCIPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryCIListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryCIListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfEHFrameEntryCIPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71657 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryFDStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71670 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryFDStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryFD* pointer ) 
   { 
     SgAsmElfEHFrameEntryFD* source = (SgAsmElfEHFrameEntryFD*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_begin_rva =  source->p_begin_rva ;
     storageOf_size =  source->p_size ;
     storageOf_augmentation_data.storeDataInEasyStorageClass(source->p_augmentation_data);
     storageOf_instructions.storeDataInEasyStorageClass(source->p_instructions);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryFDStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryFDStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71722 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameEntryFDListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71735 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameEntryFDListStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameEntryFDList* pointer ) 
   { 
     SgAsmElfEHFrameEntryFDList* source = (SgAsmElfEHFrameEntryFDList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfEHFrameEntryFDPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfEHFrameEntryFDPtrList::value_type *  tempListentries = new SgAsmElfEHFrameEntryFDPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfEHFrameEntryFDPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameEntryFDListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameEntryFDListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfEHFrameEntryFDPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71801 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71814 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteEntryStorageClass::pickOutIRNodeData ( SgAsmElfNoteEntry* pointer ) 
   { 
     SgAsmElfNoteEntry* source = (SgAsmElfNoteEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type =  source->p_type ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_payload.storeDataInEasyStorageClass(source->p_payload);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfNoteEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfNoteEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71865 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71878 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteEntryListStorageClass::pickOutIRNodeData ( SgAsmElfNoteEntryList* pointer ) 
   { 
     SgAsmElfNoteEntryList* source = (SgAsmElfNoteEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfNoteEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfNoteEntryPtrList::value_type *  tempListentries = new SgAsmElfNoteEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfNoteEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfNoteEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfNoteEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfNoteEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfNoteEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 71944 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 71957 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocEntryStorageClass::pickOutIRNodeData ( SgAsmElfRelocEntry* pointer ) 
   { 
     SgAsmElfRelocEntry* source = (SgAsmElfRelocEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_r_offset =  source->p_r_offset ;
     storageOf_r_addend =  source->p_r_addend ;
     storageOf_sym =  source->p_sym ;
     storageOf_type =  source->p_type ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfRelocEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfRelocEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72010 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72023 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocEntryListStorageClass::pickOutIRNodeData ( SgAsmElfRelocEntryList* pointer ) 
   { 
     SgAsmElfRelocEntryList* source = (SgAsmElfRelocEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfRelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfRelocEntryPtrList::value_type *  tempListentries = new SgAsmElfRelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfRelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfRelocEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfRelocEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfRelocEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfRelocEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72089 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72102 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmElfSectionTableEntry* pointer ) 
   { 
     SgAsmElfSectionTableEntry* source = (SgAsmElfSectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_sh_name =  source->p_sh_name ;
     storageOf_sh_type =  source->p_sh_type ;
     storageOf_sh_link =  source->p_sh_link ;
     storageOf_sh_info =  source->p_sh_info ;
     storageOf_sh_flags =  source->p_sh_flags ;
     storageOf_sh_addr =  source->p_sh_addr ;
     storageOf_sh_offset =  source->p_sh_offset ;
     storageOf_sh_size =  source->p_sh_size ;
     storageOf_sh_addralign =  source->p_sh_addralign ;
     storageOf_sh_entsize =  source->p_sh_entsize ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfSectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72161 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72174 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableEntryStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTableEntry* pointer ) 
   { 
     SgAsmElfSegmentTableEntry* source = (SgAsmElfSegmentTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_index =  source->p_index ;
     storageOf_type =  source->p_type ;
     storageOf_flags =  source->p_flags ;
     storageOf_offset =  source->p_offset ;
     storageOf_vaddr =  source->p_vaddr ;
     storageOf_paddr =  source->p_paddr ;
     storageOf_filesz =  source->p_filesz ;
     storageOf_memsz =  source->p_memsz ;
     storageOf_align =  source->p_align ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72232 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72245 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTableEntryList* pointer ) 
   { 
     SgAsmElfSegmentTableEntryList* source = (SgAsmElfSegmentTableEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfSegmentTableEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSegmentTableEntryPtrList::value_type *  tempListentries = new SgAsmElfSegmentTableEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSegmentTableEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSegmentTableEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72311 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72324 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolListStorageClass::pickOutIRNodeData ( SgAsmElfSymbolList* pointer ) 
   { 
     SgAsmElfSymbolList* source = (SgAsmElfSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmElfSymbolPtrList::value_type *  tempListsymbols = new SgAsmElfSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmElfSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymbolPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymbolPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymbolPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72390 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedAuxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72403 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedAuxStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedAux* pointer ) 
   { 
     SgAsmElfSymverDefinedAux* source = (SgAsmElfSymverDefinedAux*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72426 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedAuxListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72439 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedAuxListStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedAuxList* pointer ) 
   { 
     SgAsmElfSymverDefinedAuxList* source = (SgAsmElfSymverDefinedAuxList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfSymverDefinedAuxPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverDefinedAuxPtrList::value_type *  tempListentries = new SgAsmElfSymverDefinedAuxPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverDefinedAuxPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedAuxListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedAuxListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverDefinedAuxPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72505 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72518 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedEntry* pointer ) 
   { 
     SgAsmElfSymverDefinedEntry* source = (SgAsmElfSymverDefinedEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_flags =  source->p_flags ;
     storageOf_index =  source->p_index ;
     storageOf_hash =  source->p_hash ;
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72545 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72558 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedEntryList* pointer ) 
   { 
     SgAsmElfSymverDefinedEntryList* source = (SgAsmElfSymverDefinedEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfSymverDefinedEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverDefinedEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverDefinedEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverDefinedEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverDefinedEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72624 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72637 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverEntry* pointer ) 
   { 
     SgAsmElfSymverEntry* source = (SgAsmElfSymverEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_value =  source->p_value ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72660 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72673 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverEntryList* pointer ) 
   { 
     SgAsmElfSymverEntryList* source = (SgAsmElfSymverEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfSymverEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfSymverEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72739 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededAuxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72752 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededAuxStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededAux* pointer ) 
   { 
     SgAsmElfSymverNeededAux* source = (SgAsmElfSymverNeededAux*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_hash =  source->p_hash ;
     storageOf_flags =  source->p_flags ;
     storageOf_other =  source->p_other ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72778 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededAuxListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72791 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededAuxListStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededAuxList* pointer ) 
   { 
     SgAsmElfSymverNeededAuxList* source = (SgAsmElfSymverNeededAuxList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfSymverNeededAuxPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverNeededAuxPtrList::value_type *  tempListentries = new SgAsmElfSymverNeededAuxPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverNeededAuxPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededAuxListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededAuxListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverNeededAuxPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72857 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72870 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededEntryStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededEntry* pointer ) 
   { 
     SgAsmElfSymverNeededEntry* source = (SgAsmElfSymverNeededEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_version =  source->p_version ;
     storageOf_fileName = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_fileName );
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72895 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72908 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededEntryListStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededEntryList* pointer ) 
   { 
     SgAsmElfSymverNeededEntryList* source = (SgAsmElfSymverNeededEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmElfSymverNeededEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmElfSymverNeededEntryPtrList::value_type *  tempListentries = new SgAsmElfSymverNeededEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmElfSymverNeededEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmElfSymverNeededEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 72974 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericDLLStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 72987 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericDLLStorageClass::pickOutIRNodeData ( SgAsmGenericDLL* pointer ) 
   { 
     SgAsmGenericDLL* source = (SgAsmGenericDLL*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericDLLStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericDLLStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
   }

void
SgAsmGenericDLLStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
   }


void
SgAsmGenericDLLStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73037 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericDLLListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73050 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericDLLListStorageClass::pickOutIRNodeData ( SgAsmGenericDLLList* pointer ) 
   { 
     SgAsmGenericDLLList* source = (SgAsmGenericDLLList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmGenericDLLPtrList::iterator i_dlls = source->p_dlls.begin() ; 
     unsigned int tempListCountdlls = 0; 
     SgAsmGenericDLLPtrList::value_type *  tempListdlls = new SgAsmGenericDLLPtrList::value_type[ source->p_dlls.size() ]; 
     for ( ; i_dlls != source->p_dlls.end(); ++i_dlls ) 
        {
          tempListdlls[tempListCountdlls] = *i_dlls;
          tempListCountdlls++; 
          (*i_dlls) = (SgAsmGenericDLLPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dlls ) );
        }
     storageOf_dlls.storeDataInEasyStorageClass(source->p_dlls);
     tempListCountdlls = 0; 
     i_dlls = source->p_dlls.begin() ; 
     for ( ; i_dlls != source->p_dlls.end(); ++i_dlls ) 
        {
          *i_dlls = tempListdlls[tempListCountdlls] ;
          tempListCountdlls++; 
        }
      delete [] tempListdlls; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericDLLListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericDLLPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericDLLListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericDLLPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmGenericDLLListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericDLLPtrList > :: writeToFile(out) ;
   }


void
SgAsmGenericDLLListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericDLLPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73116 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73129 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFileStorageClass::pickOutIRNodeData ( SgAsmGenericFile* pointer ) 
   { 
     SgAsmGenericFile* source = (SgAsmGenericFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_dwarfInfo = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dwarfInfo );
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_fd =  source->p_fd ;
     storageOf_sb =  source->p_sb ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_headers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headers );
     storageOf_holes = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_holes );
     storageOf_truncateZeros =  source->p_truncateZeros ;
     storageOf_trackingReferences =  source->p_trackingReferences ;
     storageOf_referencedExtents.storeDataInEasyStorageClass(source->p_referencedExtents);
     storageOf_neuter =  source->p_neuter ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericFileStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFileStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFileStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: writeToFile(out) ;
   }


void
SgAsmGenericFileStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73196 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFormatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73209 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFormatStorageClass::pickOutIRNodeData ( SgAsmGenericFormat* pointer ) 
   { 
     SgAsmGenericFormat* source = (SgAsmGenericFormat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_family =  source->p_family ;
     storageOf_purpose =  source->p_purpose ;
     storageOf_sex =  source->p_sex ;
     storageOf_version =  source->p_version ;
     storageOf_isCurrentVersion =  source->p_isCurrentVersion ;
     storageOf_abi =  source->p_abi ;
     storageOf_abiVersion =  source->p_abiVersion ;
     storageOf_wordSize =  source->p_wordSize ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73239 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericHeaderListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73252 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericHeaderListStorageClass::pickOutIRNodeData ( SgAsmGenericHeaderList* pointer ) 
   { 
     SgAsmGenericHeaderList* source = (SgAsmGenericHeaderList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmGenericHeaderPtrList::iterator i_headers = source->p_headers.begin() ; 
     unsigned int tempListCountheaders = 0; 
     SgAsmGenericHeaderPtrList::value_type *  tempListheaders = new SgAsmGenericHeaderPtrList::value_type[ source->p_headers.size() ]; 
     for ( ; i_headers != source->p_headers.end(); ++i_headers ) 
        {
          tempListheaders[tempListCountheaders] = *i_headers;
          tempListCountheaders++; 
          (*i_headers) = (SgAsmGenericHeaderPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_headers ) );
        }
     storageOf_headers.storeDataInEasyStorageClass(source->p_headers);
     tempListCountheaders = 0; 
     i_headers = source->p_headers.begin() ; 
     for ( ; i_headers != source->p_headers.end(); ++i_headers ) 
        {
          *i_headers = tempListheaders[tempListCountheaders] ;
          tempListCountheaders++; 
        }
      delete [] tempListheaders; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericHeaderListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericHeaderListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmGenericHeaderListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericHeaderPtrList > :: writeToFile(out) ;
   }


void
SgAsmGenericHeaderListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericHeaderPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73318 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73331 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSectionStorageClass::pickOutIRNodeData ( SgAsmGenericSection* pointer ) 
   { 
     SgAsmGenericSection* source = (SgAsmGenericSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmGenericSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73402 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCliHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73415 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCliHeaderStorageClass::pickOutIRNodeData ( SgAsmCliHeader* pointer ) 
   { 
     SgAsmCliHeader* source = (SgAsmCliHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_cb =  source->p_cb ;
     storageOf_majorRuntimeVersion =  source->p_majorRuntimeVersion ;
     storageOf_minorRuntimeVersion =  source->p_minorRuntimeVersion ;
     storageOf_metaData =  source->p_metaData ;
     storageOf_flags =  source->p_flags ;
     storageOf_entryPointToken =  source->p_entryPointToken ;
     storageOf_resources =  source->p_resources ;
     storageOf_strongNameSignature =  source->p_strongNameSignature ;
     storageOf_codeManagerTable =  source->p_codeManagerTable ;
     storageOf_vTableFixups =  source->p_vTableFixups ;
     storageOf_exportAddressTableJumps =  source->p_exportAddressTableJumps ;
     storageOf_managedNativeHeader =  source->p_managedNativeHeader ;
     storageOf_metadataRoot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_metadataRoot );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCliHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCliHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCliHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCliHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73499 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73512 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolTableStorageClass::pickOutIRNodeData ( SgAsmCoffSymbolTable* pointer ) 
   { 
     SgAsmCoffSymbolTable* source = (SgAsmCoffSymbolTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_symbols = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbols );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCoffSymbolTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73585 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDOSExtendedHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73598 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDOSExtendedHeaderStorageClass::pickOutIRNodeData ( SgAsmDOSExtendedHeader* pointer ) 
   { 
     SgAsmDOSExtendedHeader* source = (SgAsmDOSExtendedHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_e_oemid =  source->p_e_oemid ;
     storageOf_e_oeminfo =  source->p_e_oeminfo ;
     storageOf_e_res2 =  source->p_e_res2 ;
     storageOf_e_res3 =  source->p_e_res3 ;
     storageOf_e_res4 =  source->p_e_res4 ;
     storageOf_e_res5 =  source->p_e_res5 ;
     storageOf_e_res6 =  source->p_e_res6 ;
     storageOf_e_lfanew =  source->p_e_lfanew ;
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDOSExtendedHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDOSExtendedHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73678 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73691 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionStorageClass::pickOutIRNodeData ( SgAsmElfSection* pointer ) 
   { 
     SgAsmElfSection* source = (SgAsmElfSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73765 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfDynamicSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73778 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfDynamicSectionStorageClass::pickOutIRNodeData ( SgAsmElfDynamicSection* pointer ) 
   { 
     SgAsmElfDynamicSection* source = (SgAsmElfDynamicSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfDynamicSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfDynamicSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfDynamicSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfDynamicSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73853 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfEHFrameSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73866 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfEHFrameSectionStorageClass::pickOutIRNodeData ( SgAsmElfEHFrameSection* pointer ) 
   { 
     SgAsmElfEHFrameSection* source = (SgAsmElfEHFrameSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_ci_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_ci_entries );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfEHFrameSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfEHFrameSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfEHFrameSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfEHFrameSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 73941 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfNoteSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 73954 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfNoteSectionStorageClass::pickOutIRNodeData ( SgAsmElfNoteSection* pointer ) 
   { 
     SgAsmElfNoteSection* source = (SgAsmElfNoteSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfNoteSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfNoteSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfNoteSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfNoteSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74029 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfRelocSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74042 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfRelocSectionStorageClass::pickOutIRNodeData ( SgAsmElfRelocSection* pointer ) 
   { 
     SgAsmElfRelocSection* source = (SgAsmElfRelocSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_usesAddend =  source->p_usesAddend ;
     storageOf_targetSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_targetSection );
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfRelocSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfRelocSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfRelocSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfRelocSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74119 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfStringSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74132 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfStringSectionStorageClass::pickOutIRNodeData ( SgAsmElfStringSection* pointer ) 
   { 
     SgAsmElfStringSection* source = (SgAsmElfStringSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfStringSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfStringSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfStringSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfStringSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74207 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74220 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymbolSection* pointer ) 
   { 
     SgAsmElfSymbolSection* source = (SgAsmElfSymbolSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isDynamic =  source->p_isDynamic ;
     storageOf_symbols = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbols );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymbolSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74296 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverDefinedSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74309 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverDefinedSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverDefinedSection* pointer ) 
   { 
     SgAsmElfSymverDefinedSection* source = (SgAsmElfSymverDefinedSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverDefinedSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfSymverDefinedSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74384 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverNeededSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74397 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverNeededSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverNeededSection* pointer ) 
   { 
     SgAsmElfSymverNeededSection* source = (SgAsmElfSymverNeededSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverNeededSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfSymverNeededSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74472 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymverSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74485 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymverSectionStorageClass::pickOutIRNodeData ( SgAsmElfSymverSection* pointer ) 
   { 
     SgAsmElfSymverSection* source = (SgAsmElfSymverSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_entries = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entries );
     storageOf_linkedSection = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_linkedSection );
     storageOf_sectionEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionEntry );
     storageOf_segmentEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymverSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymverSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymverSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfSymverSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74560 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74573 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSectionTableStorageClass::pickOutIRNodeData ( SgAsmElfSectionTable* pointer ) 
   { 
     SgAsmElfSectionTable* source = (SgAsmElfSectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfSectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfSectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74644 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSegmentTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74657 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSegmentTableStorageClass::pickOutIRNodeData ( SgAsmElfSegmentTable* pointer ) 
   { 
     SgAsmElfSegmentTable* source = (SgAsmElfSegmentTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSegmentTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSegmentTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfSegmentTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfSegmentTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74728 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74741 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericHeaderStorageClass::pickOutIRNodeData ( SgAsmGenericHeader* pointer ) 
   { 
     SgAsmGenericHeader* source = (SgAsmGenericHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_executableFormat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executableFormat );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_baseVa =  source->p_baseVa ;
     storageOf_entryRvas.storeDataInEasyStorageClass(source->p_entryRvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmGenericHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmGenericHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74827 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDOSFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74840 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDOSFileHeaderStorageClass::pickOutIRNodeData ( SgAsmDOSFileHeader* pointer ) 
   { 
     SgAsmDOSFileHeader* source = (SgAsmDOSFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_e_last_page_size =  source->p_e_last_page_size ;
     storageOf_e_total_pages =  source->p_e_total_pages ;
     storageOf_e_nrelocs =  source->p_e_nrelocs ;
     storageOf_e_header_paragraphs =  source->p_e_header_paragraphs ;
     storageOf_e_minalloc =  source->p_e_minalloc ;
     storageOf_e_maxalloc =  source->p_e_maxalloc ;
     storageOf_e_ss =  source->p_e_ss ;
     storageOf_e_sp =  source->p_e_sp ;
     storageOf_e_cksum =  source->p_e_cksum ;
     storageOf_e_ip =  source->p_e_ip ;
     storageOf_e_cs =  source->p_e_cs ;
     storageOf_e_overlay =  source->p_e_overlay ;
     storageOf_e_relocs_offset =  source->p_e_relocs_offset ;
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_relocs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_relocs );
     storageOf_rm_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rm_section );
     storageOf_executableFormat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executableFormat );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_baseVa =  source->p_baseVa ;
     storageOf_entryRvas.storeDataInEasyStorageClass(source->p_entryRvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDOSFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDOSFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDOSFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDOSFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 74942 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 74955 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfFileHeaderStorageClass::pickOutIRNodeData ( SgAsmElfFileHeader* pointer ) 
   { 
     SgAsmElfFileHeader* source = (SgAsmElfFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_e_ident_file_class =  source->p_e_ident_file_class ;
     storageOf_e_ident_data_encoding =  source->p_e_ident_data_encoding ;
     storageOf_e_ident_file_version =  source->p_e_ident_file_version ;
     storageOf_e_ident_padding.storeDataInEasyStorageClass(source->p_e_ident_padding);
     storageOf_e_type =  source->p_e_type ;
     storageOf_e_machine =  source->p_e_machine ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_ehsize =  source->p_e_ehsize ;
     storageOf_phextrasz =  source->p_phextrasz ;
     storageOf_e_phnum =  source->p_e_phnum ;
     storageOf_shextrasz =  source->p_shextrasz ;
     storageOf_e_shnum =  source->p_e_shnum ;
     storageOf_e_shstrndx =  source->p_e_shstrndx ;
     storageOf_sectionTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionTable );
     storageOf_segmentTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segmentTable );
     storageOf_executableFormat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executableFormat );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_baseVa =  source->p_baseVa ;
     storageOf_entryRvas.storeDataInEasyStorageClass(source->p_entryRvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmElfFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmElfFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75060 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75073 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmFileHeaderStorageClass::pickOutIRNodeData ( SgAsmJvmFileHeader* pointer ) 
   { 
     SgAsmJvmFileHeader* source = (SgAsmJvmFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_minor_version =  source->p_minor_version ;
     storageOf_major_version =  source->p_major_version ;
     storageOf_access_flags =  source->p_access_flags ;
     storageOf_this_class =  source->p_this_class ;
     storageOf_super_class =  source->p_super_class ;
     storageOf_constant_pool = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_constant_pool );
     storageOf_interfaces.storeDataInEasyStorageClass(source->p_interfaces);
     storageOf_field_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_field_table );
     storageOf_method_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_method_table );
     storageOf_attribute_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_attribute_table );
     storageOf_executableFormat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executableFormat );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_baseVa =  source->p_baseVa ;
     storageOf_entryRvas.storeDataInEasyStorageClass(source->p_entryRvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::list<uint16_t> > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::list<uint16_t> > :: deleteMemoryPool() ;
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmJvmFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::list<uint16_t> > :: writeToFile(out) ;
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmJvmFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::list<uint16_t> > :: readFromFile(in) ;
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75173 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmLEFileHeader* pointer ) 
   { 
     SgAsmLEFileHeader* source = (SgAsmLEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_e_byte_order =  source->p_e_byte_order ;
     storageOf_e_word_order =  source->p_e_word_order ;
     storageOf_e_format_level =  source->p_e_format_level ;
     storageOf_e_cpu_type =  source->p_e_cpu_type ;
     storageOf_e_os_type =  source->p_e_os_type ;
     storageOf_e_module_version =  source->p_e_module_version ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_eip_section =  source->p_e_eip_section ;
     storageOf_e_esp_section =  source->p_e_esp_section ;
     storageOf_e_last_page_size =  source->p_e_last_page_size ;
     storageOf_e_page_offset_shift =  source->p_e_page_offset_shift ;
     storageOf_e_fixup_sect_cksum =  source->p_e_fixup_sect_cksum ;
     storageOf_e_loader_sect_cksum =  source->p_e_loader_sect_cksum ;
     storageOf_e_secttab_nentries =  source->p_e_secttab_nentries ;
     storageOf_e_rsrctab_nentries =  source->p_e_rsrctab_nentries ;
     storageOf_e_fmtdirtab_nentries =  source->p_e_fmtdirtab_nentries ;
     storageOf_e_import_modtab_nentries =  source->p_e_import_modtab_nentries ;
     storageOf_e_preload_npages =  source->p_e_preload_npages ;
     storageOf_e_nonresnametab_size =  source->p_e_nonresnametab_size ;
     storageOf_e_nonresnametab_cksum =  source->p_e_nonresnametab_cksum ;
     storageOf_e_auto_ds_section =  source->p_e_auto_ds_section ;
     storageOf_e_debug_info_size =  source->p_e_debug_info_size ;
     storageOf_e_num_instance_preload =  source->p_e_num_instance_preload ;
     storageOf_e_num_instance_demand =  source->p_e_num_instance_demand ;
     storageOf_e_heap_size =  source->p_e_heap_size ;
     storageOf_e_npages =  source->p_e_npages ;
     storageOf_e_eip =  source->p_e_eip ;
     storageOf_e_esp =  source->p_e_esp ;
     storageOf_e_page_size =  source->p_e_page_size ;
     storageOf_e_fixup_sect_size =  source->p_e_fixup_sect_size ;
     storageOf_e_loader_sect_size =  source->p_e_loader_sect_size ;
     storageOf_e_secttab_rfo =  source->p_e_secttab_rfo ;
     storageOf_e_pagetab_rfo =  source->p_e_pagetab_rfo ;
     storageOf_e_iterpages_offset =  source->p_e_iterpages_offset ;
     storageOf_e_rsrctab_rfo =  source->p_e_rsrctab_rfo ;
     storageOf_e_resnametab_rfo =  source->p_e_resnametab_rfo ;
     storageOf_e_entrytab_rfo =  source->p_e_entrytab_rfo ;
     storageOf_e_fmtdirtab_rfo =  source->p_e_fmtdirtab_rfo ;
     storageOf_e_fixup_pagetab_rfo =  source->p_e_fixup_pagetab_rfo ;
     storageOf_e_fixup_rectab_rfo =  source->p_e_fixup_rectab_rfo ;
     storageOf_e_import_modtab_rfo =  source->p_e_import_modtab_rfo ;
     storageOf_e_import_proctab_rfo =  source->p_e_import_proctab_rfo ;
     storageOf_e_ppcksumtab_rfo =  source->p_e_ppcksumtab_rfo ;
     storageOf_e_data_pages_offset =  source->p_e_data_pages_offset ;
     storageOf_e_nonresnametab_offset =  source->p_e_nonresnametab_offset ;
     storageOf_e_debug_info_rfo =  source->p_e_debug_info_rfo ;
     storageOf_dos2Header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dos2Header );
     storageOf_sectionTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionTable );
     storageOf_pageTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_pageTable );
     storageOf_residentNameTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_residentNameTable );
     storageOf_nonresidentNameTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonresidentNameTable );
     storageOf_entryTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entryTable );
     storageOf_relocationTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_relocationTable );
     storageOf_executableFormat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executableFormat );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_baseVa =  source->p_baseVa ;
     storageOf_entryRvas.storeDataInEasyStorageClass(source->p_entryRvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmLEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmLEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75325 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75338 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmNEFileHeader* pointer ) 
   { 
     SgAsmNEFileHeader* source = (SgAsmNEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_e_linker_major =  source->p_e_linker_major ;
     storageOf_e_linker_minor =  source->p_e_linker_minor ;
     storageOf_e_checksum =  source->p_e_checksum ;
     storageOf_e_flags1 =  source->p_e_flags1 ;
     storageOf_e_autodata_sn =  source->p_e_autodata_sn ;
     storageOf_e_bss_size =  source->p_e_bss_size ;
     storageOf_e_stack_size =  source->p_e_stack_size ;
     storageOf_e_csip =  source->p_e_csip ;
     storageOf_e_sssp =  source->p_e_sssp ;
     storageOf_e_nsections =  source->p_e_nsections ;
     storageOf_e_nmodrefs =  source->p_e_nmodrefs ;
     storageOf_e_nnonresnames =  source->p_e_nnonresnames ;
     storageOf_e_nmovable_entries =  source->p_e_nmovable_entries ;
     storageOf_e_sector_align =  source->p_e_sector_align ;
     storageOf_e_nresources =  source->p_e_nresources ;
     storageOf_e_exetype =  source->p_e_exetype ;
     storageOf_e_flags2 =  source->p_e_flags2 ;
     storageOf_e_res1 =  source->p_e_res1 ;
     storageOf_e_winvers =  source->p_e_winvers ;
     storageOf_e_entrytab_rfo =  source->p_e_entrytab_rfo ;
     storageOf_e_entrytab_size =  source->p_e_entrytab_size ;
     storageOf_e_sectab_rfo =  source->p_e_sectab_rfo ;
     storageOf_e_rsrctab_rfo =  source->p_e_rsrctab_rfo ;
     storageOf_e_resnametab_rfo =  source->p_e_resnametab_rfo ;
     storageOf_e_modreftab_rfo =  source->p_e_modreftab_rfo ;
     storageOf_e_importnametab_rfo =  source->p_e_importnametab_rfo ;
     storageOf_e_nonresnametab_offset =  source->p_e_nonresnametab_offset ;
     storageOf_e_fastload_sector =  source->p_e_fastload_sector ;
     storageOf_e_fastload_nsectors =  source->p_e_fastload_nsectors ;
     storageOf_dos2Header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dos2Header );
     storageOf_sectionTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionTable );
     storageOf_residentNameTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_residentNameTable );
     storageOf_nonresidentNameTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_nonresidentNameTable );
     storageOf_moduleTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_moduleTable );
     storageOf_entryTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_entryTable );
     storageOf_executableFormat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executableFormat );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_baseVa =  source->p_baseVa ;
     storageOf_entryRvas.storeDataInEasyStorageClass(source->p_entryRvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75459 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEFileHeaderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75472 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEFileHeaderStorageClass::pickOutIRNodeData ( SgAsmPEFileHeader* pointer ) 
   { 
     SgAsmPEFileHeader* source = (SgAsmPEFileHeader*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_e_cpu_type =  source->p_e_cpu_type ;
     storageOf_e_nsections =  source->p_e_nsections ;
     storageOf_e_time =  source->p_e_time ;
     storageOf_e_coff_symtab =  source->p_e_coff_symtab ;
     storageOf_e_nt_hdr_size =  source->p_e_nt_hdr_size ;
     storageOf_e_coff_nsyms =  source->p_e_coff_nsyms ;
     storageOf_e_flags =  source->p_e_flags ;
     storageOf_e_opt_magic =  source->p_e_opt_magic ;
     storageOf_e_lmajor =  source->p_e_lmajor ;
     storageOf_e_lminor =  source->p_e_lminor ;
     storageOf_e_code_size =  source->p_e_code_size ;
     storageOf_e_data_size =  source->p_e_data_size ;
     storageOf_e_bss_size =  source->p_e_bss_size ;
     storageOf_e_code_rva =  source->p_e_code_rva ;
     storageOf_e_data_rva =  source->p_e_data_rva ;
     storageOf_e_section_align =  source->p_e_section_align ;
     storageOf_e_file_align =  source->p_e_file_align ;
     storageOf_e_os_major =  source->p_e_os_major ;
     storageOf_e_os_minor =  source->p_e_os_minor ;
     storageOf_e_user_major =  source->p_e_user_major ;
     storageOf_e_user_minor =  source->p_e_user_minor ;
     storageOf_e_subsys_major =  source->p_e_subsys_major ;
     storageOf_e_subsys_minor =  source->p_e_subsys_minor ;
     storageOf_e_reserved9 =  source->p_e_reserved9 ;
     storageOf_e_image_size =  source->p_e_image_size ;
     storageOf_e_header_size =  source->p_e_header_size ;
     storageOf_e_file_checksum =  source->p_e_file_checksum ;
     storageOf_e_subsystem =  source->p_e_subsystem ;
     storageOf_e_dll_flags =  source->p_e_dll_flags ;
     storageOf_e_stack_reserve_size =  source->p_e_stack_reserve_size ;
     storageOf_e_stack_commit_size =  source->p_e_stack_commit_size ;
     storageOf_e_heap_reserve_size =  source->p_e_heap_reserve_size ;
     storageOf_e_heap_commit_size =  source->p_e_heap_commit_size ;
     storageOf_e_loader_flags =  source->p_e_loader_flags ;
     storageOf_e_num_rvasize_pairs =  source->p_e_num_rvasize_pairs ;
     storageOf_rvaSizePairs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rvaSizePairs );
     storageOf_sectionTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionTable );
     storageOf_coffSymbolTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_coffSymbolTable );
     storageOf_executableFormat = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_executableFormat );
     storageOf_magic.storeDataInEasyStorageClass(source->p_magic);
     storageOf_isa =  source->p_isa ;
     storageOf_baseVa =  source->p_baseVa ;
     storageOf_entryRvas.storeDataInEasyStorageClass(source->p_entryRvas);
     storageOf_dlls = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dlls );
     storageOf_sections = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sections );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPEFileHeaderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgRVAList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEFileHeaderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgCharList > :: deleteMemoryPool() ;
     EasyStorage < SgRVAList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPEFileHeaderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgCharList > :: writeToFile(out) ;
     EasyStorage < SgRVAList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPEFileHeaderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgCharList > :: readFromFile(in) ;
     EasyStorage < SgRVAList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75596 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmAttributeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75609 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmAttributeTableStorageClass::pickOutIRNodeData ( SgAsmJvmAttributeTable* pointer ) 
   { 
     SgAsmJvmAttributeTable* source = (SgAsmJvmAttributeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmAttributePtrList::iterator i_attributes = source->p_attributes.begin() ; 
     unsigned int tempListCountattributes = 0; 
     SgAsmJvmAttributePtrList::value_type *  tempListattributes = new SgAsmJvmAttributePtrList::value_type[ source->p_attributes.size() ]; 
     for ( ; i_attributes != source->p_attributes.end(); ++i_attributes ) 
        {
          tempListattributes[tempListCountattributes] = *i_attributes;
          tempListCountattributes++; 
          (*i_attributes) = (SgAsmJvmAttributePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_attributes ) );
        }
     storageOf_attributes.storeDataInEasyStorageClass(source->p_attributes);
     tempListCountattributes = 0; 
     i_attributes = source->p_attributes.begin() ; 
     for ( ; i_attributes != source->p_attributes.end(); ++i_attributes ) 
        {
          *i_attributes = tempListattributes[tempListCountattributes] ;
          tempListCountattributes++; 
        }
      delete [] tempListattributes; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmAttributeTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmAttributePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmAttributeTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmAttributePtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmJvmAttributeTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmAttributePtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmJvmAttributeTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmAttributePtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75702 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmConstantPoolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75715 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmConstantPoolStorageClass::pickOutIRNodeData ( SgAsmJvmConstantPool* pointer ) 
   { 
     SgAsmJvmConstantPool* source = (SgAsmJvmConstantPool*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmConstantPoolEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmJvmConstantPoolEntryPtrList::value_type *  tempListentries = new SgAsmJvmConstantPoolEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmJvmConstantPoolEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmConstantPoolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmConstantPoolEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmConstantPoolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmConstantPoolEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmJvmConstantPoolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmConstantPoolEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmJvmConstantPoolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmConstantPoolEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75808 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmFieldTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75821 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmFieldTableStorageClass::pickOutIRNodeData ( SgAsmJvmFieldTable* pointer ) 
   { 
     SgAsmJvmFieldTable* source = (SgAsmJvmFieldTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmFieldPtrList::iterator i_fields = source->p_fields.begin() ; 
     unsigned int tempListCountfields = 0; 
     SgAsmJvmFieldPtrList::value_type *  tempListfields = new SgAsmJvmFieldPtrList::value_type[ source->p_fields.size() ]; 
     for ( ; i_fields != source->p_fields.end(); ++i_fields ) 
        {
          tempListfields[tempListCountfields] = *i_fields;
          tempListCountfields++; 
          (*i_fields) = (SgAsmJvmFieldPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_fields ) );
        }
     storageOf_fields.storeDataInEasyStorageClass(source->p_fields);
     tempListCountfields = 0; 
     i_fields = source->p_fields.begin() ; 
     for ( ; i_fields != source->p_fields.end(); ++i_fields ) 
        {
          *i_fields = tempListfields[tempListCountfields] ;
          tempListCountfields++; 
        }
      delete [] tempListfields; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmFieldTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmFieldPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmFieldTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmFieldPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmJvmFieldTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmFieldPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmJvmFieldTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmFieldPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 75914 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmMethodTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 75927 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmMethodTableStorageClass::pickOutIRNodeData ( SgAsmJvmMethodTable* pointer ) 
   { 
     SgAsmJvmMethodTable* source = (SgAsmJvmMethodTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmMethodPtrList::iterator i_methods = source->p_methods.begin() ; 
     unsigned int tempListCountmethods = 0; 
     SgAsmJvmMethodPtrList::value_type *  tempListmethods = new SgAsmJvmMethodPtrList::value_type[ source->p_methods.size() ]; 
     for ( ; i_methods != source->p_methods.end(); ++i_methods ) 
        {
          tempListmethods[tempListCountmethods] = *i_methods;
          tempListCountmethods++; 
          (*i_methods) = (SgAsmJvmMethodPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_methods ) );
        }
     storageOf_methods.storeDataInEasyStorageClass(source->p_methods);
     tempListCountmethods = 0; 
     i_methods = source->p_methods.begin() ; 
     for ( ; i_methods != source->p_methods.end(); ++i_methods ) 
        {
          *i_methods = tempListmethods[tempListCountmethods] ;
          tempListCountmethods++; 
        }
      delete [] tempListmethods; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmMethodTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmMethodPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmMethodTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmMethodPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmJvmMethodTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmMethodPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmJvmMethodTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmMethodPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76020 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEEntryTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76033 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEEntryTableStorageClass::pickOutIRNodeData ( SgAsmLEEntryTable* pointer ) 
   { 
     SgAsmLEEntryTable* source = (SgAsmLEEntryTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bundle_sizes.storeDataInEasyStorageClass(source->p_bundle_sizes);
     SgAsmLEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEEntryPointPtrList::value_type *  tempListentries = new SgAsmLEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLEEntryTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgSizeTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEEntryTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgSizeTList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmLEEntryTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgSizeTList > :: writeToFile(out) ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmLEEntryTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgSizeTList > :: readFromFile(in) ;
     EasyStorage < SgAsmLEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76131 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLENameTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76144 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLENameTableStorageClass::pickOutIRNodeData ( SgAsmLENameTable* pointer ) 
   { 
     SgAsmLENameTable* source = (SgAsmLENameTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_ordinals.storeDataInEasyStorageClass(source->p_ordinals);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLENameTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLENameTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmLENameTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgUnsignedList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmLENameTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgUnsignedList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76225 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEPageTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76238 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEPageTableStorageClass::pickOutIRNodeData ( SgAsmLEPageTable* pointer ) 
   { 
     SgAsmLEPageTable* source = (SgAsmLEPageTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmLEPageTableEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEPageTableEntryPtrList::value_type *  tempListentries = new SgAsmLEPageTableEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEPageTableEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLEPageTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEPageTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmLEPageTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmLEPageTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLEPageTableEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76331 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLERelocTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76344 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLERelocTableStorageClass::pickOutIRNodeData ( SgAsmLERelocTable* pointer ) 
   { 
     SgAsmLERelocTable* source = (SgAsmLERelocTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmLERelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLERelocEntryPtrList::value_type *  tempListentries = new SgAsmLERelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLERelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLERelocTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLERelocTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmLERelocTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLERelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmLERelocTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLERelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76437 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76450 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionStorageClass::pickOutIRNodeData ( SgAsmLESection* pointer ) 
   { 
     SgAsmLESection* source = (SgAsmLESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_sectionTableEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionTableEntry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmLESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76522 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76535 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionTableStorageClass::pickOutIRNodeData ( SgAsmLESectionTable* pointer ) 
   { 
     SgAsmLESectionTable* source = (SgAsmLESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmLESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmLESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76606 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEEntryTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76619 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEEntryTableStorageClass::pickOutIRNodeData ( SgAsmNEEntryTable* pointer ) 
   { 
     SgAsmNEEntryTable* source = (SgAsmNEEntryTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bundle_sizes.storeDataInEasyStorageClass(source->p_bundle_sizes);
     SgAsmNEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmNEEntryPointPtrList::value_type *  tempListentries = new SgAsmNEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmNEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNEEntryTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgSizeTList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEEntryTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgSizeTList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNEEntryTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgSizeTList > :: writeToFile(out) ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNEEntryTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgSizeTList > :: readFromFile(in) ;
     EasyStorage < SgAsmNEEntryPointPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76717 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEModuleTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76730 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEModuleTableStorageClass::pickOutIRNodeData ( SgAsmNEModuleTable* pointer ) 
   { 
     SgAsmNEModuleTable* source = (SgAsmNEModuleTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_nameOffsets.storeDataInEasyStorageClass(source->p_nameOffsets);
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNEModuleTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAddressList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEModuleTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAddressList > :: deleteMemoryPool() ;
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNEModuleTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAddressList > :: writeToFile(out) ;
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNEModuleTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAddressList > :: readFromFile(in) ;
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76812 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNENameTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76825 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNENameTableStorageClass::pickOutIRNodeData ( SgAsmNENameTable* pointer ) 
   { 
     SgAsmNENameTable* source = (SgAsmNENameTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_names.storeDataInEasyStorageClass(source->p_names);
     storageOf_ordinals.storeDataInEasyStorageClass(source->p_ordinals);
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNENameTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgStringList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNENameTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgStringList > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNENameTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgStringList > :: writeToFile(out) ;
     EasyStorage < SgUnsignedList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNENameTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgStringList > :: readFromFile(in) ;
     EasyStorage < SgUnsignedList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 76906 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNERelocTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 76919 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNERelocTableStorageClass::pickOutIRNodeData ( SgAsmNERelocTable* pointer ) 
   { 
     SgAsmNERelocTable* source = (SgAsmNERelocTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmNERelocEntryPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmNERelocEntryPtrList::value_type *  tempListentries = new SgAsmNERelocEntryPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmNERelocEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNERelocTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNERelocTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNERelocTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmNERelocEntryPtrList > :: writeToFile(out) ;
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNERelocTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmNERelocEntryPtrList > :: readFromFile(in) ;
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77012 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77025 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionStorageClass::pickOutIRNodeData ( SgAsmNESection* pointer ) 
   { 
     SgAsmNESection* source = (SgAsmNESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_sectionTableEntry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_sectionTableEntry );
     storageOf_relocationTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_relocationTable );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77098 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77111 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionTableStorageClass::pickOutIRNodeData ( SgAsmNESectionTable* pointer ) 
   { 
     SgAsmNESectionTable* source = (SgAsmNESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_sector =  source->p_sector ;
     storageOf_physicalSize =  source->p_physicalSize ;
     storageOf_virtualSize =  source->p_virtualSize ;
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEStringTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77199 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEStringTableStorageClass::pickOutIRNodeData ( SgAsmNEStringTable* pointer ) 
   { 
     SgAsmNEStringTable* source = (SgAsmNEStringTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNEStringTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNEStringTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNEStringTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNEStringTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77270 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77283 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionStorageClass::pickOutIRNodeData ( SgAsmPESection* pointer ) 
   { 
     SgAsmPESection* source = (SgAsmPESection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPESectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPESectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77355 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77368 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportSectionStorageClass::pickOutIRNodeData ( SgAsmPEExportSection* pointer ) 
   { 
     SgAsmPEExportSection* source = (SgAsmPEExportSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_exportDirectory = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exportDirectory );
     storageOf_exports = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exports );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPEExportSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPEExportSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77442 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77455 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportSectionStorageClass::pickOutIRNodeData ( SgAsmPEImportSection* pointer ) 
   { 
     SgAsmPEImportSection* source = (SgAsmPEImportSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_importDirectories = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_importDirectories );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPEImportSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPEImportSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77528 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEStringSectionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77541 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEStringSectionStorageClass::pickOutIRNodeData ( SgAsmPEStringSection* pointer ) 
   { 
     SgAsmPEStringSection* source = (SgAsmPEStringSection*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_section_entry = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section_entry );
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPEStringSectionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEStringSectionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPEStringSectionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPEStringSectionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77614 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77627 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionTableStorageClass::pickOutIRNodeData ( SgAsmPESectionTable* pointer ) 
   { 
     SgAsmPESectionTable* source = (SgAsmPESectionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_file = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_file );
     storageOf_header = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_header );
     storageOf_size =  source->p_size ;
     storageOf_offset =  source->p_offset ;
     storageOf_fileAlignment =  source->p_fileAlignment ;
     storageOf_data.storeDataInEasyStorageClass(source->p_data);
     storageOf_purpose =  source->p_purpose ;
     storageOf_synthesized =  source->p_synthesized ;
     storageOf_id =  source->p_id ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_shortName.storeDataInEasyStorageClass(source->p_shortName);
     storageOf_mappedPreferredRva =  source->p_mappedPreferredRva ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_mappedAlignment =  source->p_mappedAlignment ;
     storageOf_mappedReadPermission =  source->p_mappedReadPermission ;
     storageOf_mappedWritePermission =  source->p_mappedWritePermission ;
     storageOf_mappedExecutePermission =  source->p_mappedExecutePermission ;
     storageOf_containsCode =  source->p_containsCode ;
     storageOf_mappedActualVa =  source->p_mappedActualVa ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPESectionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgFileContentList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgFileContentList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgFileContentList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPESectionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgFileContentList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77698 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSectionListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77711 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSectionListStorageClass::pickOutIRNodeData ( SgAsmGenericSectionList* pointer ) 
   { 
     SgAsmGenericSectionList* source = (SgAsmGenericSectionList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmGenericSectionPtrList::iterator i_sections = source->p_sections.begin() ; 
     unsigned int tempListCountsections = 0; 
     SgAsmGenericSectionPtrList::value_type *  tempListsections = new SgAsmGenericSectionPtrList::value_type[ source->p_sections.size() ]; 
     for ( ; i_sections != source->p_sections.end(); ++i_sections ) 
        {
          tempListsections[tempListCountsections] = *i_sections;
          tempListCountsections++; 
          (*i_sections) = (SgAsmGenericSectionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_sections ) );
        }
     storageOf_sections.storeDataInEasyStorageClass(source->p_sections);
     tempListCountsections = 0; 
     i_sections = source->p_sections.begin() ; 
     for ( ; i_sections != source->p_sections.end(); ++i_sections ) 
        {
          *i_sections = tempListsections[tempListCountsections] ;
          tempListCountsections++; 
        }
      delete [] tempListsections; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericSectionListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericSectionPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSectionListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericSectionPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSectionListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericSectionPtrList > :: writeToFile(out) ;
   }


void
SgAsmGenericSectionListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericSectionPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77777 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77790 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericStringStorageClass::pickOutIRNodeData ( SgAsmGenericString* pointer ) 
   { 
     SgAsmGenericString* source = (SgAsmGenericString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77812 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBasicStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77825 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBasicStringStorageClass::pickOutIRNodeData ( SgAsmBasicString* pointer ) 
   { 
     SgAsmBasicString* source = (SgAsmBasicString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_string.storeDataInEasyStorageClass(source->p_string);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBasicStringStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBasicStringStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBasicStringStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBasicStringStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77874 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStoredStringStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77887 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStoredStringStorageClass::pickOutIRNodeData ( SgAsmStoredString* pointer ) 
   { 
     SgAsmStoredString* source = (SgAsmStoredString*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_storage = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_storage );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77910 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 77923 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericStrtabStorageClass::pickOutIRNodeData ( SgAsmGenericStrtab* pointer ) 
   { 
     SgAsmGenericStrtab* source = (SgAsmGenericStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storageList = source->p_storageList.begin() ; 
     unsigned int tempListCountstorageList = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorageList = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storageList.size() ]; 
     for ( ; i_storageList != source->p_storageList.end(); ++i_storageList ) 
        {
          tempListstorageList[tempListCountstorageList] = *i_storageList;
          tempListCountstorageList++; 
          (*i_storageList) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storageList ) );
        }
     storageOf_storageList.storeDataInEasyStorageClass(source->p_storageList);
     tempListCountstorageList = 0; 
     i_storageList = source->p_storageList.begin() ; 
     for ( ; i_storageList != source->p_storageList.end(); ++i_storageList ) 
        {
          *i_storageList = tempListstorageList[tempListCountstorageList] ;
          tempListCountstorageList++; 
        }
      delete [] tempListstorageList; 
     storageOf_freeList.storeDataInEasyStorageClass(source->p_freeList);
     storageOf_dontFree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dontFree );
     storageOf_numberFreed =  source->p_numberFreed ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: deleteMemoryPool() ;
   }

void
SgAsmGenericStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: writeToFile(out) ;
   }


void
SgAsmGenericStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 77997 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78010 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffStrtabStorageClass::pickOutIRNodeData ( SgAsmCoffStrtab* pointer ) 
   { 
     SgAsmCoffStrtab* source = (SgAsmCoffStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storageList = source->p_storageList.begin() ; 
     unsigned int tempListCountstorageList = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorageList = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storageList.size() ]; 
     for ( ; i_storageList != source->p_storageList.end(); ++i_storageList ) 
        {
          tempListstorageList[tempListCountstorageList] = *i_storageList;
          tempListCountstorageList++; 
          (*i_storageList) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storageList ) );
        }
     storageOf_storageList.storeDataInEasyStorageClass(source->p_storageList);
     tempListCountstorageList = 0; 
     i_storageList = source->p_storageList.begin() ; 
     for ( ; i_storageList != source->p_storageList.end(); ++i_storageList ) 
        {
          *i_storageList = tempListstorageList[tempListCountstorageList] ;
          tempListCountstorageList++; 
        }
      delete [] tempListstorageList; 
     storageOf_freeList.storeDataInEasyStorageClass(source->p_freeList);
     storageOf_dontFree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dontFree );
     storageOf_numberFreed =  source->p_numberFreed ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCoffStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: deleteMemoryPool() ;
   }

void
SgAsmCoffStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: writeToFile(out) ;
   }


void
SgAsmCoffStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78084 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfStrtabStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78097 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfStrtabStorageClass::pickOutIRNodeData ( SgAsmElfStrtab* pointer ) 
   { 
     SgAsmElfStrtab* source = (SgAsmElfStrtab*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_container = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_container );
     SgAsmGenericStrtab::referenced_t::iterator i_storageList = source->p_storageList.begin() ; 
     unsigned int tempListCountstorageList = 0; 
     SgAsmGenericStrtab::referenced_t::value_type *  tempListstorageList = new SgAsmGenericStrtab::referenced_t::value_type[ source->p_storageList.size() ]; 
     for ( ; i_storageList != source->p_storageList.end(); ++i_storageList ) 
        {
          tempListstorageList[tempListCountstorageList] = *i_storageList;
          tempListCountstorageList++; 
          (*i_storageList) = (SgAsmGenericStrtab::referenced_t::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_storageList ) );
        }
     storageOf_storageList.storeDataInEasyStorageClass(source->p_storageList);
     tempListCountstorageList = 0; 
     i_storageList = source->p_storageList.begin() ; 
     for ( ; i_storageList != source->p_storageList.end(); ++i_storageList ) 
        {
          *i_storageList = tempListstorageList[tempListCountstorageList] ;
          tempListCountstorageList++; 
        }
      delete [] tempListstorageList; 
     storageOf_freeList.storeDataInEasyStorageClass(source->p_freeList);
     storageOf_dontFree = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dontFree );
     storageOf_numberFreed =  source->p_numberFreed ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfStrtabStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfStrtabStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: deleteMemoryPool() ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: deleteMemoryPool() ;
   }

void
SgAsmElfStrtabStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: writeToFile(out) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: writeToFile(out) ;
   }


void
SgAsmElfStrtabStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericStrtab::referenced_t > :: readFromFile(in) ;
     EasyStorage < Rose::BinaryAnalysis::AddressIntervalSet > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78171 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78184 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSymbolStorageClass::pickOutIRNodeData ( SgAsmGenericSymbol* pointer ) 
   { 
     SgAsmGenericSymbol* source = (SgAsmGenericSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_definitionState =  source->p_definitionState ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78213 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCoffSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78226 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCoffSymbolStorageClass::pickOutIRNodeData ( SgAsmCoffSymbol* pointer ) 
   { 
     SgAsmCoffSymbol* source = (SgAsmCoffSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_st_name.storeDataInEasyStorageClass(source->p_st_name);
     storageOf_st_name_offset =  source->p_st_name_offset ;
     storageOf_st_section_num =  source->p_st_section_num ;
     storageOf_st_type =  source->p_st_type ;
     storageOf_st_storage_class =  source->p_st_storage_class ;
     storageOf_st_num_aux_entries =  source->p_st_num_aux_entries ;
     storageOf_auxiliaryData.storeDataInEasyStorageClass(source->p_auxiliaryData);
     storageOf_definitionState =  source->p_definitionState ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCoffSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCoffSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmCoffSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmCoffSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78292 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmElfSymbolStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78305 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmElfSymbolStorageClass::pickOutIRNodeData ( SgAsmElfSymbol* pointer ) 
   { 
     SgAsmElfSymbol* source = (SgAsmElfSymbol*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_st_info =  source->p_st_info ;
     storageOf_st_res1 =  source->p_st_res1 ;
     storageOf_st_shndx =  source->p_st_shndx ;
     storageOf_st_size =  source->p_st_size ;
     storageOf_extra.storeDataInEasyStorageClass(source->p_extra);
     storageOf_definitionState =  source->p_definitionState ;
     storageOf_binding =  source->p_binding ;
     storageOf_type =  source->p_type ;
     storageOf_value =  source->p_value ;
     storageOf_size =  source->p_size ;
     storageOf_bound = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_bound );
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmElfSymbolStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmElfSymbolStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
   }

void
SgAsmElfSymbolStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
   }


void
SgAsmElfSymbolStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78365 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericSymbolListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78378 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericSymbolListStorageClass::pickOutIRNodeData ( SgAsmGenericSymbolList* pointer ) 
   { 
     SgAsmGenericSymbolList* source = (SgAsmGenericSymbolList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmGenericSymbolPtrList::iterator i_symbols = source->p_symbols.begin() ; 
     unsigned int tempListCountsymbols = 0; 
     SgAsmGenericSymbolPtrList::value_type *  tempListsymbols = new SgAsmGenericSymbolPtrList::value_type[ source->p_symbols.size() ]; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          tempListsymbols[tempListCountsymbols] = *i_symbols;
          tempListCountsymbols++; 
          (*i_symbols) = (SgAsmGenericSymbolPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_symbols ) );
        }
     storageOf_symbols.storeDataInEasyStorageClass(source->p_symbols);
     tempListCountsymbols = 0; 
     i_symbols = source->p_symbols.begin() ; 
     for ( ; i_symbols != source->p_symbols.end(); ++i_symbols ) 
        {
          *i_symbols = tempListsymbols[tempListCountsymbols] ;
          tempListCountsymbols++; 
        }
      delete [] tempListsymbols; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericSymbolListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericSymbolListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmGenericSymbolListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericSymbolPtrList > :: writeToFile(out) ;
   }


void
SgAsmGenericSymbolListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericSymbolPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78444 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78457 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEEntryPointStorageClass::pickOutIRNodeData ( SgAsmLEEntryPoint* pointer ) 
   { 
     SgAsmLEEntryPoint* source = (SgAsmLEEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmLEEntryPointPtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmLEEntryPointPtrList::value_type *  tempListentries = new SgAsmLEEntryPointPtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmLEEntryPointPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_flags =  source->p_flags ;
     storageOf_objnum =  source->p_objnum ;
     storageOf_entry_type =  source->p_entry_type ;
     storageOf_res1 =  source->p_res1 ;
     storageOf_entry_offset =  source->p_entry_offset ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmLEEntryPointStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmLEEntryPointStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmLEEntryPointStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmLEEntryPointPtrList > :: writeToFile(out) ;
   }


void
SgAsmLEEntryPointStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmLEEntryPointPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78528 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLEPageTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78541 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLEPageTableEntryStorageClass::pickOutIRNodeData ( SgAsmLEPageTableEntry* pointer ) 
   { 
     SgAsmLEPageTableEntry* source = (SgAsmLEPageTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_pageno =  source->p_pageno ;
     storageOf_flags =  source->p_flags ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78565 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmLESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78578 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmLESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmLESectionTableEntry* pointer ) 
   { 
     SgAsmLESectionTableEntry* source = (SgAsmLESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_pageMapIndex =  source->p_pageMapIndex ;
     storageOf_pageMapNEntries =  source->p_pageMapNEntries ;
     storageOf_res1 =  source->p_res1 ;
     storageOf_mappedSize =  source->p_mappedSize ;
     storageOf_baseAddr =  source->p_baseAddr ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78606 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNEEntryPointStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78619 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNEEntryPointStorageClass::pickOutIRNodeData ( SgAsmNEEntryPoint* pointer ) 
   { 
     SgAsmNEEntryPoint* source = (SgAsmNEEntryPoint*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_int3f =  source->p_int3f ;
     storageOf_sectionIndex =  source->p_sectionIndex ;
     storageOf_sectionOffset =  source->p_sectionOffset ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78645 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNERelocEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78658 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNERelocEntryStorageClass::pickOutIRNodeData ( SgAsmNERelocEntry* pointer ) 
   { 
     SgAsmNERelocEntry* source = (SgAsmNERelocEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_src_type =  source->p_src_type ;
     storageOf_modifier =  source->p_modifier ;
     storageOf_tgt_type =  source->p_tgt_type ;
     storageOf_flags =  source->p_flags ;
     storageOf_src_offset =  source->p_src_offset ;
     storageOf_iref =  source->p_iref ;
     storageOf_iord =  source->p_iord ;
     storageOf_iname =  source->p_iname ;
     storageOf_osfixup =  source->p_osfixup ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78689 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78702 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmNESectionTableEntry* pointer ) 
   { 
     SgAsmNESectionTableEntry* source = (SgAsmNESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_flags =  source->p_flags ;
     storageOf_sector =  source->p_sector ;
     storageOf_physicalSize =  source->p_physicalSize ;
     storageOf_virtualSize =  source->p_virtualSize ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78728 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78741 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportDirectoryStorageClass::pickOutIRNodeData ( SgAsmPEExportDirectory* pointer ) 
   { 
     SgAsmPEExportDirectory* source = (SgAsmPEExportDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_res1 =  source->p_res1 ;
     storageOf_timestamp =  source->p_timestamp ;
     storageOf_vmajor =  source->p_vmajor ;
     storageOf_vminor =  source->p_vminor ;
     storageOf_name_rva =  source->p_name_rva ;
     storageOf_ord_base =  source->p_ord_base ;
     storageOf_expaddr_n =  source->p_expaddr_n ;
     storageOf_nameptr_n =  source->p_nameptr_n ;
     storageOf_expaddr_rva =  source->p_expaddr_rva ;
     storageOf_nameptr_rva =  source->p_nameptr_rva ;
     storageOf_ordinals_rva =  source->p_ordinals_rva ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78775 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78788 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportEntryStorageClass::pickOutIRNodeData ( SgAsmPEExportEntry* pointer ) 
   { 
     SgAsmPEExportEntry* source = (SgAsmPEExportEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_ordinal =  source->p_ordinal ;
     storageOf_exportRva =  source->p_exportRva ;
     storageOf_forwarder = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_forwarder );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78814 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEExportEntryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78827 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEExportEntryListStorageClass::pickOutIRNodeData ( SgAsmPEExportEntryList* pointer ) 
   { 
     SgAsmPEExportEntryList* source = (SgAsmPEExportEntryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmPEExportEntryPtrList::iterator i_exports = source->p_exports.begin() ; 
     unsigned int tempListCountexports = 0; 
     SgAsmPEExportEntryPtrList::value_type *  tempListexports = new SgAsmPEExportEntryPtrList::value_type[ source->p_exports.size() ]; 
     for ( ; i_exports != source->p_exports.end(); ++i_exports ) 
        {
          tempListexports[tempListCountexports] = *i_exports;
          tempListCountexports++; 
          (*i_exports) = (SgAsmPEExportEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_exports ) );
        }
     storageOf_exports.storeDataInEasyStorageClass(source->p_exports);
     tempListCountexports = 0; 
     i_exports = source->p_exports.begin() ; 
     for ( ; i_exports != source->p_exports.end(); ++i_exports ) 
        {
          *i_exports = tempListexports[tempListCountexports] ;
          tempListCountexports++; 
        }
      delete [] tempListexports; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPEExportEntryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEExportEntryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmPEExportEntryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEExportEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmPEExportEntryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEExportEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78893 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportDirectoryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78906 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportDirectoryStorageClass::pickOutIRNodeData ( SgAsmPEImportDirectory* pointer ) 
   { 
     SgAsmPEImportDirectory* source = (SgAsmPEImportDirectory*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_dllName = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_dllName );
     storageOf_dllNameRva =  source->p_dllNameRva ;
     storageOf_dll_name_nalloc =  source->p_dll_name_nalloc ;
     storageOf_time =  source->p_time ;
     storageOf_forwarder_chain =  source->p_forwarder_chain ;
     storageOf_ilt_rva =  source->p_ilt_rva ;
     storageOf_ilt_nalloc =  source->p_ilt_nalloc ;
     storageOf_iat_rva =  source->p_iat_rva ;
     storageOf_iat_nalloc =  source->p_iat_nalloc ;
     storageOf_imports = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_imports );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 78938 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportDirectoryListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 78951 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportDirectoryListStorageClass::pickOutIRNodeData ( SgAsmPEImportDirectoryList* pointer ) 
   { 
     SgAsmPEImportDirectoryList* source = (SgAsmPEImportDirectoryList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmPEImportDirectoryPtrList::iterator i_vector = source->p_vector.begin() ; 
     unsigned int tempListCountvector = 0; 
     SgAsmPEImportDirectoryPtrList::value_type *  tempListvector = new SgAsmPEImportDirectoryPtrList::value_type[ source->p_vector.size() ]; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          tempListvector[tempListCountvector] = *i_vector;
          tempListCountvector++; 
          (*i_vector) = (SgAsmPEImportDirectoryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_vector ) );
        }
     storageOf_vector.storeDataInEasyStorageClass(source->p_vector);
     tempListCountvector = 0; 
     i_vector = source->p_vector.begin() ; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          *i_vector = tempListvector[tempListCountvector] ;
          tempListCountvector++; 
        }
      delete [] tempListvector; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPEImportDirectoryListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportDirectoryListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportDirectoryListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: writeToFile(out) ;
   }


void
SgAsmPEImportDirectoryListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEImportDirectoryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79017 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportItemStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79030 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportItemStorageClass::pickOutIRNodeData ( SgAsmPEImportItem* pointer ) 
   { 
     SgAsmPEImportItem* source = (SgAsmPEImportItem*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_by_ordinal =  source->p_by_ordinal ;
     storageOf_ordinal =  source->p_ordinal ;
     storageOf_hint =  source->p_hint ;
     storageOf_name = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_name );
     storageOf_hintname_rva =  source->p_hintname_rva ;
     storageOf_hintname_nalloc =  source->p_hintname_nalloc ;
     storageOf_bound_rva =  source->p_bound_rva ;
     storageOf_iat_written =  source->p_iat_written ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79060 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPEImportItemListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79073 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPEImportItemListStorageClass::pickOutIRNodeData ( SgAsmPEImportItemList* pointer ) 
   { 
     SgAsmPEImportItemList* source = (SgAsmPEImportItemList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmPEImportItemPtrList::iterator i_vector = source->p_vector.begin() ; 
     unsigned int tempListCountvector = 0; 
     SgAsmPEImportItemPtrList::value_type *  tempListvector = new SgAsmPEImportItemPtrList::value_type[ source->p_vector.size() ]; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          tempListvector[tempListCountvector] = *i_vector;
          tempListCountvector++; 
          (*i_vector) = (SgAsmPEImportItemPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_vector ) );
        }
     storageOf_vector.storeDataInEasyStorageClass(source->p_vector);
     tempListCountvector = 0; 
     i_vector = source->p_vector.begin() ; 
     for ( ; i_vector != source->p_vector.end(); ++i_vector ) 
        {
          *i_vector = tempListvector[tempListCountvector] ;
          tempListCountvector++; 
        }
      delete [] tempListvector; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPEImportItemListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPEImportItemPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPEImportItemListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPEImportItemPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmPEImportItemListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPEImportItemPtrList > :: writeToFile(out) ;
   }


void
SgAsmPEImportItemListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPEImportItemPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79139 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPERVASizePairStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79152 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPERVASizePairStorageClass::pickOutIRNodeData ( SgAsmPERVASizePair* pointer ) 
   { 
     SgAsmPERVASizePair* source = (SgAsmPERVASizePair*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_e_rva =  source->p_e_rva ;
     storageOf_e_size =  source->p_e_size ;
     storageOf_section = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_section );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79177 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPERVASizePairListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79190 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPERVASizePairListStorageClass::pickOutIRNodeData ( SgAsmPERVASizePairList* pointer ) 
   { 
     SgAsmPERVASizePairList* source = (SgAsmPERVASizePairList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmPERVASizePairPtrList::iterator i_pairs = source->p_pairs.begin() ; 
     unsigned int tempListCountpairs = 0; 
     SgAsmPERVASizePairPtrList::value_type *  tempListpairs = new SgAsmPERVASizePairPtrList::value_type[ source->p_pairs.size() ]; 
     for ( ; i_pairs != source->p_pairs.end(); ++i_pairs ) 
        {
          tempListpairs[tempListCountpairs] = *i_pairs;
          tempListCountpairs++; 
          (*i_pairs) = (SgAsmPERVASizePairPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_pairs ) );
        }
     storageOf_pairs.storeDataInEasyStorageClass(source->p_pairs);
     tempListCountpairs = 0; 
     i_pairs = source->p_pairs.begin() ; 
     for ( ; i_pairs != source->p_pairs.end(); ++i_pairs ) 
        {
          *i_pairs = tempListpairs[tempListCountpairs] ;
          tempListCountpairs++; 
        }
      delete [] tempListpairs; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPERVASizePairListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPERVASizePairListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmPERVASizePairListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmPERVASizePairPtrList > :: writeToFile(out) ;
   }


void
SgAsmPERVASizePairListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmPERVASizePairPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79256 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPESectionTableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79269 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPESectionTableEntryStorageClass::pickOutIRNodeData ( SgAsmPESectionTableEntry* pointer ) 
   { 
     SgAsmPESectionTableEntry* source = (SgAsmPESectionTableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_virtual_size =  source->p_virtual_size ;
     storageOf_rva =  source->p_rva ;
     storageOf_physical_size =  source->p_physical_size ;
     storageOf_physical_offset =  source->p_physical_offset ;
     storageOf_coff_line_nums =  source->p_coff_line_nums ;
     storageOf_n_relocs =  source->p_n_relocs ;
     storageOf_n_coff_line_nums =  source->p_n_coff_line_nums ;
     storageOf_flags =  source->p_flags ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPESectionTableEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPESectionTableEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPESectionTableEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPESectionTableEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79326 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStringStorageStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79339 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStringStorageStorageClass::pickOutIRNodeData ( SgAsmStringStorage* pointer ) 
   { 
     SgAsmStringStorage* source = (SgAsmStringStorage*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_strtab = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_strtab );
     storageOf_string.storeDataInEasyStorageClass(source->p_string);
     storageOf_offset =  source->p_offset ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmStringStorageStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStringStorageStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmStringStorageStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmStringStorageStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79390 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79403 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExpressionStorageClass::pickOutIRNodeData ( SgAsmExpression* pointer ) 
   { 
     SgAsmExpression* source = (SgAsmExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79453 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmAarch32CoprocessorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79466 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmAarch32CoprocessorStorageClass::pickOutIRNodeData ( SgAsmAarch32Coprocessor* pointer ) 
   { 
     SgAsmAarch32Coprocessor* source = (SgAsmAarch32Coprocessor*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmAarch32CoprocessorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmAarch32CoprocessorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmAarch32CoprocessorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmAarch32CoprocessorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79516 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79529 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryExpressionStorageClass::pickOutIRNodeData ( SgAsmBinaryExpression* pointer ) 
   { 
     SgAsmBinaryExpression* source = (SgAsmBinaryExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79581 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAddStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79594 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAddStorageClass::pickOutIRNodeData ( SgAsmBinaryAdd* pointer ) 
   { 
     SgAsmBinaryAdd* source = (SgAsmBinaryAdd*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryAddStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAddStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAddStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryAddStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79646 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryAsrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79659 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryAsrStorageClass::pickOutIRNodeData ( SgAsmBinaryAsr* pointer ) 
   { 
     SgAsmBinaryAsr* source = (SgAsmBinaryAsr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryAsrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryAsrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryAsrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryAsrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79711 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryConcatStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79724 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryConcatStorageClass::pickOutIRNodeData ( SgAsmBinaryConcat* pointer ) 
   { 
     SgAsmBinaryConcat* source = (SgAsmBinaryConcat*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryConcatStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryConcatStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryConcatStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryConcatStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79776 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryDivideStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79789 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryDivideStorageClass::pickOutIRNodeData ( SgAsmBinaryDivide* pointer ) 
   { 
     SgAsmBinaryDivide* source = (SgAsmBinaryDivide*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryDivideStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryDivideStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryDivideStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryDivideStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79841 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryLslStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79854 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryLslStorageClass::pickOutIRNodeData ( SgAsmBinaryLsl* pointer ) 
   { 
     SgAsmBinaryLsl* source = (SgAsmBinaryLsl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryLslStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryLslStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryLslStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryLslStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79906 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryLsrStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79919 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryLsrStorageClass::pickOutIRNodeData ( SgAsmBinaryLsr* pointer ) 
   { 
     SgAsmBinaryLsr* source = (SgAsmBinaryLsr*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryLsrStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryLsrStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryLsrStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryLsrStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 79971 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryModStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 79984 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryModStorageClass::pickOutIRNodeData ( SgAsmBinaryMod* pointer ) 
   { 
     SgAsmBinaryMod* source = (SgAsmBinaryMod*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryModStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryModStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryModStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryModStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80036 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryMslStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80049 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryMslStorageClass::pickOutIRNodeData ( SgAsmBinaryMsl* pointer ) 
   { 
     SgAsmBinaryMsl* source = (SgAsmBinaryMsl*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryMslStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryMslStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryMslStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryMslStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80101 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryMultiplyStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80114 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryMultiplyStorageClass::pickOutIRNodeData ( SgAsmBinaryMultiply* pointer ) 
   { 
     SgAsmBinaryMultiply* source = (SgAsmBinaryMultiply*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryMultiplyStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryMultiplyStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryMultiplyStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryMultiplyStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80166 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryPostupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80179 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryPostupdateStorageClass::pickOutIRNodeData ( SgAsmBinaryPostupdate* pointer ) 
   { 
     SgAsmBinaryPostupdate* source = (SgAsmBinaryPostupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryPostupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryPostupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryPostupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryPostupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80231 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryPreupdateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80244 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryPreupdateStorageClass::pickOutIRNodeData ( SgAsmBinaryPreupdate* pointer ) 
   { 
     SgAsmBinaryPreupdate* source = (SgAsmBinaryPreupdate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryPreupdateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryPreupdateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryPreupdateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryPreupdateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80296 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinaryRorStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80309 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinaryRorStorageClass::pickOutIRNodeData ( SgAsmBinaryRor* pointer ) 
   { 
     SgAsmBinaryRor* source = (SgAsmBinaryRor*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinaryRorStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinaryRorStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinaryRorStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinaryRorStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80361 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBinarySubtractStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80374 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBinarySubtractStorageClass::pickOutIRNodeData ( SgAsmBinarySubtract* pointer ) 
   { 
     SgAsmBinarySubtract* source = (SgAsmBinarySubtract*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_lhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_lhs );
     storageOf_rhs = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_rhs );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBinarySubtractStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBinarySubtractStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBinarySubtractStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBinarySubtractStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80426 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmByteOrderStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80439 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmByteOrderStorageClass::pickOutIRNodeData ( SgAsmByteOrder* pointer ) 
   { 
     SgAsmByteOrder* source = (SgAsmByteOrder*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmByteOrderStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmByteOrderStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmByteOrderStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmByteOrderStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80489 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCommonSubExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80502 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCommonSubExpressionStorageClass::pickOutIRNodeData ( SgAsmCommonSubExpression* pointer ) 
   { 
     SgAsmCommonSubExpression* source = (SgAsmCommonSubExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_subexpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_subexpression );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCommonSubExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCommonSubExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCommonSubExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCommonSubExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80553 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmControlFlagsExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80566 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmControlFlagsExpressionStorageClass::pickOutIRNodeData ( SgAsmControlFlagsExpression* pointer ) 
   { 
     SgAsmControlFlagsExpression* source = (SgAsmControlFlagsExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bitFlags =  source->p_bitFlags ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmControlFlagsExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmControlFlagsExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmControlFlagsExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmControlFlagsExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80617 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmExprListExpStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80630 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmExprListExpStorageClass::pickOutIRNodeData ( SgAsmExprListExp* pointer ) 
   { 
     SgAsmExprListExp* source = (SgAsmExprListExp*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmExpressionPtrList::iterator i_expressions = source->p_expressions.begin() ; 
     unsigned int tempListCountexpressions = 0; 
     SgAsmExpressionPtrList::value_type *  tempListexpressions = new SgAsmExpressionPtrList::value_type[ source->p_expressions.size() ]; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          tempListexpressions[tempListCountexpressions] = *i_expressions;
          tempListCountexpressions++; 
          (*i_expressions) = (SgAsmExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_expressions ) );
        }
     storageOf_expressions.storeDataInEasyStorageClass(source->p_expressions);
     tempListCountexpressions = 0; 
     i_expressions = source->p_expressions.begin() ; 
     for ( ; i_expressions != source->p_expressions.end(); ++i_expressions ) 
        {
          *i_expressions = tempListexpressions[tempListCountexpressions] ;
          tempListCountexpressions++; 
        }
      delete [] tempListexpressions; 
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmExprListExpStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmExprListExpStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmExprListExpStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmExprListExpStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80702 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmMemoryReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80715 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmMemoryReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmMemoryReferenceExpression* pointer ) 
   { 
     SgAsmMemoryReferenceExpression* source = (SgAsmMemoryReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_address = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_address );
     storageOf_segment = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_segment );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmMemoryReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmMemoryReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80767 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmRegisterNamesStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80780 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmRegisterNamesStorageClass::pickOutIRNodeData ( SgAsmRegisterNames* pointer ) 
   { 
     SgAsmRegisterNames* source = (SgAsmRegisterNames*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmRegisterReferenceExpressionPtrList::iterator i_registers = source->p_registers.begin() ; 
     unsigned int tempListCountregisters = 0; 
     SgAsmRegisterReferenceExpressionPtrList::value_type *  tempListregisters = new SgAsmRegisterReferenceExpressionPtrList::value_type[ source->p_registers.size() ]; 
     for ( ; i_registers != source->p_registers.end(); ++i_registers ) 
        {
          tempListregisters[tempListCountregisters] = *i_registers;
          tempListCountregisters++; 
          (*i_registers) = (SgAsmRegisterReferenceExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_registers ) );
        }
     storageOf_registers.storeDataInEasyStorageClass(source->p_registers);
     tempListCountregisters = 0; 
     i_registers = source->p_registers.begin() ; 
     for ( ; i_registers != source->p_registers.end(); ++i_registers ) 
        {
          *i_registers = tempListregisters[tempListCountregisters] ;
          tempListCountregisters++; 
        }
      delete [] tempListregisters; 
     storageOf_mask =  source->p_mask ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmRegisterNamesStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmRegisterReferenceExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmRegisterNamesStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmRegisterReferenceExpressionPtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmRegisterNamesStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmRegisterReferenceExpressionPtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmRegisterNamesStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmRegisterReferenceExpressionPtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80853 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmRegisterReferenceExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80866 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmRegisterReferenceExpressionStorageClass::pickOutIRNodeData ( SgAsmRegisterReferenceExpression* pointer ) 
   { 
     SgAsmRegisterReferenceExpression* source = (SgAsmRegisterReferenceExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_adjustment =  source->p_adjustment ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmRegisterReferenceExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmRegisterReferenceExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80918 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmDirectRegisterExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80931 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmDirectRegisterExpressionStorageClass::pickOutIRNodeData ( SgAsmDirectRegisterExpression* pointer ) 
   { 
     SgAsmDirectRegisterExpression* source = (SgAsmDirectRegisterExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_adjustment =  source->p_adjustment ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmDirectRegisterExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmDirectRegisterExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmDirectRegisterExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmDirectRegisterExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 80983 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmIndirectRegisterExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 80996 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmIndirectRegisterExpressionStorageClass::pickOutIRNodeData ( SgAsmIndirectRegisterExpression* pointer ) 
   { 
     SgAsmIndirectRegisterExpression* source = (SgAsmIndirectRegisterExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_stride =  source->p_stride ;
     storageOf_offset =  source->p_offset ;
     storageOf_index =  source->p_index ;
     storageOf_modulus =  source->p_modulus ;
     storageOf_descriptor =  source->p_descriptor ;
     storageOf_adjustment =  source->p_adjustment ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmIndirectRegisterExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmIndirectRegisterExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmIndirectRegisterExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmIndirectRegisterExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81052 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmRiscOperationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81065 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmRiscOperationStorageClass::pickOutIRNodeData ( SgAsmRiscOperation* pointer ) 
   { 
     SgAsmRiscOperation* source = (SgAsmRiscOperation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_riscOperator =  source->p_riscOperator ;
     storageOf_operands = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operands );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmRiscOperationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmRiscOperationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmRiscOperationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmRiscOperationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81117 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStackExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81130 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStackExpressionStorageClass::pickOutIRNodeData ( SgAsmStackExpression* pointer ) 
   { 
     SgAsmStackExpression* source = (SgAsmStackExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_stackPosition =  source->p_stackPosition ;
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmStackExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStackExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmStackExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmStackExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81181 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81194 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryExpressionStorageClass::pickOutIRNodeData ( SgAsmUnaryExpression* pointer ) 
   { 
     SgAsmUnaryExpression* source = (SgAsmUnaryExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUnaryExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUnaryExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81245 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryMinusStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81258 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryMinusStorageClass::pickOutIRNodeData ( SgAsmUnaryMinus* pointer ) 
   { 
     SgAsmUnaryMinus* source = (SgAsmUnaryMinus*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUnaryMinusStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryMinusStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryMinusStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUnaryMinusStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81309 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryPlusStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81322 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryPlusStorageClass::pickOutIRNodeData ( SgAsmUnaryPlus* pointer ) 
   { 
     SgAsmUnaryPlus* source = (SgAsmUnaryPlus*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUnaryPlusStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryPlusStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryPlusStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUnaryPlusStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81373 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryRrxStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81386 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryRrxStorageClass::pickOutIRNodeData ( SgAsmUnaryRrx* pointer ) 
   { 
     SgAsmUnaryRrx* source = (SgAsmUnaryRrx*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUnaryRrxStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryRrxStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryRrxStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUnaryRrxStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81437 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnarySignedExtendStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81450 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnarySignedExtendStorageClass::pickOutIRNodeData ( SgAsmUnarySignedExtend* pointer ) 
   { 
     SgAsmUnarySignedExtend* source = (SgAsmUnarySignedExtend*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUnarySignedExtendStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnarySignedExtendStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUnarySignedExtendStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUnarySignedExtendStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81501 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryTruncateStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81514 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryTruncateStorageClass::pickOutIRNodeData ( SgAsmUnaryTruncate* pointer ) 
   { 
     SgAsmUnaryTruncate* source = (SgAsmUnaryTruncate*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUnaryTruncateStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryTruncateStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryTruncateStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUnaryTruncateStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81565 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUnaryUnsignedExtendStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81578 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUnaryUnsignedExtendStorageClass::pickOutIRNodeData ( SgAsmUnaryUnsignedExtend* pointer ) 
   { 
     SgAsmUnaryUnsignedExtend* source = (SgAsmUnaryUnsignedExtend*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_operand = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operand );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUnaryUnsignedExtendStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUnaryUnsignedExtendStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUnaryUnsignedExtendStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUnaryUnsignedExtendStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81629 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81642 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmValueExpressionStorageClass::pickOutIRNodeData ( SgAsmValueExpression* pointer ) 
   { 
     SgAsmValueExpression* source = (SgAsmValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_unfoldedExpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfoldedExpression );
     storageOf_bitOffset =  source->p_bitOffset ;
     storageOf_bitSize =  source->p_bitSize ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81696 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmConstantExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81709 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmConstantExpressionStorageClass::pickOutIRNodeData ( SgAsmConstantExpression* pointer ) 
   { 
     SgAsmConstantExpression* source = (SgAsmConstantExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bitVector.storeDataInEasyStorageClass(source->p_bitVector);
     storageOf_unfoldedExpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfoldedExpression );
     storageOf_bitOffset =  source->p_bitOffset ;
     storageOf_bitSize =  source->p_bitSize ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmConstantExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < Sawyer::Container::BitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmConstantExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < Sawyer::Container::BitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmConstantExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < Sawyer::Container::BitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmConstantExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < Sawyer::Container::BitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81768 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmFloatValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81781 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmFloatValueExpressionStorageClass::pickOutIRNodeData ( SgAsmFloatValueExpression* pointer ) 
   { 
     SgAsmFloatValueExpression* source = (SgAsmFloatValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bitVector.storeDataInEasyStorageClass(source->p_bitVector);
     storageOf_unfoldedExpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfoldedExpression );
     storageOf_bitOffset =  source->p_bitOffset ;
     storageOf_bitSize =  source->p_bitSize ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmFloatValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < Sawyer::Container::BitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmFloatValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < Sawyer::Container::BitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmFloatValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < Sawyer::Container::BitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmFloatValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < Sawyer::Container::BitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81840 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmIntegerValueExpressionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81853 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmIntegerValueExpressionStorageClass::pickOutIRNodeData ( SgAsmIntegerValueExpression* pointer ) 
   { 
     SgAsmIntegerValueExpression* source = (SgAsmIntegerValueExpression*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_baseNode = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_baseNode );
     storageOf_bitVector.storeDataInEasyStorageClass(source->p_bitVector);
     storageOf_unfoldedExpression = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_unfoldedExpression );
     storageOf_bitOffset =  source->p_bitOffset ;
     storageOf_bitSize =  source->p_bitSize ;
     storageOf_symbol = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbol );
     storageOf_type = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_type );
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmIntegerValueExpressionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < Sawyer::Container::BitVector > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmIntegerValueExpressionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < Sawyer::Container::BitVector > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmIntegerValueExpressionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < Sawyer::Container::BitVector > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmIntegerValueExpressionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < Sawyer::Container::BitVector > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81913 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmGenericFileListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 81926 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmGenericFileListStorageClass::pickOutIRNodeData ( SgAsmGenericFileList* pointer ) 
   { 
     SgAsmGenericFileList* source = (SgAsmGenericFileList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmGenericFilePtrList::iterator i_files = source->p_files.begin() ; 
     unsigned int tempListCountfiles = 0; 
     SgAsmGenericFilePtrList::value_type *  tempListfiles = new SgAsmGenericFilePtrList::value_type[ source->p_files.size() ]; 
     for ( ; i_files != source->p_files.end(); ++i_files ) 
        {
          tempListfiles[tempListCountfiles] = *i_files;
          tempListCountfiles++; 
          (*i_files) = (SgAsmGenericFilePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_files ) );
        }
     storageOf_files.storeDataInEasyStorageClass(source->p_files);
     tempListCountfiles = 0; 
     i_files = source->p_files.begin() ; 
     for ( ; i_files != source->p_files.end(); ++i_files ) 
        {
          *i_files = tempListfiles[tempListCountfiles] ;
          tempListCountfiles++; 
        }
      delete [] tempListfiles; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmGenericFileListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmGenericFilePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmGenericFileListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmGenericFilePtrList > :: deleteMemoryPool() ;
   }

void
SgAsmGenericFileListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmGenericFilePtrList > :: writeToFile(out) ;
   }


void
SgAsmGenericFileListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmGenericFilePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 81992 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInstructionListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82005 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInstructionListStorageClass::pickOutIRNodeData ( SgAsmInstructionList* pointer ) 
   { 
     SgAsmInstructionList* source = (SgAsmInstructionList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmInstructionPtrList::iterator i_instructions = source->p_instructions.begin() ; 
     unsigned int tempListCountinstructions = 0; 
     SgAsmInstructionPtrList::value_type *  tempListinstructions = new SgAsmInstructionPtrList::value_type[ source->p_instructions.size() ]; 
     for ( ; i_instructions != source->p_instructions.end(); ++i_instructions ) 
        {
          tempListinstructions[tempListCountinstructions] = *i_instructions;
          tempListCountinstructions++; 
          (*i_instructions) = (SgAsmInstructionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_instructions ) );
        }
     storageOf_instructions.storeDataInEasyStorageClass(source->p_instructions);
     tempListCountinstructions = 0; 
     i_instructions = source->p_instructions.begin() ; 
     for ( ; i_instructions != source->p_instructions.end(); ++i_instructions ) 
        {
          *i_instructions = tempListinstructions[tempListCountinstructions] ;
          tempListCountinstructions++; 
        }
      delete [] tempListinstructions; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmInstructionListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmInstructionPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInstructionListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmInstructionPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmInstructionListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmInstructionPtrList > :: writeToFile(out) ;
   }


void
SgAsmInstructionListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmInstructionPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82071 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInterpretationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82084 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInterpretationStorageClass::pickOutIRNodeData ( SgAsmInterpretation* pointer ) 
   { 
     SgAsmInterpretation* source = (SgAsmInterpretation*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_headers = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_headers );
     storageOf_globalBlock = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_globalBlock );
     storageOf_coverageComputed =  source->p_coverageComputed ;
     storageOf_percentageCoverage =  source->p_percentageCoverage ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82110 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInterpretationListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82123 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInterpretationListStorageClass::pickOutIRNodeData ( SgAsmInterpretationList* pointer ) 
   { 
     SgAsmInterpretationList* source = (SgAsmInterpretationList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmInterpretationPtrList::iterator i_interpretations = source->p_interpretations.begin() ; 
     unsigned int tempListCountinterpretations = 0; 
     SgAsmInterpretationPtrList::value_type *  tempListinterpretations = new SgAsmInterpretationPtrList::value_type[ source->p_interpretations.size() ]; 
     for ( ; i_interpretations != source->p_interpretations.end(); ++i_interpretations ) 
        {
          tempListinterpretations[tempListCountinterpretations] = *i_interpretations;
          tempListCountinterpretations++; 
          (*i_interpretations) = (SgAsmInterpretationPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_interpretations ) );
        }
     storageOf_interpretations.storeDataInEasyStorageClass(source->p_interpretations);
     tempListCountinterpretations = 0; 
     i_interpretations = source->p_interpretations.begin() ; 
     for ( ; i_interpretations != source->p_interpretations.end(); ++i_interpretations ) 
        {
          *i_interpretations = tempListinterpretations[tempListCountinterpretations] ;
          tempListCountinterpretations++; 
        }
      delete [] tempListinterpretations; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmInterpretationListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmInterpretationPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInterpretationListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmInterpretationPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmInterpretationListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmInterpretationPtrList > :: writeToFile(out) ;
   }


void
SgAsmInterpretationListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmInterpretationPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82189 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmNodeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82202 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmNodeStorageClass::pickOutIRNodeData ( SgAsmJvmNode* pointer ) 
   { 
     SgAsmJvmNode* source = (SgAsmJvmNode*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82224 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82237 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmAttributeStorageClass::pickOutIRNodeData ( SgAsmJvmAttribute* pointer ) 
   { 
     SgAsmJvmAttribute* source = (SgAsmJvmAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82261 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmBootstrapMethodsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82274 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmBootstrapMethodsStorageClass::pickOutIRNodeData ( SgAsmJvmBootstrapMethods* pointer ) 
   { 
     SgAsmJvmBootstrapMethods* source = (SgAsmJvmBootstrapMethods*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmBootstrapMethodPtrList::iterator i_bootstrap_methods = source->p_bootstrap_methods.begin() ; 
     unsigned int tempListCountbootstrap_methods = 0; 
     SgAsmJvmBootstrapMethodPtrList::value_type *  tempListbootstrap_methods = new SgAsmJvmBootstrapMethodPtrList::value_type[ source->p_bootstrap_methods.size() ]; 
     for ( ; i_bootstrap_methods != source->p_bootstrap_methods.end(); ++i_bootstrap_methods ) 
        {
          tempListbootstrap_methods[tempListCountbootstrap_methods] = *i_bootstrap_methods;
          tempListCountbootstrap_methods++; 
          (*i_bootstrap_methods) = (SgAsmJvmBootstrapMethodPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_bootstrap_methods ) );
        }
     storageOf_bootstrap_methods.storeDataInEasyStorageClass(source->p_bootstrap_methods);
     tempListCountbootstrap_methods = 0; 
     i_bootstrap_methods = source->p_bootstrap_methods.begin() ; 
     for ( ; i_bootstrap_methods != source->p_bootstrap_methods.end(); ++i_bootstrap_methods ) 
        {
          *i_bootstrap_methods = tempListbootstrap_methods[tempListCountbootstrap_methods] ;
          tempListCountbootstrap_methods++; 
        }
      delete [] tempListbootstrap_methods; 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmBootstrapMethodsStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmBootstrapMethodPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmBootstrapMethodsStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmBootstrapMethodPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmBootstrapMethodsStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmBootstrapMethodPtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmBootstrapMethodsStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmBootstrapMethodPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82342 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmCodeAttributeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82355 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmCodeAttributeStorageClass::pickOutIRNodeData ( SgAsmJvmCodeAttribute* pointer ) 
   { 
     SgAsmJvmCodeAttribute* source = (SgAsmJvmCodeAttribute*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_max_stack =  source->p_max_stack ;
     storageOf_max_locals =  source->p_max_locals ;
     storageOf_code_length =  source->p_code_length ;
     storageOf_code.storeDataInEasyStorageClass(source->p_code);
     storageOf_exception_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_exception_table );
     storageOf_attribute_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_attribute_table );
     storageOf_code_offset =  source->p_code_offset ;
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmCodeAttributeStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < char* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmCodeAttributeStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < char* > :: deleteMemoryPool() ;
   }

void
SgAsmJvmCodeAttributeStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < char* > :: writeToFile(out) ;
   }


void
SgAsmJvmCodeAttributeStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < char* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82412 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmConstantValueStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82425 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmConstantValueStorageClass::pickOutIRNodeData ( SgAsmJvmConstantValue* pointer ) 
   { 
     SgAsmJvmConstantValue* source = (SgAsmJvmConstantValue*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_constantvalue_index =  source->p_constantvalue_index ;
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82450 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmDeprecatedStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82463 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmDeprecatedStorageClass::pickOutIRNodeData ( SgAsmJvmDeprecated* pointer ) 
   { 
     SgAsmJvmDeprecated* source = (SgAsmJvmDeprecated*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82487 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmEnclosingMethodStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82500 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmEnclosingMethodStorageClass::pickOutIRNodeData ( SgAsmJvmEnclosingMethod* pointer ) 
   { 
     SgAsmJvmEnclosingMethod* source = (SgAsmJvmEnclosingMethod*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_class_index =  source->p_class_index ;
     storageOf_method_index =  source->p_method_index ;
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82526 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmExceptionsStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82539 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmExceptionsStorageClass::pickOutIRNodeData ( SgAsmJvmExceptions* pointer ) 
   { 
     SgAsmJvmExceptions* source = (SgAsmJvmExceptions*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_exception_index_table.storeDataInEasyStorageClass(source->p_exception_index_table);
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmExceptionsStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsigned16List > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmExceptionsStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsigned16List > :: deleteMemoryPool() ;
   }

void
SgAsmJvmExceptionsStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsigned16List > :: writeToFile(out) ;
   }


void
SgAsmJvmExceptionsStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsigned16List > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82590 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmInnerClassesStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82603 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmInnerClassesStorageClass::pickOutIRNodeData ( SgAsmJvmInnerClasses* pointer ) 
   { 
     SgAsmJvmInnerClasses* source = (SgAsmJvmInnerClasses*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmInnerClassesEntryPtrList::iterator i_classes = source->p_classes.begin() ; 
     unsigned int tempListCountclasses = 0; 
     SgAsmJvmInnerClassesEntryPtrList::value_type *  tempListclasses = new SgAsmJvmInnerClassesEntryPtrList::value_type[ source->p_classes.size() ]; 
     for ( ; i_classes != source->p_classes.end(); ++i_classes ) 
        {
          tempListclasses[tempListCountclasses] = *i_classes;
          tempListCountclasses++; 
          (*i_classes) = (SgAsmJvmInnerClassesEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_classes ) );
        }
     storageOf_classes.storeDataInEasyStorageClass(source->p_classes);
     tempListCountclasses = 0; 
     i_classes = source->p_classes.begin() ; 
     for ( ; i_classes != source->p_classes.end(); ++i_classes ) 
        {
          *i_classes = tempListclasses[tempListCountclasses] ;
          tempListCountclasses++; 
        }
      delete [] tempListclasses; 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmInnerClassesStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmInnerClassesEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmInnerClassesStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmInnerClassesEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmInnerClassesStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmInnerClassesEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmInnerClassesStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmInnerClassesEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82671 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmLineNumberTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82684 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmLineNumberTableStorageClass::pickOutIRNodeData ( SgAsmJvmLineNumberTable* pointer ) 
   { 
     SgAsmJvmLineNumberTable* source = (SgAsmJvmLineNumberTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmLineNumberEntryPtrList::iterator i_line_number_table = source->p_line_number_table.begin() ; 
     unsigned int tempListCountline_number_table = 0; 
     SgAsmJvmLineNumberEntryPtrList::value_type *  tempListline_number_table = new SgAsmJvmLineNumberEntryPtrList::value_type[ source->p_line_number_table.size() ]; 
     for ( ; i_line_number_table != source->p_line_number_table.end(); ++i_line_number_table ) 
        {
          tempListline_number_table[tempListCountline_number_table] = *i_line_number_table;
          tempListCountline_number_table++; 
          (*i_line_number_table) = (SgAsmJvmLineNumberEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_line_number_table ) );
        }
     storageOf_line_number_table.storeDataInEasyStorageClass(source->p_line_number_table);
     tempListCountline_number_table = 0; 
     i_line_number_table = source->p_line_number_table.begin() ; 
     for ( ; i_line_number_table != source->p_line_number_table.end(); ++i_line_number_table ) 
        {
          *i_line_number_table = tempListline_number_table[tempListCountline_number_table] ;
          tempListCountline_number_table++; 
        }
      delete [] tempListline_number_table; 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmLineNumberTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmLineNumberEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmLineNumberTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmLineNumberEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmLineNumberTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmLineNumberEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmLineNumberTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmLineNumberEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82752 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmLocalVariableTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82765 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmLocalVariableTableStorageClass::pickOutIRNodeData ( SgAsmJvmLocalVariableTable* pointer ) 
   { 
     SgAsmJvmLocalVariableTable* source = (SgAsmJvmLocalVariableTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmLocalVariableEntryPtrList::iterator i_local_variable_table = source->p_local_variable_table.begin() ; 
     unsigned int tempListCountlocal_variable_table = 0; 
     SgAsmJvmLocalVariableEntryPtrList::value_type *  tempListlocal_variable_table = new SgAsmJvmLocalVariableEntryPtrList::value_type[ source->p_local_variable_table.size() ]; 
     for ( ; i_local_variable_table != source->p_local_variable_table.end(); ++i_local_variable_table ) 
        {
          tempListlocal_variable_table[tempListCountlocal_variable_table] = *i_local_variable_table;
          tempListCountlocal_variable_table++; 
          (*i_local_variable_table) = (SgAsmJvmLocalVariableEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_local_variable_table ) );
        }
     storageOf_local_variable_table.storeDataInEasyStorageClass(source->p_local_variable_table);
     tempListCountlocal_variable_table = 0; 
     i_local_variable_table = source->p_local_variable_table.begin() ; 
     for ( ; i_local_variable_table != source->p_local_variable_table.end(); ++i_local_variable_table ) 
        {
          *i_local_variable_table = tempListlocal_variable_table[tempListCountlocal_variable_table] ;
          tempListCountlocal_variable_table++; 
        }
      delete [] tempListlocal_variable_table; 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmLocalVariableTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmLocalVariableEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmLocalVariableTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmLocalVariableEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmLocalVariableTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmLocalVariableEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmLocalVariableTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmLocalVariableEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82833 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmLocalVariableTypeTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82846 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmLocalVariableTypeTableStorageClass::pickOutIRNodeData ( SgAsmJvmLocalVariableTypeTable* pointer ) 
   { 
     SgAsmJvmLocalVariableTypeTable* source = (SgAsmJvmLocalVariableTypeTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmLocalVariableTypeEntryPtrList::iterator i_local_variable_type_table = source->p_local_variable_type_table.begin() ; 
     unsigned int tempListCountlocal_variable_type_table = 0; 
     SgAsmJvmLocalVariableTypeEntryPtrList::value_type *  tempListlocal_variable_type_table = new SgAsmJvmLocalVariableTypeEntryPtrList::value_type[ source->p_local_variable_type_table.size() ]; 
     for ( ; i_local_variable_type_table != source->p_local_variable_type_table.end(); ++i_local_variable_type_table ) 
        {
          tempListlocal_variable_type_table[tempListCountlocal_variable_type_table] = *i_local_variable_type_table;
          tempListCountlocal_variable_type_table++; 
          (*i_local_variable_type_table) = (SgAsmJvmLocalVariableTypeEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_local_variable_type_table ) );
        }
     storageOf_local_variable_type_table.storeDataInEasyStorageClass(source->p_local_variable_type_table);
     tempListCountlocal_variable_type_table = 0; 
     i_local_variable_type_table = source->p_local_variable_type_table.begin() ; 
     for ( ; i_local_variable_type_table != source->p_local_variable_type_table.end(); ++i_local_variable_type_table ) 
        {
          *i_local_variable_type_table = tempListlocal_variable_type_table[tempListCountlocal_variable_type_table] ;
          tempListCountlocal_variable_type_table++; 
        }
      delete [] tempListlocal_variable_type_table; 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmLocalVariableTypeTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmLocalVariableTypeEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmLocalVariableTypeTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmLocalVariableTypeEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmLocalVariableTypeTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmLocalVariableTypeEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmLocalVariableTypeTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmLocalVariableTypeEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82914 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmMethodParametersStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 82927 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmMethodParametersStorageClass::pickOutIRNodeData ( SgAsmJvmMethodParameters* pointer ) 
   { 
     SgAsmJvmMethodParameters* source = (SgAsmJvmMethodParameters*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmMethodParametersEntryPtrList::iterator i_parameters = source->p_parameters.begin() ; 
     unsigned int tempListCountparameters = 0; 
     SgAsmJvmMethodParametersEntryPtrList::value_type *  tempListparameters = new SgAsmJvmMethodParametersEntryPtrList::value_type[ source->p_parameters.size() ]; 
     for ( ; i_parameters != source->p_parameters.end(); ++i_parameters ) 
        {
          tempListparameters[tempListCountparameters] = *i_parameters;
          tempListCountparameters++; 
          (*i_parameters) = (SgAsmJvmMethodParametersEntryPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_parameters ) );
        }
     storageOf_parameters.storeDataInEasyStorageClass(source->p_parameters);
     tempListCountparameters = 0; 
     i_parameters = source->p_parameters.begin() ; 
     for ( ; i_parameters != source->p_parameters.end(); ++i_parameters ) 
        {
          *i_parameters = tempListparameters[tempListCountparameters] ;
          tempListCountparameters++; 
        }
      delete [] tempListparameters; 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmMethodParametersStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmMethodParametersEntryPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmMethodParametersStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmMethodParametersEntryPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmMethodParametersStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmMethodParametersEntryPtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmMethodParametersStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmMethodParametersEntryPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 82995 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmModuleMainClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83008 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmModuleMainClassStorageClass::pickOutIRNodeData ( SgAsmJvmModuleMainClass* pointer ) 
   { 
     SgAsmJvmModuleMainClass* source = (SgAsmJvmModuleMainClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_main_class_index =  source->p_main_class_index ;
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83033 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmNestHostStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83046 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmNestHostStorageClass::pickOutIRNodeData ( SgAsmJvmNestHost* pointer ) 
   { 
     SgAsmJvmNestHost* source = (SgAsmJvmNestHost*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_host_class_index =  source->p_host_class_index ;
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83071 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmNestMembersStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83084 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmNestMembersStorageClass::pickOutIRNodeData ( SgAsmJvmNestMembers* pointer ) 
   { 
     SgAsmJvmNestMembers* source = (SgAsmJvmNestMembers*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_classes.storeDataInEasyStorageClass(source->p_classes);
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmNestMembersStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsigned16List > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmNestMembersStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsigned16List > :: deleteMemoryPool() ;
   }

void
SgAsmJvmNestMembersStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsigned16List > :: writeToFile(out) ;
   }


void
SgAsmJvmNestMembersStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsigned16List > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83135 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmSignatureStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83148 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmSignatureStorageClass::pickOutIRNodeData ( SgAsmJvmSignature* pointer ) 
   { 
     SgAsmJvmSignature* source = (SgAsmJvmSignature*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_signature_index =  source->p_signature_index ;
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83173 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmSourceFileStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83186 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmSourceFileStorageClass::pickOutIRNodeData ( SgAsmJvmSourceFile* pointer ) 
   { 
     SgAsmJvmSourceFile* source = (SgAsmJvmSourceFile*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_sourcefile_index =  source->p_sourcefile_index ;
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83211 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmStackMapTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83224 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmStackMapTableStorageClass::pickOutIRNodeData ( SgAsmJvmStackMapTable* pointer ) 
   { 
     SgAsmJvmStackMapTable* source = (SgAsmJvmStackMapTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmStackMapFramePtrList::iterator i_entries = source->p_entries.begin() ; 
     unsigned int tempListCountentries = 0; 
     SgAsmJvmStackMapFramePtrList::value_type *  tempListentries = new SgAsmJvmStackMapFramePtrList::value_type[ source->p_entries.size() ]; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          tempListentries[tempListCountentries] = *i_entries;
          tempListCountentries++; 
          (*i_entries) = (SgAsmJvmStackMapFramePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_entries ) );
        }
     storageOf_entries.storeDataInEasyStorageClass(source->p_entries);
     tempListCountentries = 0; 
     i_entries = source->p_entries.begin() ; 
     for ( ; i_entries != source->p_entries.end(); ++i_entries ) 
        {
          *i_entries = tempListentries[tempListCountentries] ;
          tempListCountentries++; 
        }
      delete [] tempListentries; 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmStackMapTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmStackMapFramePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmStackMapTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmStackMapFramePtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmStackMapTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmStackMapFramePtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmStackMapTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmStackMapFramePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83292 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmSyntheticStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83305 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmSyntheticStorageClass::pickOutIRNodeData ( SgAsmJvmSynthetic* pointer ) 
   { 
     SgAsmJvmSynthetic* source = (SgAsmJvmSynthetic*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_attribute_name_index =  source->p_attribute_name_index ;
     storageOf_attribute_length =  source->p_attribute_length ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83329 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmBootstrapMethodStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83342 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmBootstrapMethodStorageClass::pickOutIRNodeData ( SgAsmJvmBootstrapMethod* pointer ) 
   { 
     SgAsmJvmBootstrapMethod* source = (SgAsmJvmBootstrapMethod*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_bootstrap_method_ref =  source->p_bootstrap_method_ref ;
     storageOf_bootstrap_arguments.storeDataInEasyStorageClass(source->p_bootstrap_arguments);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmBootstrapMethodStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsigned16List > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmBootstrapMethodStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsigned16List > :: deleteMemoryPool() ;
   }

void
SgAsmJvmBootstrapMethodStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsigned16List > :: writeToFile(out) ;
   }


void
SgAsmJvmBootstrapMethodStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsigned16List > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83392 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmClassStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83405 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmClassStorageClass::pickOutIRNodeData ( SgAsmJvmClass* pointer ) 
   { 
     SgAsmJvmClass* source = (SgAsmJvmClass*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83427 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmConstantPoolEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83440 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmConstantPoolEntryStorageClass::pickOutIRNodeData ( SgAsmJvmConstantPoolEntry* pointer ) 
   { 
     SgAsmJvmConstantPoolEntry* source = (SgAsmJvmConstantPoolEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_tag =  source->p_tag ;
     storageOf_bytes =  source->p_bytes ;
     storageOf_hi_bytes =  source->p_hi_bytes ;
     storageOf_low_bytes =  source->p_low_bytes ;
     storageOf_bootstrap_method_attr_index =  source->p_bootstrap_method_attr_index ;
     storageOf_class_index =  source->p_class_index ;
     storageOf_descriptor_index =  source->p_descriptor_index ;
     storageOf_name_index =  source->p_name_index ;
     storageOf_name_and_type_index =  source->p_name_and_type_index ;
     storageOf_reference_index =  source->p_reference_index ;
     storageOf_reference_kind =  source->p_reference_kind ;
     storageOf_string_index =  source->p_string_index ;
     storageOf_length =  source->p_length ;
     storageOf_utf8_bytes.storeDataInEasyStorageClass(source->p_utf8_bytes);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmConstantPoolEntryStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < char* > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmConstantPoolEntryStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < char* > :: deleteMemoryPool() ;
   }

void
SgAsmJvmConstantPoolEntryStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < char* > :: writeToFile(out) ;
   }


void
SgAsmJvmConstantPoolEntryStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < char* > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83502 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmExceptionHandlerStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83515 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmExceptionHandlerStorageClass::pickOutIRNodeData ( SgAsmJvmExceptionHandler* pointer ) 
   { 
     SgAsmJvmExceptionHandler* source = (SgAsmJvmExceptionHandler*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_start_pc =  source->p_start_pc ;
     storageOf_end_pc =  source->p_end_pc ;
     storageOf_handler_pc =  source->p_handler_pc ;
     storageOf_catch_type =  source->p_catch_type ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83541 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmExceptionTableStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83554 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmExceptionTableStorageClass::pickOutIRNodeData ( SgAsmJvmExceptionTable* pointer ) 
   { 
     SgAsmJvmExceptionTable* source = (SgAsmJvmExceptionTable*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmExceptionHandlerPtrList::iterator i_handlers = source->p_handlers.begin() ; 
     unsigned int tempListCounthandlers = 0; 
     SgAsmJvmExceptionHandlerPtrList::value_type *  tempListhandlers = new SgAsmJvmExceptionHandlerPtrList::value_type[ source->p_handlers.size() ]; 
     for ( ; i_handlers != source->p_handlers.end(); ++i_handlers ) 
        {
          tempListhandlers[tempListCounthandlers] = *i_handlers;
          tempListCounthandlers++; 
          (*i_handlers) = (SgAsmJvmExceptionHandlerPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_handlers ) );
        }
     storageOf_handlers.storeDataInEasyStorageClass(source->p_handlers);
     tempListCounthandlers = 0; 
     i_handlers = source->p_handlers.begin() ; 
     for ( ; i_handlers != source->p_handlers.end(); ++i_handlers ) 
        {
          *i_handlers = tempListhandlers[tempListCounthandlers] ;
          tempListCounthandlers++; 
        }
      delete [] tempListhandlers; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmExceptionTableStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmExceptionHandlerPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmExceptionTableStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmExceptionHandlerPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmExceptionTableStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmExceptionHandlerPtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmExceptionTableStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmExceptionHandlerPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83620 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmFieldStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83633 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmFieldStorageClass::pickOutIRNodeData ( SgAsmJvmField* pointer ) 
   { 
     SgAsmJvmField* source = (SgAsmJvmField*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_access_flags =  source->p_access_flags ;
     storageOf_name_index =  source->p_name_index ;
     storageOf_descriptor_index =  source->p_descriptor_index ;
     storageOf_attribute_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_attribute_table );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83659 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmInnerClassesEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83672 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmInnerClassesEntryStorageClass::pickOutIRNodeData ( SgAsmJvmInnerClassesEntry* pointer ) 
   { 
     SgAsmJvmInnerClassesEntry* source = (SgAsmJvmInnerClassesEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_inner_class_info_index =  source->p_inner_class_info_index ;
     storageOf_outer_class_info_index =  source->p_outer_class_info_index ;
     storageOf_inner_name_index =  source->p_inner_name_index ;
     storageOf_inner_class_access_flags =  source->p_inner_class_access_flags ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83698 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmLineNumberEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83711 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmLineNumberEntryStorageClass::pickOutIRNodeData ( SgAsmJvmLineNumberEntry* pointer ) 
   { 
     SgAsmJvmLineNumberEntry* source = (SgAsmJvmLineNumberEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_start_pc =  source->p_start_pc ;
     storageOf_line_number =  source->p_line_number ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83735 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmLocalVariableEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83748 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmLocalVariableEntryStorageClass::pickOutIRNodeData ( SgAsmJvmLocalVariableEntry* pointer ) 
   { 
     SgAsmJvmLocalVariableEntry* source = (SgAsmJvmLocalVariableEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_start_pc =  source->p_start_pc ;
     storageOf_length =  source->p_length ;
     storageOf_name_index =  source->p_name_index ;
     storageOf_descriptor_index =  source->p_descriptor_index ;
     storageOf_index =  source->p_index ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83775 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmLocalVariableTypeEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83788 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmLocalVariableTypeEntryStorageClass::pickOutIRNodeData ( SgAsmJvmLocalVariableTypeEntry* pointer ) 
   { 
     SgAsmJvmLocalVariableTypeEntry* source = (SgAsmJvmLocalVariableTypeEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_start_pc =  source->p_start_pc ;
     storageOf_length =  source->p_length ;
     storageOf_name_index =  source->p_name_index ;
     storageOf_signature_index =  source->p_signature_index ;
     storageOf_index =  source->p_index ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83815 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmMethodStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83828 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmMethodStorageClass::pickOutIRNodeData ( SgAsmJvmMethod* pointer ) 
   { 
     SgAsmJvmMethod* source = (SgAsmJvmMethod*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_access_flags =  source->p_access_flags ;
     storageOf_name_index =  source->p_name_index ;
     storageOf_descriptor_index =  source->p_descriptor_index ;
     storageOf_attribute_table = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_attribute_table );
     storageOf_instruction_list = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_instruction_list );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83855 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmMethodParametersEntryStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83868 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmMethodParametersEntryStorageClass::pickOutIRNodeData ( SgAsmJvmMethodParametersEntry* pointer ) 
   { 
     SgAsmJvmMethodParametersEntry* source = (SgAsmJvmMethodParametersEntry*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name_index =  source->p_name_index ;
     storageOf_access_flags =  source->p_access_flags ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83892 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmStackMapFrameStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 83905 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmStackMapFrameStorageClass::pickOutIRNodeData ( SgAsmJvmStackMapFrame* pointer ) 
   { 
     SgAsmJvmStackMapFrame* source = (SgAsmJvmStackMapFrame*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmJvmStackMapVerificationTypePtrList::iterator i_stack = source->p_stack.begin() ; 
     unsigned int tempListCountstack = 0; 
     SgAsmJvmStackMapVerificationTypePtrList::value_type *  tempListstack = new SgAsmJvmStackMapVerificationTypePtrList::value_type[ source->p_stack.size() ]; 
     for ( ; i_stack != source->p_stack.end(); ++i_stack ) 
        {
          tempListstack[tempListCountstack] = *i_stack;
          tempListCountstack++; 
          (*i_stack) = (SgAsmJvmStackMapVerificationTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_stack ) );
        }
     storageOf_stack.storeDataInEasyStorageClass(source->p_stack);
     tempListCountstack = 0; 
     i_stack = source->p_stack.begin() ; 
     for ( ; i_stack != source->p_stack.end(); ++i_stack ) 
        {
          *i_stack = tempListstack[tempListCountstack] ;
          tempListCountstack++; 
        }
      delete [] tempListstack; 
     SgAsmJvmStackMapVerificationTypePtrList::iterator i_locals = source->p_locals.begin() ; 
     unsigned int tempListCountlocals = 0; 
     SgAsmJvmStackMapVerificationTypePtrList::value_type *  tempListlocals = new SgAsmJvmStackMapVerificationTypePtrList::value_type[ source->p_locals.size() ]; 
     for ( ; i_locals != source->p_locals.end(); ++i_locals ) 
        {
          tempListlocals[tempListCountlocals] = *i_locals;
          tempListCountlocals++; 
          (*i_locals) = (SgAsmJvmStackMapVerificationTypePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_locals ) );
        }
     storageOf_locals.storeDataInEasyStorageClass(source->p_locals);
     tempListCountlocals = 0; 
     i_locals = source->p_locals.begin() ; 
     for ( ; i_locals != source->p_locals.end(); ++i_locals ) 
        {
          *i_locals = tempListlocals[tempListCountlocals] ;
          tempListCountlocals++; 
        }
      delete [] tempListlocals; 
     storageOf_frame_type =  source->p_frame_type ;
     storageOf_offset_delta =  source->p_offset_delta ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmStackMapFrameStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmJvmStackMapVerificationTypePtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmStackMapFrameStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmJvmStackMapVerificationTypePtrList > :: deleteMemoryPool() ;
   }

void
SgAsmJvmStackMapFrameStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmJvmStackMapVerificationTypePtrList > :: writeToFile(out) ;
   }


void
SgAsmJvmStackMapFrameStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmJvmStackMapVerificationTypePtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 83991 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmStackMapVerificationTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84004 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmStackMapVerificationTypeStorageClass::pickOutIRNodeData ( SgAsmJvmStackMapVerificationType* pointer ) 
   { 
     SgAsmJvmStackMapVerificationType* source = (SgAsmJvmStackMapVerificationType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_tag =  source->p_tag ;
     storageOf_cpool_index =  source->p_cpool_index ;
     storageOf_offset =  source->p_offset ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84029 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmOperandListStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84042 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmOperandListStorageClass::pickOutIRNodeData ( SgAsmOperandList* pointer ) 
   { 
     SgAsmOperandList* source = (SgAsmOperandList*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     SgAsmExpressionPtrList::iterator i_operands = source->p_operands.begin() ; 
     unsigned int tempListCountoperands = 0; 
     SgAsmExpressionPtrList::value_type *  tempListoperands = new SgAsmExpressionPtrList::value_type[ source->p_operands.size() ]; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          tempListoperands[tempListCountoperands] = *i_operands;
          tempListCountoperands++; 
          (*i_operands) = (SgAsmExpressionPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_operands ) );
        }
     storageOf_operands.storeDataInEasyStorageClass(source->p_operands);
     tempListCountoperands = 0; 
     i_operands = source->p_operands.begin() ; 
     for ( ; i_operands != source->p_operands.end(); ++i_operands ) 
        {
          *i_operands = tempListoperands[tempListCountoperands] ;
          tempListCountoperands++; 
        }
      delete [] tempListoperands; 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmOperandListStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmExpressionPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmOperandListStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmExpressionPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmOperandListStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmExpressionPtrList > :: writeToFile(out) ;
   }


void
SgAsmOperandListStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmExpressionPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84108 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStatementStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84121 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStatementStorageClass::pickOutIRNodeData ( SgAsmStatement* pointer ) 
   { 
     SgAsmStatement* source = (SgAsmStatement*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmStatementStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStatementStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmStatementStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmStatementStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84171 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmBlockStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84184 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmBlockStorageClass::pickOutIRNodeData ( SgAsmBlock* pointer ) 
   { 
     SgAsmBlock* source = (SgAsmBlock*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_id =  source->p_id ;
     storageOf_reason =  source->p_reason ;
     SgAsmStatementPtrList::iterator i_statementList = source->p_statementList.begin() ; 
     unsigned int tempListCountstatementList = 0; 
     SgAsmStatementPtrList::value_type *  tempListstatementList = new SgAsmStatementPtrList::value_type[ source->p_statementList.size() ]; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          tempListstatementList[tempListCountstatementList] = *i_statementList;
          tempListCountstatementList++; 
          (*i_statementList) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statementList ) );
        }
     storageOf_statementList.storeDataInEasyStorageClass(source->p_statementList);
     tempListCountstatementList = 0; 
     i_statementList = source->p_statementList.begin() ; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          *i_statementList = tempListstatementList[tempListCountstatementList] ;
          tempListCountstatementList++; 
        }
      delete [] tempListstatementList; 
     SgAsmIntegerValuePtrList::iterator i_successors = source->p_successors.begin() ; 
     unsigned int tempListCountsuccessors = 0; 
     SgAsmIntegerValuePtrList::value_type *  tempListsuccessors = new SgAsmIntegerValuePtrList::value_type[ source->p_successors.size() ]; 
     for ( ; i_successors != source->p_successors.end(); ++i_successors ) 
        {
          tempListsuccessors[tempListCountsuccessors] = *i_successors;
          tempListCountsuccessors++; 
          (*i_successors) = (SgAsmIntegerValuePtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_successors ) );
        }
     storageOf_successors.storeDataInEasyStorageClass(source->p_successors);
     tempListCountsuccessors = 0; 
     i_successors = source->p_successors.begin() ; 
     for ( ; i_successors != source->p_successors.end(); ++i_successors ) 
        {
          *i_successors = tempListsuccessors[tempListCountsuccessors] ;
          tempListCountsuccessors++; 
        }
      delete [] tempListsuccessors; 
     storageOf_successorsComplete =  source->p_successorsComplete ;
     storageOf_immediateDominator = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_immediateDominator );
     storageOf_cachedVertex =  source->p_cachedVertex ;
     storageOf_codeLikelihood =  source->p_codeLikelihood ;
     storageOf_stackDeltaOut =  source->p_stackDeltaOut ;
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmBlockStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmIntegerValuePtrList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmBlockStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
     EasyStorage < SgAsmIntegerValuePtrList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmBlockStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
     EasyStorage < SgAsmIntegerValuePtrList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmBlockStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
     EasyStorage < SgAsmIntegerValuePtrList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84285 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84298 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmInstructionStorageClass::pickOutIRNodeData ( SgAsmInstruction* pointer ) 
   { 
     SgAsmInstruction* source = (SgAsmInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84357 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmCilInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84370 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmCilInstructionStorageClass::pickOutIRNodeData ( SgAsmCilInstruction* pointer ) 
   { 
     SgAsmCilInstruction* source = (SgAsmCilInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmCilInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmCilInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmCilInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmCilInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84430 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmJvmInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84443 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmJvmInstructionStorageClass::pickOutIRNodeData ( SgAsmJvmInstruction* pointer ) 
   { 
     SgAsmJvmInstruction* source = (SgAsmJvmInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmJvmInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmJvmInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmJvmInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmJvmInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84503 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmM68kInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84516 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmM68kInstructionStorageClass::pickOutIRNodeData ( SgAsmM68kInstruction* pointer ) 
   { 
     SgAsmM68kInstruction* source = (SgAsmM68kInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_dataFormat =  source->p_dataFormat ;
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmM68kInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmM68kInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmM68kInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmM68kInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84577 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmMipsInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84590 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmMipsInstructionStorageClass::pickOutIRNodeData ( SgAsmMipsInstruction* pointer ) 
   { 
     SgAsmMipsInstruction* source = (SgAsmMipsInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmMipsInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmMipsInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmMipsInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmMipsInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84650 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmNullInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84663 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmNullInstructionStorageClass::pickOutIRNodeData ( SgAsmNullInstruction* pointer ) 
   { 
     SgAsmNullInstruction* source = (SgAsmNullInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmNullInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmNullInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmNullInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmNullInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84722 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPowerpcInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84735 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPowerpcInstructionStorageClass::pickOutIRNodeData ( SgAsmPowerpcInstruction* pointer ) 
   { 
     SgAsmPowerpcInstruction* source = (SgAsmPowerpcInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmPowerpcInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmPowerpcInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmPowerpcInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmPowerpcInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84795 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmUserInstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84808 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmUserInstructionStorageClass::pickOutIRNodeData ( SgAsmUserInstruction* pointer ) 
   { 
     SgAsmUserInstruction* source = (SgAsmUserInstruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmUserInstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmUserInstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmUserInstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmUserInstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84868 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmX86InstructionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84881 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmX86InstructionStorageClass::pickOutIRNodeData ( SgAsmX86Instruction* pointer ) 
   { 
     SgAsmX86Instruction* source = (SgAsmX86Instruction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_kind =  source->p_kind ;
     storageOf_baseSize =  source->p_baseSize ;
     storageOf_operandSize =  source->p_operandSize ;
     storageOf_addressSize =  source->p_addressSize ;
     storageOf_lockPrefix =  source->p_lockPrefix ;
     storageOf_repeatPrefix =  source->p_repeatPrefix ;
     storageOf_branchPrediction =  source->p_branchPrediction ;
     storageOf_segmentOverride =  source->p_segmentOverride ;
     storageOf_architectureId =  source->p_architectureId ;
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_operandList = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_operandList );
     storageOf_delaySlot = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_delaySlot );
     storageOf_semantics = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_semantics );
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmX86InstructionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmX86InstructionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmX86InstructionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmX86InstructionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 84948 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmStaticDataStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 84961 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmStaticDataStorageClass::pickOutIRNodeData ( SgAsmStaticData* pointer ) 
   { 
     SgAsmStaticData* source = (SgAsmStaticData*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_rawBytes.storeDataInEasyStorageClass(source->p_rawBytes);
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmStaticDataStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < SgUnsignedCharList > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmStaticDataStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < SgUnsignedCharList > :: deleteMemoryPool() ;
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmStaticDataStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < SgUnsignedCharList > :: writeToFile(out) ;
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmStaticDataStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < SgUnsignedCharList > :: readFromFile(in) ;
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85016 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmSynthesizedDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85029 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmSynthesizedDeclarationStorageClass::pickOutIRNodeData ( SgAsmSynthesizedDeclaration* pointer ) 
   { 
     SgAsmSynthesizedDeclaration* source = (SgAsmSynthesizedDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmSynthesizedDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmSynthesizedDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmSynthesizedDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmSynthesizedDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85079 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmFunctionStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85092 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmFunctionStorageClass::pickOutIRNodeData ( SgAsmFunction* pointer ) 
   { 
     SgAsmFunction* source = (SgAsmFunction*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_reason =  source->p_reason ;
     storageOf_reasonComment.storeDataInEasyStorageClass(source->p_reasonComment);
     storageOf_functionKind =  source->p_functionKind ;
     storageOf_mayReturn =  source->p_mayReturn ;
     storageOf_nameMd5.storeDataInEasyStorageClass(source->p_nameMd5);
     SgAsmStatementPtrList::iterator i_statementList = source->p_statementList.begin() ; 
     unsigned int tempListCountstatementList = 0; 
     SgAsmStatementPtrList::value_type *  tempListstatementList = new SgAsmStatementPtrList::value_type[ source->p_statementList.size() ]; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          tempListstatementList[tempListCountstatementList] = *i_statementList;
          tempListCountstatementList++; 
          (*i_statementList) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_statementList ) );
        }
     storageOf_statementList.storeDataInEasyStorageClass(source->p_statementList);
     tempListCountstatementList = 0; 
     i_statementList = source->p_statementList.begin() ; 
     for ( ; i_statementList != source->p_statementList.end(); ++i_statementList ) 
        {
          *i_statementList = tempListstatementList[tempListCountstatementList] ;
          tempListCountstatementList++; 
        }
      delete [] tempListstatementList; 
     SgAsmStatementPtrList::iterator i_dest = source->p_dest.begin() ; 
     unsigned int tempListCountdest = 0; 
     SgAsmStatementPtrList::value_type *  tempListdest = new SgAsmStatementPtrList::value_type[ source->p_dest.size() ]; 
     for ( ; i_dest != source->p_dest.end(); ++i_dest ) 
        {
          tempListdest[tempListCountdest] = *i_dest;
          tempListCountdest++; 
          (*i_dest) = (SgAsmStatementPtrList::value_type)(AST_FILE_IO::getGlobalIndexFromSgClassPointer ( *i_dest ) );
        }
     storageOf_dest.storeDataInEasyStorageClass(source->p_dest);
     tempListCountdest = 0; 
     i_dest = source->p_dest.begin() ; 
     for ( ; i_dest != source->p_dest.end(); ++i_dest ) 
        {
          *i_dest = tempListdest[tempListCountdest] ;
          tempListCountdest++; 
        }
      delete [] tempListdest; 
     storageOf_entryVa =  source->p_entryVa ;
     storageOf_symbolTable = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_symbolTable );
     storageOf_cachedVertex =  source->p_cachedVertex ;
     storageOf_stackDelta =  source->p_stackDelta ;
     storageOf_callingConvention.storeDataInEasyStorageClass(source->p_callingConvention);
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmFunctionStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
     EasyStorage < SgAsmStatementPtrList > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmFunctionStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
     EasyStorage < SgAsmStatementPtrList > :: deleteMemoryPool() ;
   }

void
SgAsmFunctionStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
     EasyStorage < SgAsmStatementPtrList > :: writeToFile(out) ;
   }


void
SgAsmFunctionStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
     EasyStorage < SgAsmStatementPtrList > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85193 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmSynthesizedDataStructureDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85206 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmSynthesizedDataStructureDeclarationStorageClass::pickOutIRNodeData ( SgAsmSynthesizedDataStructureDeclaration* pointer ) 
   { 
     SgAsmSynthesizedDataStructureDeclaration* source = (SgAsmSynthesizedDataStructureDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmSynthesizedDataStructureDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmSynthesizedDataStructureDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmSynthesizedDataStructureDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmSynthesizedDataStructureDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85256 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmSynthesizedFieldDeclarationStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85269 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmSynthesizedFieldDeclarationStorageClass::pickOutIRNodeData ( SgAsmSynthesizedFieldDeclaration* pointer ) 
   { 
     SgAsmSynthesizedFieldDeclaration* source = (SgAsmSynthesizedFieldDeclaration*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_name.storeDataInEasyStorageClass(source->p_name);
     storageOf_offset =  source->p_offset ;
     storageOf_address =  source->p_address ;
     storageOf_comment.storeDataInEasyStorageClass(source->p_comment);
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }

void
SgAsmSynthesizedFieldDeclarationStorageClass::arrangeStaticDataOfEasyStorageClassesInOneBlock ( )
   { 
     EasyStorage < std::string > :: arrangeMemoryPoolInOneBlock() ;
   }

void
SgAsmSynthesizedFieldDeclarationStorageClass::deleteStaticDataOfEasyStorageClasses ( ) 
   { 
     EasyStorage < std::string > :: deleteMemoryPool() ;
   }

void
SgAsmSynthesizedFieldDeclarationStorageClass::writeEasyStorageDataToFile (std::ostream& out)
   {
     EasyStorage < std::string > :: writeToFile(out) ;
   }


void
SgAsmSynthesizedFieldDeclarationStorageClass::readEasyStorageDataFromFile (std::istream& in)
      { 
     EasyStorage < std::string > :: readFromFile(in) ;
   }



/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85321 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85334 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmTypeStorageClass::pickOutIRNodeData ( SgAsmType* pointer ) 
   { 
     SgAsmType* source = (SgAsmType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85356 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmScalarTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85369 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmScalarTypeStorageClass::pickOutIRNodeData ( SgAsmScalarType* pointer ) 
   { 
     SgAsmScalarType* source = (SgAsmScalarType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_minorOrder =  source->p_minorOrder ;
     storageOf_majorOrder =  source->p_majorOrder ;
     storageOf_majorNBytes =  source->p_majorNBytes ;
     storageOf_nBits =  source->p_nBits ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85395 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmFloatTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85408 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmFloatTypeStorageClass::pickOutIRNodeData ( SgAsmFloatType* pointer ) 
   { 
     SgAsmFloatType* source = (SgAsmFloatType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_significandOffset =  source->p_significandOffset ;
     storageOf_significandNBits =  source->p_significandNBits ;
     storageOf_signBitOffset =  source->p_signBitOffset ;
     storageOf_exponentOffset =  source->p_exponentOffset ;
     storageOf_exponentNBits =  source->p_exponentNBits ;
     storageOf_exponentBias =  source->p_exponentBias ;
     storageOf_flags =  source->p_flags ;
     storageOf_minorOrder =  source->p_minorOrder ;
     storageOf_majorOrder =  source->p_majorOrder ;
     storageOf_majorNBytes =  source->p_majorNBytes ;
     storageOf_nBits =  source->p_nBits ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85441 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmIntegerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85454 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmIntegerTypeStorageClass::pickOutIRNodeData ( SgAsmIntegerType* pointer ) 
   { 
     SgAsmIntegerType* source = (SgAsmIntegerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_isSigned =  source->p_isSigned ;
     storageOf_minorOrder =  source->p_minorOrder ;
     storageOf_majorOrder =  source->p_majorOrder ;
     storageOf_majorNBytes =  source->p_majorNBytes ;
     storageOf_nBits =  source->p_nBits ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85481 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmPointerTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85494 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmPointerTypeStorageClass::pickOutIRNodeData ( SgAsmPointerType* pointer ) 
   { 
     SgAsmPointerType* source = (SgAsmPointerType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_subtype = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_subtype );
     storageOf_minorOrder =  source->p_minorOrder ;
     storageOf_majorOrder =  source->p_majorOrder ;
     storageOf_majorNBytes =  source->p_majorNBytes ;
     storageOf_nBits =  source->p_nBits ;
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85521 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmVectorTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85534 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmVectorTypeStorageClass::pickOutIRNodeData ( SgAsmVectorType* pointer ) 
   { 
     SgAsmVectorType* source = (SgAsmVectorType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_nElmts =  source->p_nElmts ;
     storageOf_elmtType = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_elmtType );
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85558 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



/* #line 1 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */

// ****************************************************************
// member functions definition specific to each node in the grammar
// these are the SgAsmVoidTypeStorageClass parts !!!!
// ROSETTA generated code. Do not change by hand.
// ****************************************************************


/* #line 85571 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */


void
SgAsmVoidTypeStorageClass::pickOutIRNodeData ( SgAsmVoidType* pointer ) 
   { 
     SgAsmVoidType* source = (SgAsmVoidType*) (pointer); 
#if FILE_IO_EXTRA_CHECK 
     ASSERT_not_null(source) ; 
     ASSERT_not_null(source->p_freepointer) ; 
#endif 
     storageOf_parent = AST_FILE_IO::getGlobalIndexFromSgClassPointer ( source->p_parent );
     storageOf_isModified =  source->p_isModified ;
     storageOf_containsTransformation =  source->p_containsTransformation ;
   }


/* #line 8 "/workspace/generated/src/ROSETTA/Grammar/grammarStorageClassDefinitionMacros.macro" */


// ********************************************************

/* #line 85593 "/workspace/generated/src/frontend/SageIII//StorageClasses.C" */



#endif // STORAGE_CLASSES_H

