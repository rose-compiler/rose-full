// MACHINE GENERATED SOURCE FILE WITH ROSE (Grammar.h)--- DO NOT MODIFY!

#include "sage3basic.h"

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
   #include "AST_FILE_IO.h"
#endif 
// The header file ("rose_config.h") should only be included by source files that require it.
#include "rose_config.h"

#if _MSC_VER
#define USE_CPP_NEW_DELETE_OPERATORS 0
#endif

#define ROSE_ALLOC_TRACE 0
#undef mprintf
#define mprintf Rose::Diagnostics::mfprintf(Rose::ir_node_mlog[Rose::Diagnostics::DEBUG])

#include <Rose/BinaryAnalysis/RegisterDictionary.h>

using namespace std;

// Simplify code by using std namespace (never put into header files since it effects users) 
using namespace std;

vector<SgNode*>
SgNode::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgNode::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgNode::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNode" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgNode::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgNode::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgSupport::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgSupport::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgSupport::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSupport" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgSupport::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgSupport::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgModifier::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgModifier" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgModifier" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgModifier::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgModifier" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgModifier::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgModifier" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgModifier::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgModifier" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgModifierNodes::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgModifierNodes::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgModifierNodes::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgModifierNodes::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgModifierNodes" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgModifierNodes::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgModifierNodes" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgConstVolatileModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgConstVolatileModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgConstVolatileModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgConstVolatileModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgConstVolatileModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgConstVolatileModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgConstVolatileModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgStorageModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgStorageModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgStorageModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgStorageModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgStorageModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgStorageModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgStorageModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAccessModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAccessModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAccessModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAccessModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAccessModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAccessModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAccessModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFunctionModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFunctionModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFunctionModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFunctionModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFunctionModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFunctionModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFunctionModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUPC_AccessModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUPC_AccessModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUPC_AccessModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUPC_AccessModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUPC_AccessModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUPC_AccessModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUPC_AccessModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgSpecialFunctionModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgSpecialFunctionModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgSpecialFunctionModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgSpecialFunctionModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgSpecialFunctionModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgSpecialFunctionModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgSpecialFunctionModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgElaboratedTypeModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgElaboratedTypeModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgElaboratedTypeModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgElaboratedTypeModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgElaboratedTypeModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgElaboratedTypeModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgElaboratedTypeModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLinkageModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgLinkageModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgLinkageModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgLinkageModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgLinkageModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgLinkageModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgLinkageModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgBaseClassModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgBaseClassModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgBaseClassModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgBaseClassModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgBaseClassModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgBaseClassModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgBaseClassModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgStructureModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgStructureModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgStructureModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgStructureModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgStructureModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgStructureModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgStructureModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTypeModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTypeModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTypeModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTypeModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTypeModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTypeModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTypeModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgDeclarationModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDeclarationModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDeclarationModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDeclarationModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDeclarationModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDeclarationModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDeclarationModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOpenclAccessModeModifier::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOpenclAccessModeModifier::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOpenclAccessModeModifier::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOpenclAccessModeModifier::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOpenclAccessModeModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOpenclAccessModeModifier::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOpenclAccessModeModifier" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgName::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgName::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgName::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgName::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgName" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgName::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgName" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgSymbolTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgSymbolTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgSymbolTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgSymbolTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgSymbolTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgSymbolTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgSymbolTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAttribute::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAttribute::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAttribute::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAttribute" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAttribute::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAttribute::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgPragma::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgPragma::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgPragma::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgPragma::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgPragma" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgPragma::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgPragma" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgBitAttribute::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBitAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgBitAttribute::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBitAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgBitAttribute::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBitAttribute" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgBitAttribute::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBitAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgBitAttribute::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBitAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgFuncDecl_attr::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFuncDecl_attr::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFuncDecl_attr::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFuncDecl_attr::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFuncDecl_attr" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFuncDecl_attr::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFuncDecl_attr" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgClassDecl_attr::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgClassDecl_attr::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgClassDecl_attr::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgClassDecl_attr::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgClassDecl_attr" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgClassDecl_attr::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgClassDecl_attr" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
Sg_File_Info::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
Sg_File_Info::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
Sg_File_Info::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
Sg_File_Info::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "Sg_File_Info" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
Sg_File_Info::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "Sg_File_Info" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFile::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgFile" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgFile::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgFile" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgFile::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgFile" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgFile::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgFile" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgFile::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgFile" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgSourceFile::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_globalScope);
traversalSuccessorContainer.push_back(p_package);
traversalSuccessorContainer.push_back(p_import_list);
traversalSuccessorContainer.push_back(p_class_list);
return traversalSuccessorContainer;
}
vector<string>
SgSourceFile::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_globalScope");
traversalSuccessorContainer.push_back("p_package");
traversalSuccessorContainer.push_back("p_import_list");
traversalSuccessorContainer.push_back("p_class_list");
return traversalSuccessorContainer;
}
size_t
SgSourceFile::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgSourceFile::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_globalScope == NULL || p_globalScope != NULL); return p_globalScope;
case 1: ROSE_ASSERT(p_package == NULL || p_package != NULL); return p_package;
case 2: ROSE_ASSERT(p_import_list == NULL || p_import_list != NULL); return p_import_list;
case 3: ROSE_ASSERT(p_class_list == NULL || p_class_list != NULL); return p_class_list;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSourceFile::get_childIndex(SgNode *child) const {
if (child == p_globalScope) return 0;
else if (child == p_package) return 1;
else if (child == p_import_list) return 2;
else if (child == p_class_list) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgUnknownFile::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_globalScope);
return traversalSuccessorContainer;
}
vector<string>
SgUnknownFile::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_globalScope");
return traversalSuccessorContainer;
}
size_t
SgUnknownFile::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUnknownFile::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_globalScope == NULL || p_globalScope != NULL); return p_globalScope;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUnknownFile::get_childIndex(SgNode *child) const {
if (child == p_globalScope) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgBinaryComposite::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_genericFileList);
traversalSuccessorContainer.push_back(p_interpretations);
return traversalSuccessorContainer;
}
vector<string>
SgBinaryComposite::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_genericFileList");
traversalSuccessorContainer.push_back("p_interpretations");
return traversalSuccessorContainer;
}
size_t
SgBinaryComposite::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgBinaryComposite::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_genericFileList == NULL || p_genericFileList != NULL); return p_genericFileList;
case 1: ROSE_ASSERT(p_interpretations == NULL || p_interpretations != NULL); return p_interpretations;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBinaryComposite::get_childIndex(SgNode *child) const {
if (child == p_genericFileList) return 0;
else if (child == p_interpretations) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgJvmComposite::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_genericFileList);
traversalSuccessorContainer.push_back(p_interpretations);
return traversalSuccessorContainer;
}
vector<string>
SgJvmComposite::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_genericFileList");
traversalSuccessorContainer.push_back("p_interpretations");
return traversalSuccessorContainer;
}
size_t
SgJvmComposite::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJvmComposite::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_genericFileList == NULL || p_genericFileList != NULL); return p_genericFileList;
case 1: ROSE_ASSERT(p_interpretations == NULL || p_interpretations != NULL); return p_interpretations;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJvmComposite::get_childIndex(SgNode *child) const {
if (child == p_genericFileList) return 0;
else if (child == p_interpretations) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgProject::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_fileList_ptr);
return traversalSuccessorContainer;
}
vector<string>
SgProject::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_fileList_ptr");
return traversalSuccessorContainer;
}
size_t
SgProject::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgProject::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_fileList_ptr == NULL || p_fileList_ptr != NULL); return p_fileList_ptr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgProject::get_childIndex(SgNode *child) const {
if (child == p_fileList_ptr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOptions::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOptions::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOptions::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOptions::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOptions" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOptions::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOptions" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUnparse_Info::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUnparse_Info::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUnparse_Info::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUnparse_Info::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUnparse_Info" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUnparse_Info::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUnparse_Info" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgBaseClass::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBaseClass" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgBaseClass::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBaseClass" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgBaseClass::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBaseClass" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgBaseClass::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBaseClass" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgBaseClass::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBaseClass" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgExpBaseClass::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_base_class);
traversalSuccessorContainer.push_back(p_base_class_exp);
return traversalSuccessorContainer;
}
vector<string>
SgExpBaseClass::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_base_class");
traversalSuccessorContainer.push_back("p_base_class_exp");
return traversalSuccessorContainer;
}
size_t
SgExpBaseClass::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgExpBaseClass::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_base_class == NULL || p_base_class != NULL); return p_base_class;
case 1: ROSE_ASSERT(p_base_class_exp == NULL || p_base_class_exp != NULL); return p_base_class_exp;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgExpBaseClass::get_childIndex(SgNode *child) const {
if (child == p_base_class) return 0;
else if (child == p_base_class_exp) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgNonrealBaseClass::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_base_class);
traversalSuccessorContainer.push_back(p_base_class_nonreal);
return traversalSuccessorContainer;
}
vector<string>
SgNonrealBaseClass::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_base_class");
traversalSuccessorContainer.push_back("p_base_class_nonreal");
return traversalSuccessorContainer;
}
size_t
SgNonrealBaseClass::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgNonrealBaseClass::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_base_class == NULL || p_base_class != NULL); return p_base_class;
case 1: ROSE_ASSERT(p_base_class_nonreal == NULL || p_base_class_nonreal != NULL); return p_base_class_nonreal;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNonrealBaseClass::get_childIndex(SgNode *child) const {
if (child == p_base_class) return 0;
else if (child == p_base_class_nonreal) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypedefSeq::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTypedefSeq::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTypedefSeq::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTypedefSeq::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTypedefSeq" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTypedefSeq::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTypedefSeq" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateParameter::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_defaultExpressionParameter);
traversalSuccessorContainer.push_back(p_templateDeclaration);
traversalSuccessorContainer.push_back(p_defaultTemplateDeclarationParameter);
traversalSuccessorContainer.push_back(p_initializedName);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateParameter::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_defaultExpressionParameter");
traversalSuccessorContainer.push_back("p_templateDeclaration");
traversalSuccessorContainer.push_back("p_defaultTemplateDeclarationParameter");
traversalSuccessorContainer.push_back("p_initializedName");
return traversalSuccessorContainer;
}
size_t
SgTemplateParameter::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgTemplateParameter::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_defaultExpressionParameter == NULL || p_defaultExpressionParameter != NULL); return p_defaultExpressionParameter;
case 2: ROSE_ASSERT(p_templateDeclaration == NULL || p_templateDeclaration != NULL); return p_templateDeclaration;
case 3: ROSE_ASSERT(p_defaultTemplateDeclarationParameter == NULL || p_defaultTemplateDeclarationParameter != NULL); return p_defaultTemplateDeclarationParameter;
case 4: ROSE_ASSERT(p_initializedName == NULL || p_initializedName != NULL); return p_initializedName;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateParameter::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_defaultExpressionParameter) return 1;
else if (child == p_templateDeclaration) return 2;
else if (child == p_defaultTemplateDeclarationParameter) return 3;
else if (child == p_initializedName) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateArgument::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_templateDeclaration);
traversalSuccessorContainer.push_back(p_initializedName);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateArgument::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_templateDeclaration");
traversalSuccessorContainer.push_back("p_initializedName");
return traversalSuccessorContainer;
}
size_t
SgTemplateArgument::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgTemplateArgument::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_templateDeclaration == NULL || p_templateDeclaration != NULL); return p_templateDeclaration;
case 2: ROSE_ASSERT(p_initializedName == NULL || p_initializedName != NULL); return p_initializedName;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateArgument::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_templateDeclaration) return 1;
else if (child == p_initializedName) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgDirectory::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_fileList);
traversalSuccessorContainer.push_back(p_directoryList);
return traversalSuccessorContainer;
}
vector<string>
SgDirectory::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_fileList");
traversalSuccessorContainer.push_back("p_directoryList");
return traversalSuccessorContainer;
}
size_t
SgDirectory::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDirectory::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_fileList == NULL || p_fileList != NULL); return p_fileList;
case 1: ROSE_ASSERT(p_directoryList == NULL || p_directoryList != NULL); return p_directoryList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDirectory::get_childIndex(SgNode *child) const {
if (child == p_fileList) return 0;
else if (child == p_directoryList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgFileList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_listOfFiles.size() + 0);
   {
     SgFilePtrList::const_iterator iter;
     for (iter = p_listOfFiles.begin(); iter != p_listOfFiles.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgFileList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgFilePtrList::const_iterator  iter;
     for (iter = p_listOfFiles.begin(); iter != p_listOfFiles.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgFileList::get_numberOfTraversalSuccessors() const {
return p_listOfFiles.size() + 0;
}
SgNode *
SgFileList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_listOfFiles.size());
return p_listOfFiles[idx];
}
size_t
SgFileList::get_childIndex(SgNode *child) const {
SgFilePtrList::const_iterator itr = find(p_listOfFiles.begin(), p_listOfFiles.end(), child);
if (itr != p_listOfFiles.end()) return itr - p_listOfFiles.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgDirectoryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_listOfDirectories.size() + 0);
   {
     SgDirectoryPtrList::const_iterator iter;
     for (iter = p_listOfDirectories.begin(); iter != p_listOfDirectories.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgDirectoryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDirectoryPtrList::const_iterator  iter;
     for (iter = p_listOfDirectories.begin(); iter != p_listOfDirectories.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgDirectoryList::get_numberOfTraversalSuccessors() const {
return p_listOfDirectories.size() + 0;
}
SgNode *
SgDirectoryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_listOfDirectories.size());
return p_listOfDirectories[idx];
}
size_t
SgDirectoryList::get_childIndex(SgNode *child) const {
SgDirectoryPtrList::const_iterator itr = find(p_listOfDirectories.begin(), p_listOfDirectories.end(), child);
if (itr != p_listOfDirectories.end()) return itr - p_listOfDirectories.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionParameterTypeList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFunctionParameterTypeList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFunctionParameterTypeList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFunctionParameterTypeList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFunctionParameterTypeList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFunctionParameterTypeList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFunctionParameterTypeList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgQualifiedName::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgQualifiedName::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgQualifiedName::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgQualifiedName::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgQualifiedName" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgQualifiedName::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgQualifiedName" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateArgumentList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_args.size() + 0);
   {
     SgTemplateArgumentPtrList::const_iterator iter;
     for (iter = p_args.begin(); iter != p_args.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgTemplateArgumentList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgTemplateArgumentPtrList::const_iterator  iter;
     for (iter = p_args.begin(); iter != p_args.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgTemplateArgumentList::get_numberOfTraversalSuccessors() const {
return p_args.size() + 0;
}
SgNode *
SgTemplateArgumentList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_args.size());
return p_args[idx];
}
size_t
SgTemplateArgumentList::get_childIndex(SgNode *child) const {
SgTemplateArgumentPtrList::const_iterator itr = find(p_args.begin(), p_args.end(), child);
if (itr != p_args.end()) return itr - p_args.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateParameterList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_args.size() + 0);
   {
     SgTemplateParameterPtrList::const_iterator iter;
     for (iter = p_args.begin(); iter != p_args.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgTemplateParameterList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgTemplateParameterPtrList::const_iterator  iter;
     for (iter = p_args.begin(); iter != p_args.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgTemplateParameterList::get_numberOfTraversalSuccessors() const {
return p_args.size() + 0;
}
SgNode *
SgTemplateParameterList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_args.size());
return p_args[idx];
}
size_t
SgTemplateParameterList::get_childIndex(SgNode *child) const {
SgTemplateParameterPtrList::const_iterator itr = find(p_args.begin(), p_args.end(), child);
if (itr != p_args.end()) return itr - p_args.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgGraph::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgGraph::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgGraph::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraph" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgGraph::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgGraph::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgIncidenceDirectedGraph::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIncidenceDirectedGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgIncidenceDirectedGraph::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIncidenceDirectedGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgIncidenceDirectedGraph::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIncidenceDirectedGraph" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgIncidenceDirectedGraph::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIncidenceDirectedGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgIncidenceDirectedGraph::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIncidenceDirectedGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgBidirectionalGraph::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBidirectionalGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgBidirectionalGraph::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBidirectionalGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgBidirectionalGraph::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBidirectionalGraph" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgBidirectionalGraph::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBidirectionalGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgBidirectionalGraph::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBidirectionalGraph" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgStringKeyedBidirectionalGraph::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgStringKeyedBidirectionalGraph::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgStringKeyedBidirectionalGraph::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgStringKeyedBidirectionalGraph::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgStringKeyedBidirectionalGraph" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgStringKeyedBidirectionalGraph::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgStringKeyedBidirectionalGraph" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIntKeyedBidirectionalGraph::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIntKeyedBidirectionalGraph::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIntKeyedBidirectionalGraph::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIntKeyedBidirectionalGraph::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIntKeyedBidirectionalGraph" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIntKeyedBidirectionalGraph::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIntKeyedBidirectionalGraph" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIncidenceUndirectedGraph::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIncidenceUndirectedGraph::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIncidenceUndirectedGraph::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIncidenceUndirectedGraph::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIncidenceUndirectedGraph" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIncidenceUndirectedGraph::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIncidenceUndirectedGraph" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgGraphNode::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgGraphNode::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgGraphNode::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgGraphNode::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgGraphNode" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgGraphNode::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgGraphNode" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgGraphEdge::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraphEdge" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgGraphEdge::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraphEdge" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgGraphEdge::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraphEdge" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgGraphEdge::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraphEdge" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgGraphEdge::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgGraphEdge" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgDirectedGraphEdge::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDirectedGraphEdge::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDirectedGraphEdge::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDirectedGraphEdge::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDirectedGraphEdge" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDirectedGraphEdge::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDirectedGraphEdge" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUndirectedGraphEdge::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUndirectedGraphEdge::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUndirectedGraphEdge::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUndirectedGraphEdge::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUndirectedGraphEdge" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUndirectedGraphEdge::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUndirectedGraphEdge" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgGraphNodeList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgGraphNodeList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgGraphNodeList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgGraphNodeList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgGraphNodeList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgGraphNodeList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgGraphNodeList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgGraphEdgeList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgGraphEdgeList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgGraphEdgeList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgGraphEdgeList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgGraphEdgeList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgGraphEdgeList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgGraphEdgeList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTypeTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTypeTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTypeTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTypeTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTypeTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTypeTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTypeTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgNameGroup::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNameGroup::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNameGroup::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNameGroup::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNameGroup" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNameGroup::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNameGroup" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgDimensionObject::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDimensionObject::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDimensionObject::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDimensionObject::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDimensionObject" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDimensionObject::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDimensionObject" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFormatItem::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFormatItem::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFormatItem::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFormatItem::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFormatItem" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFormatItem::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFormatItem" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFormatItemList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFormatItemList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFormatItemList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFormatItemList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFormatItemList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFormatItemList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFormatItemList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgDataStatementGroup::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDataStatementGroup::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDataStatementGroup::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDataStatementGroup::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDataStatementGroup" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDataStatementGroup::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDataStatementGroup" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgDataStatementObject::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDataStatementObject::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDataStatementObject::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDataStatementObject::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDataStatementObject" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDataStatementObject::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDataStatementObject" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIncludeFile::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_include_file_list.size() + 0);
   {
     SgIncludeFilePtrList::const_iterator iter;
     for (iter = p_include_file_list.begin(); iter != p_include_file_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgIncludeFile::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgIncludeFilePtrList::const_iterator  iter;
     for (iter = p_include_file_list.begin(); iter != p_include_file_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgIncludeFile::get_numberOfTraversalSuccessors() const {
return p_include_file_list.size() + 0;
}
SgNode *
SgIncludeFile::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_include_file_list.size());
return p_include_file_list[idx];
}
size_t
SgIncludeFile::get_childIndex(SgNode *child) const {
SgIncludeFilePtrList::const_iterator itr = find(p_include_file_list.begin(), p_include_file_list.end(), child);
if (itr != p_include_file_list.end()) return itr - p_include_file_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgDataStatementValue::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDataStatementValue::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDataStatementValue::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDataStatementValue::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDataStatementValue" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDataStatementValue::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDataStatementValue" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaImportStatementList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_java_import_list.size() + 0);
   {
     SgJavaImportStatementPtrList::const_iterator iter;
     for (iter = p_java_import_list.begin(); iter != p_java_import_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgJavaImportStatementList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgJavaImportStatementPtrList::const_iterator  iter;
     for (iter = p_java_import_list.begin(); iter != p_java_import_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgJavaImportStatementList::get_numberOfTraversalSuccessors() const {
return p_java_import_list.size() + 0;
}
SgNode *
SgJavaImportStatementList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_java_import_list.size());
return p_java_import_list[idx];
}
size_t
SgJavaImportStatementList::get_childIndex(SgNode *child) const {
SgJavaImportStatementPtrList::const_iterator itr = find(p_java_import_list.begin(), p_java_import_list.end(), child);
if (itr != p_java_import_list.end()) return itr - p_java_import_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgJavaClassDeclarationList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_java_class_list.size() + 0);
   {
     SgClassDeclarationPtrList::const_iterator iter;
     for (iter = p_java_class_list.begin(); iter != p_java_class_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgJavaClassDeclarationList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgClassDeclarationPtrList::const_iterator  iter;
     for (iter = p_java_class_list.begin(); iter != p_java_class_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgJavaClassDeclarationList::get_numberOfTraversalSuccessors() const {
return p_java_class_list.size() + 0;
}
SgNode *
SgJavaClassDeclarationList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_java_class_list.size());
return p_java_class_list[idx];
}
size_t
SgJavaClassDeclarationList::get_childIndex(SgNode *child) const {
SgClassDeclarationPtrList::const_iterator itr = find(p_java_class_list.begin(), p_java_class_list.end(), child);
if (itr != p_java_class_list.end()) return itr - p_java_class_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgHeaderFileReport::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgHeaderFileReport::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgHeaderFileReport::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgHeaderFileReport::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgHeaderFileReport" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgHeaderFileReport::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgHeaderFileReport" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgType::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgType::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgType" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgType::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgType::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgTypeUnknown::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeUnknown::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeUnknown::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeUnknown::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeUnknown::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeChar::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeChar::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeChar::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeChar::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeChar::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeSignedChar::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeSignedChar::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeSignedChar::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeSignedChar::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeSignedChar::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeUnsignedChar::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeUnsignedChar::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeUnsignedChar::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeUnsignedChar::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeUnsignedChar::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeShort::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeShort::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeShort::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeShort::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeShort::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeSignedShort::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeSignedShort::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeSignedShort::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeSignedShort::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeSignedShort::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeUnsignedShort::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeUnsignedShort::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeUnsignedShort::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeUnsignedShort::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeUnsignedShort::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeInt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeInt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeInt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeInt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeInt::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeSignedInt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeSignedInt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeSignedInt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeSignedInt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeSignedInt::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeUnsignedInt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeUnsignedInt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeUnsignedInt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeUnsignedInt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeUnsignedInt::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeLong::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeLong::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeLong::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeLong::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeLong::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeSignedLong::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeSignedLong::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeSignedLong::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeSignedLong::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeSignedLong::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeUnsignedLong::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeUnsignedLong::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeUnsignedLong::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeUnsignedLong::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeUnsignedLong::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeVoid::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeVoid::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeVoid::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeVoid::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeVoid::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeGlobalVoid::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeGlobalVoid::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeGlobalVoid::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeGlobalVoid::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeGlobalVoid::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeWchar::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeWchar::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeWchar::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeWchar::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeWchar::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeFloat::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeFloat::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeFloat::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeFloat::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeFloat::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeDouble::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeDouble::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeDouble::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeDouble::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeDouble::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeLongLong::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeLongLong::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeLongLong::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeLongLong::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeLongLong::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeSignedLongLong::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeSignedLongLong::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeSignedLongLong::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeSignedLongLong::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeSignedLongLong::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeUnsignedLongLong::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeUnsignedLongLong::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeUnsignedLongLong::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeUnsignedLongLong::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeUnsignedLongLong::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeSigned128bitInteger::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeSigned128bitInteger::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeSigned128bitInteger::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeSigned128bitInteger::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeSigned128bitInteger::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeUnsigned128bitInteger::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeUnsigned128bitInteger::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeUnsigned128bitInteger::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeUnsigned128bitInteger::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeUnsigned128bitInteger::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeFloat80::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeFloat80::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeFloat80::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeFloat80::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeFloat80::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeLongDouble::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeLongDouble::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeLongDouble::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeLongDouble::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeLongDouble::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeString::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_lengthExpression);
return traversalSuccessorContainer;
}
vector<string>
SgTypeString::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_lengthExpression");
return traversalSuccessorContainer;
}
size_t
SgTypeString::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeString::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_lengthExpression == NULL || p_lengthExpression != NULL); return p_lengthExpression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeString::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_lengthExpression) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeBool::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeBool::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeBool::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeBool::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeBool::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPointerType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_base_type);
return traversalSuccessorContainer;
}
vector<string>
SgPointerType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_base_type");
return traversalSuccessorContainer;
}
size_t
SgPointerType::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgPointerType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_base_type == NULL || p_base_type != NULL); return p_base_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPointerType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_base_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPointerMemberType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_base_type);
return traversalSuccessorContainer;
}
vector<string>
SgPointerMemberType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_base_type");
return traversalSuccessorContainer;
}
size_t
SgPointerMemberType::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgPointerMemberType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_base_type == NULL || p_base_type != NULL); return p_base_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPointerMemberType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_base_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgReferenceType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgReferenceType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgReferenceType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgReferenceType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgReferenceType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgNamedType::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNamedType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgNamedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNamedType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgNamedType::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNamedType" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgNamedType::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNamedType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgNamedType::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNamedType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgClassType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgClassType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgClassType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgClassType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgClassType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaParameterType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgJavaParameterType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgJavaParameterType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgJavaParameterType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaParameterType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgJovialTableType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
traversalSuccessorContainer.push_back(p_dim_info);
return traversalSuccessorContainer;
}
vector<string>
SgJovialTableType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
traversalSuccessorContainer.push_back("p_dim_info");
return traversalSuccessorContainer;
}
size_t
SgJovialTableType::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgJovialTableType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
case 3: ROSE_ASSERT(p_dim_info == NULL || p_dim_info != NULL); return p_dim_info;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJovialTableType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else if (child == p_dim_info) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgEnumType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgEnumType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgEnumType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgEnumType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgEnumType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgTypedefType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTypedefType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTypedefType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgTypedefType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypedefType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgNonrealType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgNonrealType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgNonrealType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgNonrealType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNonrealType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaParameterizedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgJavaParameterizedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgJavaParameterizedType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgJavaParameterizedType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaParameterizedType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaQualifiedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgJavaQualifiedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgJavaQualifiedType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgJavaQualifiedType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaQualifiedType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaWildcardType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgJavaWildcardType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgJavaWildcardType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgJavaWildcardType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaWildcardType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaTaskType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaTaskType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaTaskType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaProtectedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaProtectedType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaProtectedType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaFormalType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaFormalType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaFormalType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaFormalType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaFormalType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDiscriminatedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaDiscriminatedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaDiscriminatedType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaDiscriminatedType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaDiscriminatedType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgScopedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgScopedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgScopedType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgScopedType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
case 2: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgScopedType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else if (child == p_declaration) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgModifierType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_base_type);
return traversalSuccessorContainer;
}
vector<string>
SgModifierType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_base_type");
return traversalSuccessorContainer;
}
size_t
SgModifierType::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgModifierType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_base_type == NULL || p_base_type != NULL); return p_base_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgModifierType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_base_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_return_type);
traversalSuccessorContainer.push_back(p_orig_return_type);
return traversalSuccessorContainer;
}
vector<string>
SgFunctionType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_return_type");
traversalSuccessorContainer.push_back("p_orig_return_type");
return traversalSuccessorContainer;
}
size_t
SgFunctionType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgFunctionType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_return_type == NULL || p_return_type != NULL); return p_return_type;
case 2: ROSE_ASSERT(p_orig_return_type == NULL || p_orig_return_type != NULL); return p_orig_return_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFunctionType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_return_type) return 1;
else if (child == p_orig_return_type) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgMemberFunctionType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_return_type);
traversalSuccessorContainer.push_back(p_orig_return_type);
return traversalSuccessorContainer;
}
vector<string>
SgMemberFunctionType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_return_type");
traversalSuccessorContainer.push_back("p_orig_return_type");
return traversalSuccessorContainer;
}
size_t
SgMemberFunctionType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgMemberFunctionType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_return_type == NULL || p_return_type != NULL); return p_return_type;
case 2: ROSE_ASSERT(p_orig_return_type == NULL || p_orig_return_type != NULL); return p_orig_return_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMemberFunctionType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_return_type) return 1;
else if (child == p_orig_return_type) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgPartialFunctionType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_return_type);
traversalSuccessorContainer.push_back(p_orig_return_type);
return traversalSuccessorContainer;
}
vector<string>
SgPartialFunctionType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_return_type");
traversalSuccessorContainer.push_back("p_orig_return_type");
return traversalSuccessorContainer;
}
size_t
SgPartialFunctionType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgPartialFunctionType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_return_type == NULL || p_return_type != NULL); return p_return_type;
case 2: ROSE_ASSERT(p_orig_return_type == NULL || p_orig_return_type != NULL); return p_orig_return_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPartialFunctionType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_return_type) return 1;
else if (child == p_orig_return_type) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgPartialFunctionModifierType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_return_type);
traversalSuccessorContainer.push_back(p_orig_return_type);
traversalSuccessorContainer.push_back(p_builtin_type);
return traversalSuccessorContainer;
}
vector<string>
SgPartialFunctionModifierType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_return_type");
traversalSuccessorContainer.push_back("p_orig_return_type");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgPartialFunctionModifierType::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgPartialFunctionModifierType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_return_type == NULL || p_return_type != NULL); return p_return_type;
case 2: ROSE_ASSERT(p_orig_return_type == NULL || p_orig_return_type != NULL); return p_orig_return_type;
case 3: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPartialFunctionModifierType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_return_type) return 1;
else if (child == p_orig_return_type) return 2;
else if (child == p_builtin_type) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgArrayType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_index);
traversalSuccessorContainer.push_back(p_dim_info);
return traversalSuccessorContainer;
}
vector<string>
SgArrayType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_index");
traversalSuccessorContainer.push_back("p_dim_info");
return traversalSuccessorContainer;
}
size_t
SgArrayType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgArrayType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_index == NULL || p_index != NULL); return p_index;
case 2: ROSE_ASSERT(p_dim_info == NULL || p_dim_info != NULL); return p_dim_info;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgArrayType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_index) return 1;
else if (child == p_dim_info) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeEllipse::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeEllipse::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeEllipse::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeEllipse::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeEllipse::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_class_type);
traversalSuccessorContainer.push_back(p_parent_class_type);
traversalSuccessorContainer.push_back(p_template_parameter);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_class_type");
traversalSuccessorContainer.push_back("p_parent_class_type");
traversalSuccessorContainer.push_back("p_template_parameter");
return traversalSuccessorContainer;
}
size_t
SgTemplateType::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgTemplateType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_class_type == NULL || p_class_type != NULL); return p_class_type;
case 2: ROSE_ASSERT(p_parent_class_type == NULL || p_parent_class_type != NULL); return p_parent_class_type;
case 3: ROSE_ASSERT(p_template_parameter == NULL || p_template_parameter != NULL); return p_template_parameter;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_class_type) return 1;
else if (child == p_parent_class_type) return 2;
else if (child == p_template_parameter) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgQualifiedNameType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgQualifiedNameType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgQualifiedNameType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgQualifiedNameType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgQualifiedNameType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeComplex::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgTypeComplex::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgTypeComplex::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTypeComplex::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeComplex::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeImaginary::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgTypeImaginary::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgTypeImaginary::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTypeImaginary::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeImaginary::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeDefault::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeDefault::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeDefault::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeDefault::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeDefault::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeCAFTeam::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeCAFTeam::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeCAFTeam::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeCAFTeam::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeCAFTeam::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeCrayPointer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeCrayPointer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeCrayPointer::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeCrayPointer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeCrayPointer::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeLabel::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeLabel::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeLabel::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeLabel::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeLabel::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaUnionType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgJavaUnionType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgJavaUnionType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJavaUnionType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaUnionType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgRvalueReferenceType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgRvalueReferenceType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgRvalueReferenceType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgRvalueReferenceType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRvalueReferenceType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeNullptr::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeNullptr::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeNullptr::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeNullptr::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeNullptr::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDeclType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgDeclType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgDeclType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgDeclType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDeclType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeOfType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgTypeOfType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgTypeOfType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTypeOfType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeOfType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeMatrix::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeMatrix::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeMatrix::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeMatrix::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeMatrix::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeTuple::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeTuple::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeTuple::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeTuple::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeTuple::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeChar16::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeChar16::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeChar16::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeChar16::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeChar16::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeChar32::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeChar32::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeChar32::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeChar32::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeChar32::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeFloat128::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgTypeFloat128::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgTypeFloat128::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTypeFloat128::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeFloat128::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeFixed::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_scale);
traversalSuccessorContainer.push_back(p_fraction);
return traversalSuccessorContainer;
}
vector<string>
SgTypeFixed::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_scale");
traversalSuccessorContainer.push_back("p_fraction");
return traversalSuccessorContainer;
}
size_t
SgTypeFixed::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgTypeFixed::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_scale == NULL || p_scale != NULL); return p_scale;
case 2: ROSE_ASSERT(p_fraction == NULL || p_fraction != NULL); return p_fraction;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeFixed::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_scale) return 1;
else if (child == p_fraction) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAutoType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgAutoType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgAutoType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAutoType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAutoType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaAccessType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_base_type);
return traversalSuccessorContainer;
}
vector<string>
SgAdaAccessType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_base_type");
return traversalSuccessorContainer;
}
size_t
SgAdaAccessType::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaAccessType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_base_type == NULL || p_base_type != NULL); return p_base_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaAccessType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_base_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaSubtype::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_base_type);
traversalSuccessorContainer.push_back(p_constraint);
return traversalSuccessorContainer;
}
vector<string>
SgAdaSubtype::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_base_type");
traversalSuccessorContainer.push_back("p_constraint");
return traversalSuccessorContainer;
}
size_t
SgAdaSubtype::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaSubtype::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_base_type == NULL || p_base_type != NULL); return p_base_type;
case 2: ROSE_ASSERT(p_constraint == NULL || p_constraint != NULL); return p_constraint;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaSubtype::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_base_type) return 1;
else if (child == p_constraint) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDiscreteType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
  // suppress handling of builtin_type date members 
return traversalSuccessorContainer;
}
vector<string>
SgAdaDiscreteType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_builtin_type");
return traversalSuccessorContainer;
}
size_t
SgAdaDiscreteType::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaDiscreteType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_builtin_type == NULL || p_builtin_type != NULL); return p_builtin_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaDiscreteType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_builtin_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaModularType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_modexpr);
return traversalSuccessorContainer;
}
vector<string>
SgAdaModularType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_modexpr");
return traversalSuccessorContainer;
}
size_t
SgAdaModularType::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaModularType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_modexpr == NULL || p_modexpr != NULL); return p_modexpr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaModularType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_modexpr) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDerivedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_base_type);
return traversalSuccessorContainer;
}
vector<string>
SgAdaDerivedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_base_type");
return traversalSuccessorContainer;
}
size_t
SgAdaDerivedType::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaDerivedType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_base_type == NULL || p_base_type != NULL); return p_base_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaDerivedType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_base_type) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaSubroutineType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_type_kind);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_return_type);
return traversalSuccessorContainer;
}
vector<string>
SgAdaSubroutineType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_return_type");
return traversalSuccessorContainer;
}
size_t
SgAdaSubroutineType::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaSubroutineType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
case 1: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 2: ROSE_ASSERT(p_return_type == NULL || p_return_type != NULL); return p_return_type;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaSubroutineType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else if (child == p_parameterList) return 1;
else if (child == p_return_type) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgJovialBitType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgJovialBitType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgJovialBitType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJovialBitType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJovialBitType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgRangeType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_type_kind);
return traversalSuccessorContainer;
}
vector<string>
SgRangeType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_type_kind");
return traversalSuccessorContainer;
}
size_t
SgRangeType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgRangeType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_type_kind == NULL || p_type_kind != NULL); return p_type_kind;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRangeType::get_childIndex(SgNode *child) const {
if (child == p_type_kind) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgLocatedNode::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgLocatedNode::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgLocatedNode::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNode" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgLocatedNode::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgLocatedNode::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgToken::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgToken::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgToken::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgToken::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgToken" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgToken::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgToken" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLocatedNodeSupport::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNodeSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgLocatedNodeSupport::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNodeSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgLocatedNodeSupport::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNodeSupport" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgLocatedNodeSupport::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNodeSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgLocatedNodeSupport::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgLocatedNodeSupport" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgCommonBlockObject::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variable_reference_list);
return traversalSuccessorContainer;
}
vector<string>
SgCommonBlockObject::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variable_reference_list");
return traversalSuccessorContainer;
}
size_t
SgCommonBlockObject::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgCommonBlockObject::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variable_reference_list == NULL || p_variable_reference_list != NULL); return p_variable_reference_list;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCommonBlockObject::get_childIndex(SgNode *child) const {
if (child == p_variable_reference_list) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgInitializedName::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_initptr);
return traversalSuccessorContainer;
}
vector<string>
SgInitializedName::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_initptr");
return traversalSuccessorContainer;
}
size_t
SgInitializedName::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgInitializedName::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_initptr == NULL || p_initptr != NULL); return p_initptr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgInitializedName::get_childIndex(SgNode *child) const {
if (child == p_initptr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgInterfaceBody::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgInterfaceBody::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgInterfaceBody::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgInterfaceBody::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgInterfaceBody" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgInterfaceBody::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgInterfaceBody" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgHeaderFileBody::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgHeaderFileBody::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgHeaderFileBody::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgHeaderFileBody::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgHeaderFileBody" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgHeaderFileBody::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgHeaderFileBody" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgRenamePair::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgRenamePair::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgRenamePair::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgRenamePair::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgRenamePair" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgRenamePair::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgRenamePair" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaMemberValuePair::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_value);
return traversalSuccessorContainer;
}
vector<string>
SgJavaMemberValuePair::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_value");
return traversalSuccessorContainer;
}
size_t
SgJavaMemberValuePair::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJavaMemberValuePair::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_value == NULL || p_value != NULL); return p_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaMemberValuePair::get_childIndex(SgNode *child) const {
if (child == p_value) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpClause::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgOmpClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgOmpClause::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClause" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgOmpClause::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgOmpClause::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgOmpNowaitClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpNowaitClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpNowaitClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpNowaitClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpNowaitClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpNowaitClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpNowaitClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpBeginClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpBeginClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpBeginClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpBeginClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpBeginClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpBeginClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpBeginClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpEndClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpEndClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpEndClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpEndClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpEndClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpEndClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpEndClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpUntiedClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpUntiedClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpUntiedClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpUntiedClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpUntiedClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpUntiedClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpUntiedClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpDefaultClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpDefaultClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpDefaultClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpDefaultClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpDefaultClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpDefaultClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpDefaultClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpAtomicClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpAtomicClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpAtomicClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpAtomicClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpAtomicClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpAtomicClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpAtomicClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpProcBindClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpProcBindClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpProcBindClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpProcBindClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpProcBindClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpProcBindClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpProcBindClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpExpressionClause::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpExpressionClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgOmpExpressionClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpExpressionClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgOmpExpressionClause::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpExpressionClause" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgOmpExpressionClause::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpExpressionClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgOmpExpressionClause::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpExpressionClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgOmpOrderedClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpOrderedClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpOrderedClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpOrderedClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpOrderedClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpCollapseClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpCollapseClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpCollapseClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpCollapseClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpCollapseClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpIfClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpIfClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpIfClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpIfClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpIfClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpNumThreadsClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpNumThreadsClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpNumThreadsClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpNumThreadsClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpNumThreadsClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpDeviceClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpDeviceClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpDeviceClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpDeviceClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpDeviceClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpSafelenClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpSafelenClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpSafelenClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpSafelenClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpSafelenClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpSimdlenClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpSimdlenClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpSimdlenClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpSimdlenClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpSimdlenClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpFinalClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpFinalClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpFinalClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpFinalClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpFinalClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpPriorityClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgOmpPriorityClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgOmpPriorityClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpPriorityClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpPriorityClause::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpInbranchClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpInbranchClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpInbranchClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpInbranchClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpInbranchClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpInbranchClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpInbranchClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpNotinbranchClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpNotinbranchClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpNotinbranchClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpNotinbranchClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpNotinbranchClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpNotinbranchClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpNotinbranchClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpVariablesClause::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpVariablesClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgOmpVariablesClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpVariablesClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgOmpVariablesClause::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpVariablesClause" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgOmpVariablesClause::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpVariablesClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgOmpVariablesClause::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpVariablesClause" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgOmpCopyprivateClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpCopyprivateClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpCopyprivateClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpCopyprivateClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpCopyprivateClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpPrivateClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpPrivateClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpPrivateClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpPrivateClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpPrivateClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpFirstprivateClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpFirstprivateClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpFirstprivateClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpFirstprivateClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpFirstprivateClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpSharedClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpSharedClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpSharedClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpSharedClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpSharedClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpCopyinClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpCopyinClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpCopyinClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpCopyinClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpCopyinClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpLastprivateClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpLastprivateClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpLastprivateClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpLastprivateClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpLastprivateClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpReductionClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpReductionClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpReductionClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpReductionClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpReductionClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpMapClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpMapClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpMapClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpMapClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpMapClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpUniformClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpUniformClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpUniformClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpUniformClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpUniformClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpAlignedClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_variables);
traversalSuccessorContainer.push_back(p_alignment);
return traversalSuccessorContainer;
}
vector<string>
SgOmpAlignedClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
traversalSuccessorContainer.push_back("p_alignment");
return traversalSuccessorContainer;
}
size_t
SgOmpAlignedClause::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgOmpAlignedClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
case 1: ROSE_ASSERT(p_alignment == NULL || p_alignment != NULL); return p_alignment;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpAlignedClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else if (child == p_alignment) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpLinearClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_variables);
traversalSuccessorContainer.push_back(p_step);
return traversalSuccessorContainer;
}
vector<string>
SgOmpLinearClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
traversalSuccessorContainer.push_back("p_step");
return traversalSuccessorContainer;
}
size_t
SgOmpLinearClause::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgOmpLinearClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
case 1: ROSE_ASSERT(p_step == NULL || p_step != NULL); return p_step;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpLinearClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else if (child == p_step) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpDependClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variables);
return traversalSuccessorContainer;
}
vector<string>
SgOmpDependClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variables");
return traversalSuccessorContainer;
}
size_t
SgOmpDependClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpDependClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variables == NULL || p_variables != NULL); return p_variables;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpDependClause::get_childIndex(SgNode *child) const {
if (child == p_variables) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpScheduleClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_chunk_size);
return traversalSuccessorContainer;
}
vector<string>
SgOmpScheduleClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_chunk_size");
return traversalSuccessorContainer;
}
size_t
SgOmpScheduleClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpScheduleClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_chunk_size == NULL || p_chunk_size != NULL); return p_chunk_size;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpScheduleClause::get_childIndex(SgNode *child) const {
if (child == p_chunk_size) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpMergeableClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpMergeableClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpMergeableClause::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpMergeableClause::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpMergeableClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpMergeableClause::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpMergeableClause" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLambdaCapture::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_capture_variable);
traversalSuccessorContainer.push_back(p_source_closure_variable);
traversalSuccessorContainer.push_back(p_closure_variable);
return traversalSuccessorContainer;
}
vector<string>
SgLambdaCapture::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_capture_variable");
traversalSuccessorContainer.push_back("p_source_closure_variable");
traversalSuccessorContainer.push_back("p_closure_variable");
return traversalSuccessorContainer;
}
size_t
SgLambdaCapture::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgLambdaCapture::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_capture_variable == NULL || p_capture_variable != NULL); return p_capture_variable;
case 1: ROSE_ASSERT(p_source_closure_variable == NULL || p_source_closure_variable != NULL); return p_source_closure_variable;
case 2: ROSE_ASSERT(p_closure_variable == NULL || p_closure_variable != NULL); return p_closure_variable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLambdaCapture::get_childIndex(SgNode *child) const {
if (child == p_capture_variable) return 0;
else if (child == p_source_closure_variable) return 1;
else if (child == p_closure_variable) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgLambdaCaptureList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_capture_list.size() + 0);
   {
     SgLambdaCapturePtrList::const_iterator iter;
     for (iter = p_capture_list.begin(); iter != p_capture_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgLambdaCaptureList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgLambdaCapturePtrList::const_iterator  iter;
     for (iter = p_capture_list.begin(); iter != p_capture_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgLambdaCaptureList::get_numberOfTraversalSuccessors() const {
return p_capture_list.size() + 0;
}
SgNode *
SgLambdaCaptureList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_capture_list.size());
return p_capture_list[idx];
}
size_t
SgLambdaCaptureList::get_childIndex(SgNode *child) const {
SgLambdaCapturePtrList::const_iterator itr = find(p_capture_list.begin(), p_capture_list.end(), child);
if (itr != p_capture_list.end()) return itr - p_capture_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTypeConstraint::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAdaTypeConstraint" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAdaTypeConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAdaTypeConstraint" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAdaTypeConstraint::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAdaTypeConstraint" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAdaTypeConstraint::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAdaTypeConstraint" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAdaTypeConstraint::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAdaTypeConstraint" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAdaRangeConstraint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_range);
return traversalSuccessorContainer;
}
vector<string>
SgAdaRangeConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_range");
return traversalSuccessorContainer;
}
size_t
SgAdaRangeConstraint::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaRangeConstraint::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_range == NULL || p_range != NULL); return p_range;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaRangeConstraint::get_childIndex(SgNode *child) const {
if (child == p_range) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaIndexConstraint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_indexRanges.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_indexRanges.begin(); iter != p_indexRanges.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaIndexConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_indexRanges.begin(); iter != p_indexRanges.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaIndexConstraint::get_numberOfTraversalSuccessors() const {
return p_indexRanges.size() + 0;
}
SgNode *
SgAdaIndexConstraint::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_indexRanges.size());
return p_indexRanges[idx];
}
size_t
SgAdaIndexConstraint::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_indexRanges.begin(), p_indexRanges.end(), child);
if (itr != p_indexRanges.end()) return itr - p_indexRanges.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDigitsConstraint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_digits);
traversalSuccessorContainer.push_back(p_subConstraint);
return traversalSuccessorContainer;
}
vector<string>
SgAdaDigitsConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_digits");
traversalSuccessorContainer.push_back("p_subConstraint");
return traversalSuccessorContainer;
}
size_t
SgAdaDigitsConstraint::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaDigitsConstraint::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_digits == NULL || p_digits != NULL); return p_digits;
case 1: ROSE_ASSERT(p_subConstraint == NULL || p_subConstraint != NULL); return p_subConstraint;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaDigitsConstraint::get_childIndex(SgNode *child) const {
if (child == p_digits) return 0;
else if (child == p_subConstraint) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDeltaConstraint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_delta);
traversalSuccessorContainer.push_back(p_subConstraint);
return traversalSuccessorContainer;
}
vector<string>
SgAdaDeltaConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_delta");
traversalSuccessorContainer.push_back("p_subConstraint");
return traversalSuccessorContainer;
}
size_t
SgAdaDeltaConstraint::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaDeltaConstraint::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_delta == NULL || p_delta != NULL); return p_delta;
case 1: ROSE_ASSERT(p_subConstraint == NULL || p_subConstraint != NULL); return p_subConstraint;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaDeltaConstraint::get_childIndex(SgNode *child) const {
if (child == p_delta) return 0;
else if (child == p_subConstraint) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDiscriminantConstraint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_discriminants.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_discriminants.begin(); iter != p_discriminants.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaDiscriminantConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_discriminants.begin(); iter != p_discriminants.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaDiscriminantConstraint::get_numberOfTraversalSuccessors() const {
return p_discriminants.size() + 0;
}
SgNode *
SgAdaDiscriminantConstraint::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_discriminants.size());
return p_discriminants[idx];
}
size_t
SgAdaDiscriminantConstraint::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_discriminants.begin(), p_discriminants.end(), child);
if (itr != p_discriminants.end()) return itr - p_discriminants.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaNullConstraint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaNullConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaNullConstraint::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaNullConstraint::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaNullConstraint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaNullConstraint::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaNullConstraint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgScopeStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgScopeStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgScopeStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgScopeStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgScopeStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgScopeStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgScopeStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgScopeStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgScopeStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgScopeStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgGlobal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_declarations.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgGlobal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgGlobal::get_numberOfTraversalSuccessors() const {
return p_declarations.size() + 0;
}
SgNode *
SgGlobal::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_declarations.size());
return p_declarations[idx];
}
size_t
SgGlobal::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_declarations.begin(), p_declarations.end(), child);
if (itr != p_declarations.end()) return itr - p_declarations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgBasicBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_statements.size() + 0);
   {
     SgStatementPtrList::const_iterator iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgBasicBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgStatementPtrList::const_iterator  iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgBasicBlock::get_numberOfTraversalSuccessors() const {
return p_statements.size() + 0;
}
SgNode *
SgBasicBlock::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_statements.size());
return p_statements[idx];
}
size_t
SgBasicBlock::get_childIndex(SgNode *child) const {
SgStatementPtrList::const_iterator itr = find(p_statements.begin(), p_statements.end(), child);
if (itr != p_statements.end()) return itr - p_statements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgIfStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_conditional);
traversalSuccessorContainer.push_back(p_true_body);
traversalSuccessorContainer.push_back(p_false_body);
return traversalSuccessorContainer;
}
vector<string>
SgIfStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_conditional");
traversalSuccessorContainer.push_back("p_true_body");
traversalSuccessorContainer.push_back("p_false_body");
return traversalSuccessorContainer;
}
size_t
SgIfStmt::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgIfStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_conditional == NULL || p_conditional != NULL); return p_conditional;
case 1: ROSE_ASSERT(p_true_body == NULL || p_true_body != NULL); return p_true_body;
case 2: ROSE_ASSERT(p_false_body == NULL || p_false_body != NULL); return p_false_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIfStmt::get_childIndex(SgNode *child) const {
if (child == p_conditional) return 0;
else if (child == p_true_body) return 1;
else if (child == p_false_body) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgForStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_for_init_stmt);
traversalSuccessorContainer.push_back(p_test);
traversalSuccessorContainer.push_back(p_increment);
traversalSuccessorContainer.push_back(p_loop_body);
traversalSuccessorContainer.push_back(p_else_body);
return traversalSuccessorContainer;
}
vector<string>
SgForStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_for_init_stmt");
traversalSuccessorContainer.push_back("p_test");
traversalSuccessorContainer.push_back("p_increment");
traversalSuccessorContainer.push_back("p_loop_body");
traversalSuccessorContainer.push_back("p_else_body");
return traversalSuccessorContainer;
}
size_t
SgForStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgForStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_for_init_stmt == NULL || p_for_init_stmt != NULL); return p_for_init_stmt;
case 1: ROSE_ASSERT(p_test == NULL || p_test != NULL); return p_test;
case 2: ROSE_ASSERT(p_increment == NULL || p_increment != NULL); return p_increment;
case 3: ROSE_ASSERT(p_loop_body == NULL || p_loop_body != NULL); return p_loop_body;
case 4: ROSE_ASSERT(p_else_body == NULL || p_else_body != NULL); return p_else_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgForStatement::get_childIndex(SgNode *child) const {
if (child == p_for_init_stmt) return 0;
else if (child == p_test) return 1;
else if (child == p_increment) return 2;
else if (child == p_loop_body) return 3;
else if (child == p_else_body) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionDefinition::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgFunctionDefinition::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgFunctionDefinition::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgFunctionDefinition::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFunctionDefinition::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateFunctionDefinition::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateFunctionDefinition::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgTemplateFunctionDefinition::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateFunctionDefinition::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateFunctionDefinition::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgClassDefinition::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_members.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_members.begin(); iter != p_members.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgClassDefinition::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_members.begin(); iter != p_members.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgClassDefinition::get_numberOfTraversalSuccessors() const {
return p_members.size() + 0;
}
SgNode *
SgClassDefinition::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_members.size());
return p_members[idx];
}
size_t
SgClassDefinition::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_members.begin(), p_members.end(), child);
if (itr != p_members.end()) return itr - p_members.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateInstantiationDefn::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_members.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_members.begin(); iter != p_members.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgTemplateInstantiationDefn::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_members.begin(); iter != p_members.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgTemplateInstantiationDefn::get_numberOfTraversalSuccessors() const {
return p_members.size() + 0;
}
SgNode *
SgTemplateInstantiationDefn::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_members.size());
return p_members[idx];
}
size_t
SgTemplateInstantiationDefn::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_members.begin(), p_members.end(), child);
if (itr != p_members.end()) return itr - p_members.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateClassDefinition::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_members.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_members.begin(); iter != p_members.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgTemplateClassDefinition::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_members.begin(); iter != p_members.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgTemplateClassDefinition::get_numberOfTraversalSuccessors() const {
return p_members.size() + 0;
}
SgNode *
SgTemplateClassDefinition::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_members.size());
return p_members[idx];
}
size_t
SgTemplateClassDefinition::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_members.begin(), p_members.end(), child);
if (itr != p_members.end()) return itr - p_members.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgWhileStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_condition);
traversalSuccessorContainer.push_back(p_body);
traversalSuccessorContainer.push_back(p_else_body);
return traversalSuccessorContainer;
}
vector<string>
SgWhileStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_condition");
traversalSuccessorContainer.push_back("p_body");
traversalSuccessorContainer.push_back("p_else_body");
return traversalSuccessorContainer;
}
size_t
SgWhileStmt::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgWhileStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_condition == NULL || p_condition != NULL); return p_condition;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
case 2: ROSE_ASSERT(p_else_body == NULL || p_else_body != NULL); return p_else_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgWhileStmt::get_childIndex(SgNode *child) const {
if (child == p_condition) return 0;
else if (child == p_body) return 1;
else if (child == p_else_body) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgDoWhileStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_body);
traversalSuccessorContainer.push_back(p_condition);
return traversalSuccessorContainer;
}
vector<string>
SgDoWhileStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
traversalSuccessorContainer.push_back("p_condition");
return traversalSuccessorContainer;
}
size_t
SgDoWhileStmt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDoWhileStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
case 1: ROSE_ASSERT(p_condition == NULL || p_condition != NULL); return p_condition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDoWhileStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else if (child == p_condition) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgSwitchStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_item_selector);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgSwitchStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_item_selector");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgSwitchStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgSwitchStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_item_selector == NULL || p_item_selector != NULL); return p_item_selector;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSwitchStatement::get_childIndex(SgNode *child) const {
if (child == p_item_selector) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgCatchOptionStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_condition);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgCatchOptionStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_condition");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgCatchOptionStmt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgCatchOptionStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_condition == NULL || p_condition != NULL); return p_condition;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCatchOptionStmt::get_childIndex(SgNode *child) const {
if (child == p_condition) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgNamespaceDefinitionStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_declarations.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgNamespaceDefinitionStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgNamespaceDefinitionStatement::get_numberOfTraversalSuccessors() const {
return p_declarations.size() + 0;
}
SgNode *
SgNamespaceDefinitionStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_declarations.size());
return p_declarations[idx];
}
size_t
SgNamespaceDefinitionStatement::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_declarations.begin(), p_declarations.end(), child);
if (itr != p_declarations.end()) return itr - p_declarations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgBlockDataStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgBlockDataStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgBlockDataStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgBlockDataStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgBlockDataStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgBlockDataStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgBlockDataStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAssociateStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAssociateStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAssociateStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAssociateStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAssociateStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgFortranDo::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_initialization);
traversalSuccessorContainer.push_back(p_bound);
traversalSuccessorContainer.push_back(p_increment);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgFortranDo::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_initialization");
traversalSuccessorContainer.push_back("p_bound");
traversalSuccessorContainer.push_back("p_increment");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgFortranDo::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgFortranDo::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_initialization == NULL || p_initialization != NULL); return p_initialization;
case 1: ROSE_ASSERT(p_bound == NULL || p_bound != NULL); return p_bound;
case 2: ROSE_ASSERT(p_increment == NULL || p_increment != NULL); return p_increment;
case 3: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFortranDo::get_childIndex(SgNode *child) const {
if (child == p_initialization) return 0;
else if (child == p_bound) return 1;
else if (child == p_increment) return 2;
else if (child == p_body) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgFortranNonblockedDo::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_initialization);
traversalSuccessorContainer.push_back(p_bound);
traversalSuccessorContainer.push_back(p_increment);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgFortranNonblockedDo::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_initialization");
traversalSuccessorContainer.push_back("p_bound");
traversalSuccessorContainer.push_back("p_increment");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgFortranNonblockedDo::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgFortranNonblockedDo::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_initialization == NULL || p_initialization != NULL); return p_initialization;
case 1: ROSE_ASSERT(p_bound == NULL || p_bound != NULL); return p_bound;
case 2: ROSE_ASSERT(p_increment == NULL || p_increment != NULL); return p_increment;
case 3: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFortranNonblockedDo::get_childIndex(SgNode *child) const {
if (child == p_initialization) return 0;
else if (child == p_bound) return 1;
else if (child == p_increment) return 2;
else if (child == p_body) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgForAllStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_forall_header);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgForAllStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_forall_header");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgForAllStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgForAllStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_forall_header == NULL || p_forall_header != NULL); return p_forall_header;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgForAllStatement::get_childIndex(SgNode *child) const {
if (child == p_forall_header) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcForAllStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_for_init_stmt);
traversalSuccessorContainer.push_back(p_test);
traversalSuccessorContainer.push_back(p_increment);
traversalSuccessorContainer.push_back(p_affinity);
traversalSuccessorContainer.push_back(p_loop_body);
return traversalSuccessorContainer;
}
vector<string>
SgUpcForAllStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_for_init_stmt");
traversalSuccessorContainer.push_back("p_test");
traversalSuccessorContainer.push_back("p_increment");
traversalSuccessorContainer.push_back("p_affinity");
traversalSuccessorContainer.push_back("p_loop_body");
return traversalSuccessorContainer;
}
size_t
SgUpcForAllStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgUpcForAllStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_for_init_stmt == NULL || p_for_init_stmt != NULL); return p_for_init_stmt;
case 1: ROSE_ASSERT(p_test == NULL || p_test != NULL); return p_test;
case 2: ROSE_ASSERT(p_increment == NULL || p_increment != NULL); return p_increment;
case 3: ROSE_ASSERT(p_affinity == NULL || p_affinity != NULL); return p_affinity;
case 4: ROSE_ASSERT(p_loop_body == NULL || p_loop_body != NULL); return p_loop_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUpcForAllStatement::get_childIndex(SgNode *child) const {
if (child == p_for_init_stmt) return 0;
else if (child == p_test) return 1;
else if (child == p_increment) return 2;
else if (child == p_affinity) return 3;
else if (child == p_loop_body) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgCAFWithTeamStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgCAFWithTeamStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgCAFWithTeamStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgCAFWithTeamStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCAFWithTeamStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaForEachStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_element);
traversalSuccessorContainer.push_back(p_collection);
traversalSuccessorContainer.push_back(p_loop_body);
return traversalSuccessorContainer;
}
vector<string>
SgJavaForEachStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_element");
traversalSuccessorContainer.push_back("p_collection");
traversalSuccessorContainer.push_back("p_loop_body");
return traversalSuccessorContainer;
}
size_t
SgJavaForEachStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgJavaForEachStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_element == NULL || p_element != NULL); return p_element;
case 1: ROSE_ASSERT(p_collection == NULL || p_collection != NULL); return p_collection;
case 2: ROSE_ASSERT(p_loop_body == NULL || p_loop_body != NULL); return p_loop_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaForEachStatement::get_childIndex(SgNode *child) const {
if (child == p_element) return 0;
else if (child == p_collection) return 1;
else if (child == p_loop_body) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaLabelStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_statement);
return traversalSuccessorContainer;
}
vector<string>
SgJavaLabelStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_statement");
return traversalSuccessorContainer;
}
size_t
SgJavaLabelStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJavaLabelStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_statement == NULL || p_statement != NULL); return p_statement;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaLabelStatement::get_childIndex(SgNode *child) const {
if (child == p_statement) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgMatlabForStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_index);
traversalSuccessorContainer.push_back(p_range);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgMatlabForStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_index");
traversalSuccessorContainer.push_back("p_range");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgMatlabForStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgMatlabForStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_index == NULL || p_index != NULL); return p_index;
case 1: ROSE_ASSERT(p_range == NULL || p_range != NULL); return p_range;
case 2: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMatlabForStatement::get_childIndex(SgNode *child) const {
if (child == p_index) return 0;
else if (child == p_range) return 1;
else if (child == p_body) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionParameterScope::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_declarations.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgFunctionParameterScope::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgFunctionParameterScope::get_numberOfTraversalSuccessors() const {
return p_declarations.size() + 0;
}
SgNode *
SgFunctionParameterScope::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_declarations.size());
return p_declarations[idx];
}
size_t
SgFunctionParameterScope::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_declarations.begin(), p_declarations.end(), child);
if (itr != p_declarations.end()) return itr - p_declarations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgDeclarationScope::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDeclarationScope::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDeclarationScope::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDeclarationScope::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDeclarationScope" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDeclarationScope::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDeclarationScope" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgRangeBasedForStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(7);
traversalSuccessorContainer.push_back(p_iterator_declaration);
traversalSuccessorContainer.push_back(p_range_declaration);
traversalSuccessorContainer.push_back(p_begin_declaration);
traversalSuccessorContainer.push_back(p_end_declaration);
traversalSuccessorContainer.push_back(p_not_equal_expression);
traversalSuccessorContainer.push_back(p_increment_expression);
traversalSuccessorContainer.push_back(p_loop_body);
return traversalSuccessorContainer;
}
vector<string>
SgRangeBasedForStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_iterator_declaration");
traversalSuccessorContainer.push_back("p_range_declaration");
traversalSuccessorContainer.push_back("p_begin_declaration");
traversalSuccessorContainer.push_back("p_end_declaration");
traversalSuccessorContainer.push_back("p_not_equal_expression");
traversalSuccessorContainer.push_back("p_increment_expression");
traversalSuccessorContainer.push_back("p_loop_body");
return traversalSuccessorContainer;
}
size_t
SgRangeBasedForStatement::get_numberOfTraversalSuccessors() const {
return 7;
}
SgNode *
SgRangeBasedForStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_iterator_declaration == NULL || p_iterator_declaration != NULL); return p_iterator_declaration;
case 1: ROSE_ASSERT(p_range_declaration == NULL || p_range_declaration != NULL); return p_range_declaration;
case 2: ROSE_ASSERT(p_begin_declaration == NULL || p_begin_declaration != NULL); return p_begin_declaration;
case 3: ROSE_ASSERT(p_end_declaration == NULL || p_end_declaration != NULL); return p_end_declaration;
case 4: ROSE_ASSERT(p_not_equal_expression == NULL || p_not_equal_expression != NULL); return p_not_equal_expression;
case 5: ROSE_ASSERT(p_increment_expression == NULL || p_increment_expression != NULL); return p_increment_expression;
case 6: ROSE_ASSERT(p_loop_body == NULL || p_loop_body != NULL); return p_loop_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRangeBasedForStatement::get_childIndex(SgNode *child) const {
if (child == p_iterator_declaration) return 0;
else if (child == p_range_declaration) return 1;
else if (child == p_begin_declaration) return 2;
else if (child == p_end_declaration) return 3;
else if (child == p_not_equal_expression) return 4;
else if (child == p_increment_expression) return 5;
else if (child == p_loop_body) return 6;
else return (size_t) -1;
}
vector<SgNode*>
SgJovialForThenStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_initialization);
traversalSuccessorContainer.push_back(p_while_expression);
traversalSuccessorContainer.push_back(p_by_or_then_expression);
traversalSuccessorContainer.push_back(p_loop_body);
return traversalSuccessorContainer;
}
vector<string>
SgJovialForThenStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_initialization");
traversalSuccessorContainer.push_back("p_while_expression");
traversalSuccessorContainer.push_back("p_by_or_then_expression");
traversalSuccessorContainer.push_back("p_loop_body");
return traversalSuccessorContainer;
}
size_t
SgJovialForThenStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgJovialForThenStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_initialization == NULL || p_initialization != NULL); return p_initialization;
case 1: ROSE_ASSERT(p_while_expression == NULL || p_while_expression != NULL); return p_while_expression;
case 2: ROSE_ASSERT(p_by_or_then_expression == NULL || p_by_or_then_expression != NULL); return p_by_or_then_expression;
case 3: ROSE_ASSERT(p_loop_body == NULL || p_loop_body != NULL); return p_loop_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJovialForThenStatement::get_childIndex(SgNode *child) const {
if (child == p_initialization) return 0;
else if (child == p_while_expression) return 1;
else if (child == p_by_or_then_expression) return 2;
else if (child == p_loop_body) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaAcceptStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_entry);
traversalSuccessorContainer.push_back(p_index);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAdaAcceptStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_entry");
traversalSuccessorContainer.push_back("p_index");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAdaAcceptStmt::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgAdaAcceptStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_entry == NULL || p_entry != NULL); return p_entry;
case 2: ROSE_ASSERT(p_index == NULL || p_index != NULL); return p_index;
case 3: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaAcceptStmt::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_entry) return 1;
else if (child == p_index) return 2;
else if (child == p_body) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaPackageSpec::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_declarations.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaPackageSpec::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaPackageSpec::get_numberOfTraversalSuccessors() const {
return p_declarations.size() + 0;
}
SgNode *
SgAdaPackageSpec::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_declarations.size());
return p_declarations[idx];
}
size_t
SgAdaPackageSpec::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_declarations.begin(), p_declarations.end(), child);
if (itr != p_declarations.end()) return itr - p_declarations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaPackageBody::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_statements.size() + 0);
   {
     SgStatementPtrList::const_iterator iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaPackageBody::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgStatementPtrList::const_iterator  iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaPackageBody::get_numberOfTraversalSuccessors() const {
return p_statements.size() + 0;
}
SgNode *
SgAdaPackageBody::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_statements.size());
return p_statements[idx];
}
size_t
SgAdaPackageBody::get_childIndex(SgNode *child) const {
SgStatementPtrList::const_iterator itr = find(p_statements.begin(), p_statements.end(), child);
if (itr != p_statements.end()) return itr - p_statements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskSpec::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_declarations.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskSpec::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaTaskSpec::get_numberOfTraversalSuccessors() const {
return p_declarations.size() + 0;
}
SgNode *
SgAdaTaskSpec::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_declarations.size());
return p_declarations[idx];
}
size_t
SgAdaTaskSpec::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_declarations.begin(), p_declarations.end(), child);
if (itr != p_declarations.end()) return itr - p_declarations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskBody::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_statements.size() + 0);
   {
     SgStatementPtrList::const_iterator iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskBody::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgStatementPtrList::const_iterator  iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaTaskBody::get_numberOfTraversalSuccessors() const {
return p_statements.size() + 0;
}
SgNode *
SgAdaTaskBody::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_statements.size());
return p_statements[idx];
}
size_t
SgAdaTaskBody::get_childIndex(SgNode *child) const {
SgStatementPtrList::const_iterator itr = find(p_statements.begin(), p_statements.end(), child);
if (itr != p_statements.end()) return itr - p_statements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaProtectedBody::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_statements.size() + 0);
   {
     SgStatementPtrList::const_iterator iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedBody::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgStatementPtrList::const_iterator  iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedBody::get_numberOfTraversalSuccessors() const {
return p_statements.size() + 0;
}
SgNode *
SgAdaProtectedBody::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_statements.size());
return p_statements[idx];
}
size_t
SgAdaProtectedBody::get_childIndex(SgNode *child) const {
SgStatementPtrList::const_iterator itr = find(p_statements.begin(), p_statements.end(), child);
if (itr != p_statements.end()) return itr - p_statements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaProtectedSpec::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_declarations.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedSpec::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedSpec::get_numberOfTraversalSuccessors() const {
return p_declarations.size() + 0;
}
SgNode *
SgAdaProtectedSpec::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_declarations.size());
return p_declarations[idx];
}
size_t
SgAdaProtectedSpec::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_declarations.begin(), p_declarations.end(), child);
if (itr != p_declarations.end()) return itr - p_declarations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaGenericDefn::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_declarations.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaGenericDefn::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_declarations.begin(); iter != p_declarations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaGenericDefn::get_numberOfTraversalSuccessors() const {
return p_declarations.size() + 0;
}
SgNode *
SgAdaGenericDefn::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_declarations.size());
return p_declarations[idx];
}
size_t
SgAdaGenericDefn::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_declarations.begin(), p_declarations.end(), child);
if (itr != p_declarations.end()) return itr - p_declarations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionTypeTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFunctionTypeTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFunctionTypeTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFunctionTypeTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFunctionTypeTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFunctionTypeTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFunctionTypeTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgDeclarationStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgDeclarationStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgDeclarationStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgDeclarationStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgDeclarationStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgDeclarationStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgFunctionParameterList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_args.size() + 0);
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_args.begin(); iter != p_args.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgFunctionParameterList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_args.begin(); iter != p_args.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgFunctionParameterList::get_numberOfTraversalSuccessors() const {
return p_args.size() + 0;
}
SgNode *
SgFunctionParameterList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_args.size());
return p_args[idx];
}
size_t
SgFunctionParameterList::get_childIndex(SgNode *child) const {
SgInitializedNamePtrList::const_iterator itr = find(p_args.begin(), p_args.end(), child);
if (itr != p_args.end()) return itr - p_args.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgVariableDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_variables.size() + 1);
traversalSuccessorContainer.push_back(compute_baseTypeDefiningDeclaration());
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgVariableDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_baseTypeDefiningDeclaration");
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgVariableDeclaration::get_numberOfTraversalSuccessors() const {
return p_variables.size() + 1;
}
SgNode *
SgVariableDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return compute_baseTypeDefiningDeclaration();
else return p_variables[idx-1];
}
size_t
SgVariableDeclaration::get_childIndex(SgNode *child) const {
if (child == compute_baseTypeDefiningDeclaration()) return 0;
else {
SgInitializedNamePtrList::const_iterator itr = find(p_variables.begin(), p_variables.end(), child);
if (itr != p_variables.end()) return (itr - p_variables.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgTemplateVariableDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_variables.size() + 1);
traversalSuccessorContainer.push_back(compute_baseTypeDefiningDeclaration());
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgTemplateVariableDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_baseTypeDefiningDeclaration");
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgTemplateVariableDeclaration::get_numberOfTraversalSuccessors() const {
return p_variables.size() + 1;
}
SgNode *
SgTemplateVariableDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return compute_baseTypeDefiningDeclaration();
else return p_variables[idx-1];
}
size_t
SgTemplateVariableDeclaration::get_childIndex(SgNode *child) const {
if (child == compute_baseTypeDefiningDeclaration()) return 0;
else {
SgInitializedNamePtrList::const_iterator itr = find(p_variables.begin(), p_variables.end(), child);
if (itr != p_variables.end()) return (itr - p_variables.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgTemplateVariableInstantiation::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_variables.size() + 1);
traversalSuccessorContainer.push_back(compute_baseTypeDefiningDeclaration());
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgTemplateVariableInstantiation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_baseTypeDefiningDeclaration");
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgTemplateVariableInstantiation::get_numberOfTraversalSuccessors() const {
return p_variables.size() + 1;
}
SgNode *
SgTemplateVariableInstantiation::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return compute_baseTypeDefiningDeclaration();
else return p_variables[idx-1];
}
size_t
SgTemplateVariableInstantiation::get_childIndex(SgNode *child) const {
if (child == compute_baseTypeDefiningDeclaration()) return 0;
else {
SgInitializedNamePtrList::const_iterator itr = find(p_variables.begin(), p_variables.end(), child);
if (itr != p_variables.end()) return (itr - p_variables.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgVariableDefinition::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_vardefn);
traversalSuccessorContainer.push_back(p_bitfield);
return traversalSuccessorContainer;
}
vector<string>
SgVariableDefinition::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_vardefn");
traversalSuccessorContainer.push_back("p_bitfield");
return traversalSuccessorContainer;
}
size_t
SgVariableDefinition::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgVariableDefinition::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_vardefn == NULL || p_vardefn != NULL); return p_vardefn;
case 1: ROSE_ASSERT(p_bitfield == NULL || p_bitfield != NULL); return p_bitfield;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgVariableDefinition::get_childIndex(SgNode *child) const {
if (child == p_vardefn) return 0;
else if (child == p_bitfield) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgClinkageDeclarationStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgClinkageDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgClinkageDeclarationStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgClinkageDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgClinkageDeclarationStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgClinkageDeclarationStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgClinkageDeclarationStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgClinkageDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgClinkageDeclarationStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgClinkageDeclarationStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgClinkageStartStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgClinkageStartStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgClinkageStartStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgClinkageStartStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgClinkageStartStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgClinkageStartStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgClinkageStartStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgClinkageEndStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgClinkageEndStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgClinkageEndStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgClinkageEndStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgClinkageEndStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgClinkageEndStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgClinkageEndStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgEnumDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_enumerators.size() + 0);
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_enumerators.begin(); iter != p_enumerators.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgEnumDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_enumerators.begin(); iter != p_enumerators.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgEnumDeclaration::get_numberOfTraversalSuccessors() const {
return p_enumerators.size() + 0;
}
SgNode *
SgEnumDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_enumerators.size());
return p_enumerators[idx];
}
size_t
SgEnumDeclaration::get_childIndex(SgNode *child) const {
SgInitializedNamePtrList::const_iterator itr = find(p_enumerators.begin(), p_enumerators.end(), child);
if (itr != p_enumerators.end()) return itr - p_enumerators.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_operands.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmStmt::get_numberOfTraversalSuccessors() const {
return p_operands.size() + 0;
}
SgNode *
SgAsmStmt::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_operands.size());
return p_operands[idx];
}
size_t
SgAsmStmt::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_operands.begin(), p_operands.end(), child);
if (itr != p_operands.end()) return itr - p_operands.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAttributeSpecificationStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAttributeSpecificationStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAttributeSpecificationStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAttributeSpecificationStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAttributeSpecificationStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAttributeSpecificationStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAttributeSpecificationStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFormatStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFormatStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFormatStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFormatStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFormatStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFormatStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFormatStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTemplateDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTemplateDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTemplateDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTemplateDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTemplateDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTemplateDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateInstantiationDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateInstantiationDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateInstantiationDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateInstantiationDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateInstantiationDirectiveStatement::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUseStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_rename_list.size() + 0);
   {
     SgRenamePairPtrList::const_iterator iter;
     for (iter = p_rename_list.begin(); iter != p_rename_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgUseStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgRenamePairPtrList::const_iterator  iter;
     for (iter = p_rename_list.begin(); iter != p_rename_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgUseStatement::get_numberOfTraversalSuccessors() const {
return p_rename_list.size() + 0;
}
SgNode *
SgUseStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_rename_list.size());
return p_rename_list[idx];
}
size_t
SgUseStatement::get_childIndex(SgNode *child) const {
SgRenamePairPtrList::const_iterator itr = find(p_rename_list.begin(), p_rename_list.end(), child);
if (itr != p_rename_list.end()) return itr - p_rename_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgParameterStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgParameterStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgParameterStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgParameterStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgParameterStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgParameterStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgParameterStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgNamespaceDeclarationStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgNamespaceDeclarationStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgNamespaceDeclarationStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgNamespaceDeclarationStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNamespaceDeclarationStatement::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgEquivalenceStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgEquivalenceStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgEquivalenceStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgEquivalenceStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgEquivalenceStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgEquivalenceStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgEquivalenceStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgInterfaceStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_interface_body_list.size() + 0);
   {
     SgInterfaceBodyPtrList::const_iterator iter;
     for (iter = p_interface_body_list.begin(); iter != p_interface_body_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgInterfaceStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgInterfaceBodyPtrList::const_iterator  iter;
     for (iter = p_interface_body_list.begin(); iter != p_interface_body_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgInterfaceStatement::get_numberOfTraversalSuccessors() const {
return p_interface_body_list.size() + 0;
}
SgNode *
SgInterfaceStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_interface_body_list.size());
return p_interface_body_list[idx];
}
size_t
SgInterfaceStatement::get_childIndex(SgNode *child) const {
SgInterfaceBodyPtrList::const_iterator itr = find(p_interface_body_list.begin(), p_interface_body_list.end(), child);
if (itr != p_interface_body_list.end()) return itr - p_interface_body_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgNamespaceAliasDeclarationStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNamespaceAliasDeclarationStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNamespaceAliasDeclarationStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNamespaceAliasDeclarationStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNamespaceAliasDeclarationStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNamespaceAliasDeclarationStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNamespaceAliasDeclarationStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgCommonBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_block_list.size() + 0);
   {
     SgCommonBlockObjectPtrList::const_iterator iter;
     for (iter = p_block_list.begin(); iter != p_block_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgCommonBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgCommonBlockObjectPtrList::const_iterator  iter;
     for (iter = p_block_list.begin(); iter != p_block_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgCommonBlock::get_numberOfTraversalSuccessors() const {
return p_block_list.size() + 0;
}
SgNode *
SgCommonBlock::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_block_list.size());
return p_block_list[idx];
}
size_t
SgCommonBlock::get_childIndex(SgNode *child) const {
SgCommonBlockObjectPtrList::const_iterator itr = find(p_block_list.begin(), p_block_list.end(), child);
if (itr != p_block_list.end()) return itr - p_block_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgTypedefDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(compute_baseTypeDefiningDeclaration());
return traversalSuccessorContainer;
}
vector<string>
SgTypedefDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTypedefDeclaration::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTypedefDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: return compute_baseTypeDefiningDeclaration();
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypedefDeclaration::get_childIndex(SgNode *child) const {
if (child == compute_baseTypeDefiningDeclaration()) return 0;
else if (child == p_declaration) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateTypedefDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateTypedefDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateTypedefDeclaration::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateTypedefDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateTypedefDeclaration::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateInstantiationTypedefDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateInstantiationTypedefDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateInstantiationTypedefDeclaration::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateInstantiationTypedefDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateInstantiationTypedefDeclaration::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgStatementFunctionStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_function);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgStatementFunctionStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_function");
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgStatementFunctionStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgStatementFunctionStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_function == NULL || p_function != NULL); return p_function;
case 1: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgStatementFunctionStatement::get_childIndex(SgNode *child) const {
if (child == p_function) return 0;
else if (child == p_expression) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgCtorInitializerList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_ctors.size() + 0);
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_ctors.begin(); iter != p_ctors.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgCtorInitializerList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_ctors.begin(); iter != p_ctors.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgCtorInitializerList::get_numberOfTraversalSuccessors() const {
return p_ctors.size() + 0;
}
SgNode *
SgCtorInitializerList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_ctors.size());
return p_ctors[idx];
}
size_t
SgCtorInitializerList::get_childIndex(SgNode *child) const {
SgInitializedNamePtrList::const_iterator itr = find(p_ctors.begin(), p_ctors.end(), child);
if (itr != p_ctors.end()) return itr - p_ctors.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgPragmaDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_pragma);
return traversalSuccessorContainer;
}
vector<string>
SgPragmaDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_pragma");
return traversalSuccessorContainer;
}
size_t
SgPragmaDeclaration::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgPragmaDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_pragma == NULL || p_pragma != NULL); return p_pragma;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPragmaDeclaration::get_childIndex(SgNode *child) const {
if (child == p_pragma) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUsingDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUsingDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUsingDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUsingDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUsingDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUsingDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUsingDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgClassDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(compute_classDefinition());
traversalSuccessorContainer.push_back(p_decoratorList);
return traversalSuccessorContainer;
}
vector<string>
SgClassDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_decoratorList");
return traversalSuccessorContainer;
}
size_t
SgClassDeclaration::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgClassDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: return compute_classDefinition();
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgClassDeclaration::get_childIndex(SgNode *child) const {
if (child == compute_classDefinition()) return 0;
else if (child == p_decoratorList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateClassDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_decoratorList);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateClassDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_decoratorList");
return traversalSuccessorContainer;
}
size_t
SgTemplateClassDeclaration::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTemplateClassDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateClassDeclaration::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else if (child == p_decoratorList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateInstantiationDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(compute_classDefinition());
traversalSuccessorContainer.push_back(p_decoratorList);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateInstantiationDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_decoratorList");
return traversalSuccessorContainer;
}
size_t
SgTemplateInstantiationDecl::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgTemplateInstantiationDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: return compute_classDefinition();
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateInstantiationDecl::get_childIndex(SgNode *child) const {
if (child == compute_classDefinition()) return 0;
else if (child == p_decoratorList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDerivedTypeStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_decoratorList);
return traversalSuccessorContainer;
}
vector<string>
SgDerivedTypeStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_decoratorList");
return traversalSuccessorContainer;
}
size_t
SgDerivedTypeStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDerivedTypeStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDerivedTypeStatement::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else if (child == p_decoratorList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgModuleStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_decoratorList);
return traversalSuccessorContainer;
}
vector<string>
SgModuleStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_decoratorList");
return traversalSuccessorContainer;
}
size_t
SgModuleStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgModuleStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgModuleStatement::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else if (child == p_decoratorList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaPackageDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_decoratorList);
return traversalSuccessorContainer;
}
vector<string>
SgJavaPackageDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_decoratorList");
return traversalSuccessorContainer;
}
size_t
SgJavaPackageDeclaration::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJavaPackageDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaPackageDeclaration::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else if (child == p_decoratorList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgJovialTableStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_decoratorList);
return traversalSuccessorContainer;
}
vector<string>
SgJovialTableStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_decoratorList");
return traversalSuccessorContainer;
}
size_t
SgJovialTableStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJovialTableStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJovialTableStatement::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else if (child == p_decoratorList) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgImplicitStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_variables.size() + 0);
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgImplicitStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgImplicitStatement::get_numberOfTraversalSuccessors() const {
return p_variables.size() + 0;
}
SgNode *
SgImplicitStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_variables.size());
return p_variables[idx];
}
size_t
SgImplicitStatement::get_childIndex(SgNode *child) const {
SgInitializedNamePtrList::const_iterator itr = find(p_variables.begin(), p_variables.end(), child);
if (itr != p_variables.end()) return itr - p_variables.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgUsingDeclarationStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUsingDeclarationStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUsingDeclarationStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUsingDeclarationStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUsingDeclarationStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUsingDeclarationStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUsingDeclarationStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgNamelistStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNamelistStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNamelistStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNamelistStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNamelistStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNamelistStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNamelistStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgImportStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgImportStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgImportStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgImportStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgImportStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgImportStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgImportStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFunctionDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgFunctionDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgFunctionDeclaration::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgFunctionDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFunctionDeclaration::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateFunctionDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateFunctionDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgTemplateFunctionDeclaration::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgTemplateFunctionDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateFunctionDeclaration::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgMemberFunctionDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_CtorInitializerList);
return traversalSuccessorContainer;
}
vector<string>
SgMemberFunctionDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_CtorInitializerList");
return traversalSuccessorContainer;
}
size_t
SgMemberFunctionDeclaration::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgMemberFunctionDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 3: ROSE_ASSERT(p_CtorInitializerList == NULL || p_CtorInitializerList != NULL); return p_CtorInitializerList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMemberFunctionDeclaration::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else if (child == p_CtorInitializerList) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateMemberFunctionDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_CtorInitializerList);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateMemberFunctionDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_CtorInitializerList");
return traversalSuccessorContainer;
}
size_t
SgTemplateMemberFunctionDeclaration::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgTemplateMemberFunctionDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 3: ROSE_ASSERT(p_CtorInitializerList == NULL || p_CtorInitializerList != NULL); return p_CtorInitializerList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateMemberFunctionDeclaration::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else if (child == p_CtorInitializerList) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateInstantiationMemberFunctionDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_CtorInitializerList);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateInstantiationMemberFunctionDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_CtorInitializerList");
return traversalSuccessorContainer;
}
size_t
SgTemplateInstantiationMemberFunctionDecl::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgTemplateInstantiationMemberFunctionDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 3: ROSE_ASSERT(p_CtorInitializerList == NULL || p_CtorInitializerList != NULL); return p_CtorInitializerList;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateInstantiationMemberFunctionDecl::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else if (child == p_CtorInitializerList) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateInstantiationFunctionDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateInstantiationFunctionDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgTemplateInstantiationFunctionDecl::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgTemplateInstantiationFunctionDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateInstantiationFunctionDecl::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgProgramHeaderStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgProgramHeaderStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgProgramHeaderStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgProgramHeaderStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgProgramHeaderStatement::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgProcedureHeaderStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_result_name);
return traversalSuccessorContainer;
}
vector<string>
SgProcedureHeaderStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_result_name");
return traversalSuccessorContainer;
}
size_t
SgProcedureHeaderStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgProcedureHeaderStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 3: ROSE_ASSERT(p_result_name == NULL || p_result_name != NULL); return p_result_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgProcedureHeaderStatement::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else if (child == p_result_name) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgEntryStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_result_name);
return traversalSuccessorContainer;
}
vector<string>
SgEntryStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_result_name");
return traversalSuccessorContainer;
}
size_t
SgEntryStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgEntryStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 3: ROSE_ASSERT(p_result_name == NULL || p_result_name != NULL); return p_result_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgEntryStatement::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else if (child == p_result_name) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaEntryDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_entryIndex);
traversalSuccessorContainer.push_back(p_entryBarrier);
return traversalSuccessorContainer;
}
vector<string>
SgAdaEntryDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_entryIndex");
traversalSuccessorContainer.push_back("p_entryBarrier");
return traversalSuccessorContainer;
}
size_t
SgAdaEntryDecl::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgAdaEntryDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 3: ROSE_ASSERT(p_entryIndex == NULL || p_entryIndex != NULL); return p_entryIndex;
case 4: ROSE_ASSERT(p_entryBarrier == NULL || p_entryBarrier != NULL); return p_entryBarrier;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaEntryDecl::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else if (child == p_entryIndex) return 3;
else if (child == p_entryBarrier) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaFunctionRenamingDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_parameterList);
traversalSuccessorContainer.push_back(p_decoratorList);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_renamed_function);
return traversalSuccessorContainer;
}
vector<string>
SgAdaFunctionRenamingDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameterList");
traversalSuccessorContainer.push_back("p_decoratorList");
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_renamed_function");
return traversalSuccessorContainer;
}
size_t
SgAdaFunctionRenamingDecl::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgAdaFunctionRenamingDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameterList == NULL || p_parameterList != NULL); return p_parameterList;
case 1: ROSE_ASSERT(p_decoratorList == NULL || p_decoratorList != NULL); return p_decoratorList;
case 2: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 3: ROSE_ASSERT(p_renamed_function == NULL || p_renamed_function != NULL); return p_renamed_function;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaFunctionRenamingDecl::get_childIndex(SgNode *child) const {
if (child == p_parameterList) return 0;
else if (child == p_decoratorList) return 1;
else if (child == p_definition) return 2;
else if (child == p_renamed_function) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgContainsStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgContainsStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgContainsStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgContainsStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgContainsStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgContainsStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgContainsStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgC_PreprocessorDirectiveStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgC_PreprocessorDirectiveStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgC_PreprocessorDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgC_PreprocessorDirectiveStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgC_PreprocessorDirectiveStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgC_PreprocessorDirectiveStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgC_PreprocessorDirectiveStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgC_PreprocessorDirectiveStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgC_PreprocessorDirectiveStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgC_PreprocessorDirectiveStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgIncludeDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_headerFileBody);
return traversalSuccessorContainer;
}
vector<string>
SgIncludeDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_headerFileBody");
return traversalSuccessorContainer;
}
size_t
SgIncludeDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgIncludeDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_headerFileBody == NULL || p_headerFileBody != NULL); return p_headerFileBody;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIncludeDirectiveStatement::get_childIndex(SgNode *child) const {
if (child == p_headerFileBody) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgDefineDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDefineDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDefineDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDefineDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDefineDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDefineDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDefineDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUndefDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUndefDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUndefDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUndefDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUndefDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUndefDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUndefDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIfdefDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIfdefDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIfdefDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIfdefDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIfdefDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIfdefDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIfdefDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIfndefDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIfndefDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIfndefDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIfndefDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIfndefDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIfndefDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIfndefDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIfDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIfDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIfDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIfDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIfDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIfDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIfDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgDeadIfDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDeadIfDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDeadIfDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDeadIfDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDeadIfDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDeadIfDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDeadIfDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgElseDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgElseDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgElseDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgElseDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgElseDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgElseDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgElseDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgElseifDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgElseifDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgElseifDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgElseifDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgElseifDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgElseifDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgElseifDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgEndifDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgEndifDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgEndifDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgEndifDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgEndifDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgEndifDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgEndifDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLineDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgLineDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgLineDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgLineDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgLineDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgLineDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgLineDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgWarningDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgWarningDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgWarningDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgWarningDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgWarningDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgWarningDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgWarningDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgErrorDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgErrorDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgErrorDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgErrorDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgErrorDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgErrorDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgErrorDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgEmptyDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgEmptyDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgEmptyDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgEmptyDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgEmptyDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgEmptyDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgEmptyDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIncludeNextDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIncludeNextDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIncludeNextDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIncludeNextDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIncludeNextDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIncludeNextDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIncludeNextDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIdentDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIdentDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIdentDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIdentDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIdentDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIdentDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIdentDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLinemarkerDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgLinemarkerDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgLinemarkerDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgLinemarkerDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgLinemarkerDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgLinemarkerDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgLinemarkerDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpThreadprivateStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_variables.size() + 0);
   {
     SgVarRefExpPtrList::const_iterator iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpThreadprivateStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgVarRefExpPtrList::const_iterator  iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpThreadprivateStatement::get_numberOfTraversalSuccessors() const {
return p_variables.size() + 0;
}
SgNode *
SgOmpThreadprivateStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_variables.size());
return p_variables[idx];
}
size_t
SgOmpThreadprivateStatement::get_childIndex(SgNode *child) const {
SgVarRefExpPtrList::const_iterator itr = find(p_variables.begin(), p_variables.end(), child);
if (itr != p_variables.end()) return itr - p_variables.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgFortranIncludeLine::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFortranIncludeLine::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFortranIncludeLine::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFortranIncludeLine::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFortranIncludeLine" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFortranIncludeLine::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFortranIncludeLine" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaImportStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJavaImportStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJavaImportStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJavaImportStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJavaImportStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJavaImportStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJavaImportStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaPackageStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJavaPackageStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJavaPackageStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJavaPackageStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJavaPackageStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJavaPackageStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJavaPackageStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgStmtDeclarationStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_statement);
return traversalSuccessorContainer;
}
vector<string>
SgStmtDeclarationStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_statement");
return traversalSuccessorContainer;
}
size_t
SgStmtDeclarationStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgStmtDeclarationStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_statement == NULL || p_statement != NULL); return p_statement;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgStmtDeclarationStatement::get_childIndex(SgNode *child) const {
if (child == p_statement) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgStaticAssertionDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_condition);
return traversalSuccessorContainer;
}
vector<string>
SgStaticAssertionDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_condition");
return traversalSuccessorContainer;
}
size_t
SgStaticAssertionDeclaration::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgStaticAssertionDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_condition == NULL || p_condition != NULL); return p_condition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgStaticAssertionDeclaration::get_childIndex(SgNode *child) const {
if (child == p_condition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpDeclareSimdStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 0);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpDeclareSimdStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpDeclareSimdStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 0;
}
SgNode *
SgOmpDeclareSimdStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_clauses.size());
return p_clauses[idx];
}
size_t
SgOmpDeclareSimdStatement::get_childIndex(SgNode *child) const {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return itr - p_clauses.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgMicrosoftAttributeDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgMicrosoftAttributeDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgMicrosoftAttributeDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgMicrosoftAttributeDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgMicrosoftAttributeDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgMicrosoftAttributeDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgMicrosoftAttributeDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJovialCompoolStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJovialCompoolStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJovialCompoolStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJovialCompoolStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJovialCompoolStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJovialCompoolStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJovialCompoolStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJovialDirectiveStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJovialDirectiveStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJovialDirectiveStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJovialDirectiveStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJovialDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJovialDirectiveStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJovialDirectiveStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJovialDefineDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJovialDefineDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJovialDefineDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJovialDefineDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJovialDefineDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJovialDefineDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJovialDefineDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJovialLabelDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJovialLabelDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJovialLabelDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJovialLabelDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJovialLabelDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJovialLabelDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJovialLabelDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJovialOverlayDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_address);
traversalSuccessorContainer.push_back(p_overlay);
return traversalSuccessorContainer;
}
vector<string>
SgJovialOverlayDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_address");
traversalSuccessorContainer.push_back("p_overlay");
return traversalSuccessorContainer;
}
size_t
SgJovialOverlayDeclaration::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJovialOverlayDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_address == NULL || p_address != NULL); return p_address;
case 1: ROSE_ASSERT(p_overlay == NULL || p_overlay != NULL); return p_overlay;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJovialOverlayDeclaration::get_childIndex(SgNode *child) const {
if (child == p_address) return 0;
else if (child == p_overlay) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgNonrealDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNonrealDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNonrealDecl::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNonrealDecl::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNonrealDecl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNonrealDecl::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNonrealDecl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgEmptyDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgEmptyDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgEmptyDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgEmptyDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgEmptyDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgEmptyDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgEmptyDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAdaPackageBodyDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaPackageBodyDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaPackageBodyDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaPackageBodyDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaPackageBodyDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaPackageSpecDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaPackageSpecDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaPackageSpecDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaPackageSpecDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaPackageSpecDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaRenamingDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_renamed);
return traversalSuccessorContainer;
}
vector<string>
SgAdaRenamingDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_renamed");
return traversalSuccessorContainer;
}
size_t
SgAdaRenamingDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaRenamingDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_renamed == NULL || p_renamed != NULL); return p_renamed;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaRenamingDecl::get_childIndex(SgNode *child) const {
if (child == p_renamed) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskSpecDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskSpecDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaTaskSpecDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaTaskSpecDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaTaskSpecDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskBodyDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskBodyDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaTaskBodyDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaTaskBodyDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaTaskBodyDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskTypeDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskTypeDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaTaskTypeDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaTaskTypeDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaTaskTypeDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaProtectedSpecDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedSpecDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedSpecDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaProtectedSpecDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaProtectedSpecDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaProtectedBodyDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedBodyDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedBodyDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaProtectedBodyDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaProtectedBodyDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaProtectedTypeDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_definition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedTypeDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedTypeDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaProtectedTypeDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaProtectedTypeDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaRepresentationClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_alignment);
traversalSuccessorContainer.push_back(p_components);
return traversalSuccessorContainer;
}
vector<string>
SgAdaRepresentationClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_alignment");
traversalSuccessorContainer.push_back("p_components");
return traversalSuccessorContainer;
}
size_t
SgAdaRepresentationClause::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaRepresentationClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_alignment == NULL || p_alignment != NULL); return p_alignment;
case 1: ROSE_ASSERT(p_components == NULL || p_components != NULL); return p_components;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaRepresentationClause::get_childIndex(SgNode *child) const {
if (child == p_alignment) return 0;
else if (child == p_components) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaComponentClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_component);
traversalSuccessorContainer.push_back(p_offset);
traversalSuccessorContainer.push_back(p_range);
return traversalSuccessorContainer;
}
vector<string>
SgAdaComponentClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_component");
traversalSuccessorContainer.push_back("p_offset");
traversalSuccessorContainer.push_back("p_range");
return traversalSuccessorContainer;
}
size_t
SgAdaComponentClause::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaComponentClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_component == NULL || p_component != NULL); return p_component;
case 1: ROSE_ASSERT(p_offset == NULL || p_offset != NULL); return p_offset;
case 2: ROSE_ASSERT(p_range == NULL || p_range != NULL); return p_range;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaComponentClause::get_childIndex(SgNode *child) const {
if (child == p_component) return 0;
else if (child == p_offset) return 1;
else if (child == p_range) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaAttributeClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_attribute);
traversalSuccessorContainer.push_back(p_size);
return traversalSuccessorContainer;
}
vector<string>
SgAdaAttributeClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_attribute");
traversalSuccessorContainer.push_back("p_size");
return traversalSuccessorContainer;
}
size_t
SgAdaAttributeClause::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaAttributeClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_attribute == NULL || p_attribute != NULL); return p_attribute;
case 1: ROSE_ASSERT(p_size == NULL || p_size != NULL); return p_size;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaAttributeClause::get_childIndex(SgNode *child) const {
if (child == p_attribute) return 0;
else if (child == p_size) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaEnumRepresentationClause::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_components);
return traversalSuccessorContainer;
}
vector<string>
SgAdaEnumRepresentationClause::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_components");
return traversalSuccessorContainer;
}
size_t
SgAdaEnumRepresentationClause::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaEnumRepresentationClause::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_components == NULL || p_components != NULL); return p_components;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaEnumRepresentationClause::get_childIndex(SgNode *child) const {
if (child == p_components) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaGenericDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_definition);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaGenericDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_definition");
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaGenericDecl::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaGenericDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_definition == NULL || p_definition != NULL); return p_definition;
case 1: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaGenericDecl::get_childIndex(SgNode *child) const {
if (child == p_definition) return 0;
else if (child == p_declaration) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaFormalTypeDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_discriminants);
return traversalSuccessorContainer;
}
vector<string>
SgAdaFormalTypeDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_discriminants");
return traversalSuccessorContainer;
}
size_t
SgAdaFormalTypeDecl::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaFormalTypeDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_discriminants == NULL || p_discriminants != NULL); return p_discriminants;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaFormalTypeDecl::get_childIndex(SgNode *child) const {
if (child == p_discriminants) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDiscriminatedTypeDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_discriminants);
traversalSuccessorContainer.push_back(p_discriminatedDecl);
return traversalSuccessorContainer;
}
vector<string>
SgAdaDiscriminatedTypeDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_discriminants");
traversalSuccessorContainer.push_back("p_discriminatedDecl");
return traversalSuccessorContainer;
}
size_t
SgAdaDiscriminatedTypeDecl::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaDiscriminatedTypeDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_discriminants == NULL || p_discriminants != NULL); return p_discriminants;
case 1: ROSE_ASSERT(p_discriminatedDecl == NULL || p_discriminatedDecl != NULL); return p_discriminatedDecl;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaDiscriminatedTypeDecl::get_childIndex(SgNode *child) const {
if (child == p_discriminants) return 0;
else if (child == p_discriminatedDecl) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaGenericInstanceDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_instantiatedScope);
traversalSuccessorContainer.push_back(p_actual_parameters);
return traversalSuccessorContainer;
}
vector<string>
SgAdaGenericInstanceDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_instantiatedScope");
traversalSuccessorContainer.push_back("p_actual_parameters");
return traversalSuccessorContainer;
}
size_t
SgAdaGenericInstanceDecl::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaGenericInstanceDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_instantiatedScope == NULL || p_instantiatedScope != NULL); return p_instantiatedScope;
case 1: ROSE_ASSERT(p_actual_parameters == NULL || p_actual_parameters != NULL); return p_actual_parameters;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaGenericInstanceDecl::get_childIndex(SgNode *child) const {
if (child == p_instantiatedScope) return 0;
else if (child == p_actual_parameters) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaFormalPackageDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaFormalPackageDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaFormalPackageDecl::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaFormalPackageDecl::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaFormalPackageDecl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaFormalPackageDecl::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaFormalPackageDecl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAdaParameterList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_parameters.size() + 0);
   {
     SgDeclarationStatementPtrList::const_iterator iter;
     for (iter = p_parameters.begin(); iter != p_parameters.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaParameterList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgDeclarationStatementPtrList::const_iterator  iter;
     for (iter = p_parameters.begin(); iter != p_parameters.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaParameterList::get_numberOfTraversalSuccessors() const {
return p_parameters.size() + 0;
}
SgNode *
SgAdaParameterList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_parameters.size());
return p_parameters[idx];
}
size_t
SgAdaParameterList::get_childIndex(SgNode *child) const {
SgDeclarationStatementPtrList::const_iterator itr = find(p_parameters.begin(), p_parameters.end(), child);
if (itr != p_parameters.end()) return itr - p_parameters.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaVariantDecl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_discriminant);
traversalSuccessorContainer.push_back(p_variants);
return traversalSuccessorContainer;
}
vector<string>
SgAdaVariantDecl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_discriminant");
traversalSuccessorContainer.push_back("p_variants");
return traversalSuccessorContainer;
}
size_t
SgAdaVariantDecl::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaVariantDecl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_discriminant == NULL || p_discriminant != NULL); return p_discriminant;
case 1: ROSE_ASSERT(p_variants == NULL || p_variants != NULL); return p_variants;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaVariantDecl::get_childIndex(SgNode *child) const {
if (child == p_discriminant) return 0;
else if (child == p_variants) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgExprStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgExprStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgExprStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgExprStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgExprStatement::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgLabelStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_statement);
return traversalSuccessorContainer;
}
vector<string>
SgLabelStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_statement");
return traversalSuccessorContainer;
}
size_t
SgLabelStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgLabelStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_statement == NULL || p_statement != NULL); return p_statement;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLabelStatement::get_childIndex(SgNode *child) const {
if (child == p_statement) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgCaseOptionStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_key);
traversalSuccessorContainer.push_back(p_body);
traversalSuccessorContainer.push_back(p_key_range_end);
return traversalSuccessorContainer;
}
vector<string>
SgCaseOptionStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_key");
traversalSuccessorContainer.push_back("p_body");
traversalSuccessorContainer.push_back("p_key_range_end");
return traversalSuccessorContainer;
}
size_t
SgCaseOptionStmt::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgCaseOptionStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_key == NULL || p_key != NULL); return p_key;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
case 2: ROSE_ASSERT(p_key_range_end == NULL || p_key_range_end != NULL); return p_key_range_end;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCaseOptionStmt::get_childIndex(SgNode *child) const {
if (child == p_key) return 0;
else if (child == p_body) return 1;
else if (child == p_key_range_end) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgTryStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_body);
traversalSuccessorContainer.push_back(p_catch_statement_seq_root);
traversalSuccessorContainer.push_back(p_else_body);
traversalSuccessorContainer.push_back(p_finally_body);
return traversalSuccessorContainer;
}
vector<string>
SgTryStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
traversalSuccessorContainer.push_back("p_catch_statement_seq_root");
traversalSuccessorContainer.push_back("p_else_body");
traversalSuccessorContainer.push_back("p_finally_body");
return traversalSuccessorContainer;
}
size_t
SgTryStmt::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgTryStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
case 1: ROSE_ASSERT(p_catch_statement_seq_root == NULL || p_catch_statement_seq_root != NULL); return p_catch_statement_seq_root;
case 2: ROSE_ASSERT(p_else_body == NULL || p_else_body != NULL); return p_else_body;
case 3: ROSE_ASSERT(p_finally_body == NULL || p_finally_body != NULL); return p_finally_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTryStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else if (child == p_catch_statement_seq_root) return 1;
else if (child == p_else_body) return 2;
else if (child == p_finally_body) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgDefaultOptionStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgDefaultOptionStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgDefaultOptionStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgDefaultOptionStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDefaultOptionStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgBreakStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgBreakStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgBreakStmt::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgBreakStmt::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgBreakStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgBreakStmt::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgBreakStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgContinueStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgContinueStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgContinueStmt::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgContinueStmt::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgContinueStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgContinueStmt::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgContinueStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgReturnStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgReturnStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgReturnStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgReturnStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgReturnStmt::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgGotoStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgGotoStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgGotoStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgGotoStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgGotoStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgGotoStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgGotoStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgSpawnStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_the_func);
return traversalSuccessorContainer;
}
vector<string>
SgSpawnStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_the_func");
return traversalSuccessorContainer;
}
size_t
SgSpawnStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgSpawnStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_the_func == NULL || p_the_func != NULL); return p_the_func;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSpawnStmt::get_childIndex(SgNode *child) const {
if (child == p_the_func) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgNullStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNullStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNullStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNullStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNullStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNullStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNullStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgVariantStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgVariantStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgVariantStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgVariantStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgVariantStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgVariantStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgVariantStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgForInitStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_init_stmt.size() + 0);
   {
     SgStatementPtrList::const_iterator iter;
     for (iter = p_init_stmt.begin(); iter != p_init_stmt.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgForInitStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgStatementPtrList::const_iterator  iter;
     for (iter = p_init_stmt.begin(); iter != p_init_stmt.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgForInitStatement::get_numberOfTraversalSuccessors() const {
return p_init_stmt.size() + 0;
}
SgNode *
SgForInitStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_init_stmt.size());
return p_init_stmt[idx];
}
size_t
SgForInitStatement::get_childIndex(SgNode *child) const {
SgStatementPtrList::const_iterator itr = find(p_init_stmt.begin(), p_init_stmt.end(), child);
if (itr != p_init_stmt.end()) return itr - p_init_stmt.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgCatchStatementSeq::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_catch_statement_seq.size() + 0);
   {
     SgStatementPtrList::const_iterator iter;
     for (iter = p_catch_statement_seq.begin(); iter != p_catch_statement_seq.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgCatchStatementSeq::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgStatementPtrList::const_iterator  iter;
     for (iter = p_catch_statement_seq.begin(); iter != p_catch_statement_seq.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgCatchStatementSeq::get_numberOfTraversalSuccessors() const {
return p_catch_statement_seq.size() + 0;
}
SgNode *
SgCatchStatementSeq::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_catch_statement_seq.size());
return p_catch_statement_seq[idx];
}
size_t
SgCatchStatementSeq::get_childIndex(SgNode *child) const {
SgStatementPtrList::const_iterator itr = find(p_catch_statement_seq.begin(), p_catch_statement_seq.end(), child);
if (itr != p_catch_statement_seq.end()) return itr - p_catch_statement_seq.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgProcessControlStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_code);
traversalSuccessorContainer.push_back(p_quiet);
return traversalSuccessorContainer;
}
vector<string>
SgProcessControlStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_code");
traversalSuccessorContainer.push_back("p_quiet");
return traversalSuccessorContainer;
}
size_t
SgProcessControlStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgProcessControlStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_code == NULL || p_code != NULL); return p_code;
case 1: ROSE_ASSERT(p_quiet == NULL || p_quiet != NULL); return p_quiet;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgProcessControlStatement::get_childIndex(SgNode *child) const {
if (child == p_code) return 0;
else if (child == p_quiet) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgIOStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIOStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgIOStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIOStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgIOStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIOStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgIOStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIOStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgIOStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgIOStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgPrintStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(6);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
traversalSuccessorContainer.push_back(p_format);
return traversalSuccessorContainer;
}
vector<string>
SgPrintStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
traversalSuccessorContainer.push_back("p_format");
return traversalSuccessorContainer;
}
size_t
SgPrintStatement::get_numberOfTraversalSuccessors() const {
return 6;
}
SgNode *
SgPrintStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
case 5: ROSE_ASSERT(p_format == NULL || p_format != NULL); return p_format;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPrintStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else if (child == p_format) return 5;
else return (size_t) -1;
}
vector<SgNode*>
SgReadStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(21);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
traversalSuccessorContainer.push_back(p_format);
traversalSuccessorContainer.push_back(p_namelist);
traversalSuccessorContainer.push_back(p_advance);
traversalSuccessorContainer.push_back(p_asynchronous);
traversalSuccessorContainer.push_back(p_blank);
traversalSuccessorContainer.push_back(p_decimal);
traversalSuccessorContainer.push_back(p_delim);
traversalSuccessorContainer.push_back(p_end);
traversalSuccessorContainer.push_back(p_eor);
traversalSuccessorContainer.push_back(p_id);
traversalSuccessorContainer.push_back(p_pad);
traversalSuccessorContainer.push_back(p_pos);
traversalSuccessorContainer.push_back(p_rec);
traversalSuccessorContainer.push_back(p_round);
traversalSuccessorContainer.push_back(p_sign);
traversalSuccessorContainer.push_back(p_size);
return traversalSuccessorContainer;
}
vector<string>
SgReadStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
traversalSuccessorContainer.push_back("p_format");
traversalSuccessorContainer.push_back("p_namelist");
traversalSuccessorContainer.push_back("p_advance");
traversalSuccessorContainer.push_back("p_asynchronous");
traversalSuccessorContainer.push_back("p_blank");
traversalSuccessorContainer.push_back("p_decimal");
traversalSuccessorContainer.push_back("p_delim");
traversalSuccessorContainer.push_back("p_end");
traversalSuccessorContainer.push_back("p_eor");
traversalSuccessorContainer.push_back("p_id");
traversalSuccessorContainer.push_back("p_pad");
traversalSuccessorContainer.push_back("p_pos");
traversalSuccessorContainer.push_back("p_rec");
traversalSuccessorContainer.push_back("p_round");
traversalSuccessorContainer.push_back("p_sign");
traversalSuccessorContainer.push_back("p_size");
return traversalSuccessorContainer;
}
size_t
SgReadStatement::get_numberOfTraversalSuccessors() const {
return 21;
}
SgNode *
SgReadStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
case 5: ROSE_ASSERT(p_format == NULL || p_format != NULL); return p_format;
case 6: ROSE_ASSERT(p_namelist == NULL || p_namelist != NULL); return p_namelist;
case 7: ROSE_ASSERT(p_advance == NULL || p_advance != NULL); return p_advance;
case 8: ROSE_ASSERT(p_asynchronous == NULL || p_asynchronous != NULL); return p_asynchronous;
case 9: ROSE_ASSERT(p_blank == NULL || p_blank != NULL); return p_blank;
case 10: ROSE_ASSERT(p_decimal == NULL || p_decimal != NULL); return p_decimal;
case 11: ROSE_ASSERT(p_delim == NULL || p_delim != NULL); return p_delim;
case 12: ROSE_ASSERT(p_end == NULL || p_end != NULL); return p_end;
case 13: ROSE_ASSERT(p_eor == NULL || p_eor != NULL); return p_eor;
case 14: ROSE_ASSERT(p_id == NULL || p_id != NULL); return p_id;
case 15: ROSE_ASSERT(p_pad == NULL || p_pad != NULL); return p_pad;
case 16: ROSE_ASSERT(p_pos == NULL || p_pos != NULL); return p_pos;
case 17: ROSE_ASSERT(p_rec == NULL || p_rec != NULL); return p_rec;
case 18: ROSE_ASSERT(p_round == NULL || p_round != NULL); return p_round;
case 19: ROSE_ASSERT(p_sign == NULL || p_sign != NULL); return p_sign;
case 20: ROSE_ASSERT(p_size == NULL || p_size != NULL); return p_size;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgReadStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else if (child == p_format) return 5;
else if (child == p_namelist) return 6;
else if (child == p_advance) return 7;
else if (child == p_asynchronous) return 8;
else if (child == p_blank) return 9;
else if (child == p_decimal) return 10;
else if (child == p_delim) return 11;
else if (child == p_end) return 12;
else if (child == p_eor) return 13;
else if (child == p_id) return 14;
else if (child == p_pad) return 15;
else if (child == p_pos) return 16;
else if (child == p_rec) return 17;
else if (child == p_round) return 18;
else if (child == p_sign) return 19;
else if (child == p_size) return 20;
else return (size_t) -1;
}
vector<SgNode*>
SgWriteStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(21);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
traversalSuccessorContainer.push_back(p_format);
traversalSuccessorContainer.push_back(p_namelist);
traversalSuccessorContainer.push_back(p_advance);
traversalSuccessorContainer.push_back(p_asynchronous);
traversalSuccessorContainer.push_back(p_blank);
traversalSuccessorContainer.push_back(p_decimal);
traversalSuccessorContainer.push_back(p_delim);
traversalSuccessorContainer.push_back(p_end);
traversalSuccessorContainer.push_back(p_eor);
traversalSuccessorContainer.push_back(p_id);
traversalSuccessorContainer.push_back(p_pad);
traversalSuccessorContainer.push_back(p_pos);
traversalSuccessorContainer.push_back(p_rec);
traversalSuccessorContainer.push_back(p_round);
traversalSuccessorContainer.push_back(p_sign);
traversalSuccessorContainer.push_back(p_size);
return traversalSuccessorContainer;
}
vector<string>
SgWriteStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
traversalSuccessorContainer.push_back("p_format");
traversalSuccessorContainer.push_back("p_namelist");
traversalSuccessorContainer.push_back("p_advance");
traversalSuccessorContainer.push_back("p_asynchronous");
traversalSuccessorContainer.push_back("p_blank");
traversalSuccessorContainer.push_back("p_decimal");
traversalSuccessorContainer.push_back("p_delim");
traversalSuccessorContainer.push_back("p_end");
traversalSuccessorContainer.push_back("p_eor");
traversalSuccessorContainer.push_back("p_id");
traversalSuccessorContainer.push_back("p_pad");
traversalSuccessorContainer.push_back("p_pos");
traversalSuccessorContainer.push_back("p_rec");
traversalSuccessorContainer.push_back("p_round");
traversalSuccessorContainer.push_back("p_sign");
traversalSuccessorContainer.push_back("p_size");
return traversalSuccessorContainer;
}
size_t
SgWriteStatement::get_numberOfTraversalSuccessors() const {
return 21;
}
SgNode *
SgWriteStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
case 5: ROSE_ASSERT(p_format == NULL || p_format != NULL); return p_format;
case 6: ROSE_ASSERT(p_namelist == NULL || p_namelist != NULL); return p_namelist;
case 7: ROSE_ASSERT(p_advance == NULL || p_advance != NULL); return p_advance;
case 8: ROSE_ASSERT(p_asynchronous == NULL || p_asynchronous != NULL); return p_asynchronous;
case 9: ROSE_ASSERT(p_blank == NULL || p_blank != NULL); return p_blank;
case 10: ROSE_ASSERT(p_decimal == NULL || p_decimal != NULL); return p_decimal;
case 11: ROSE_ASSERT(p_delim == NULL || p_delim != NULL); return p_delim;
case 12: ROSE_ASSERT(p_end == NULL || p_end != NULL); return p_end;
case 13: ROSE_ASSERT(p_eor == NULL || p_eor != NULL); return p_eor;
case 14: ROSE_ASSERT(p_id == NULL || p_id != NULL); return p_id;
case 15: ROSE_ASSERT(p_pad == NULL || p_pad != NULL); return p_pad;
case 16: ROSE_ASSERT(p_pos == NULL || p_pos != NULL); return p_pos;
case 17: ROSE_ASSERT(p_rec == NULL || p_rec != NULL); return p_rec;
case 18: ROSE_ASSERT(p_round == NULL || p_round != NULL); return p_round;
case 19: ROSE_ASSERT(p_sign == NULL || p_sign != NULL); return p_sign;
case 20: ROSE_ASSERT(p_size == NULL || p_size != NULL); return p_size;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgWriteStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else if (child == p_format) return 5;
else if (child == p_namelist) return 6;
else if (child == p_advance) return 7;
else if (child == p_asynchronous) return 8;
else if (child == p_blank) return 9;
else if (child == p_decimal) return 10;
else if (child == p_delim) return 11;
else if (child == p_end) return 12;
else if (child == p_eor) return 13;
else if (child == p_id) return 14;
else if (child == p_pad) return 15;
else if (child == p_pos) return 16;
else if (child == p_rec) return 17;
else if (child == p_round) return 18;
else if (child == p_sign) return 19;
else if (child == p_size) return 20;
else return (size_t) -1;
}
vector<SgNode*>
SgOpenStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(18);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
traversalSuccessorContainer.push_back(p_file);
traversalSuccessorContainer.push_back(p_status);
traversalSuccessorContainer.push_back(p_access);
traversalSuccessorContainer.push_back(p_form);
traversalSuccessorContainer.push_back(p_recl);
traversalSuccessorContainer.push_back(p_blank);
traversalSuccessorContainer.push_back(p_position);
traversalSuccessorContainer.push_back(p_action);
traversalSuccessorContainer.push_back(p_delim);
traversalSuccessorContainer.push_back(p_pad);
traversalSuccessorContainer.push_back(p_round);
traversalSuccessorContainer.push_back(p_sign);
traversalSuccessorContainer.push_back(p_asynchronous);
return traversalSuccessorContainer;
}
vector<string>
SgOpenStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
traversalSuccessorContainer.push_back("p_file");
traversalSuccessorContainer.push_back("p_status");
traversalSuccessorContainer.push_back("p_access");
traversalSuccessorContainer.push_back("p_form");
traversalSuccessorContainer.push_back("p_recl");
traversalSuccessorContainer.push_back("p_blank");
traversalSuccessorContainer.push_back("p_position");
traversalSuccessorContainer.push_back("p_action");
traversalSuccessorContainer.push_back("p_delim");
traversalSuccessorContainer.push_back("p_pad");
traversalSuccessorContainer.push_back("p_round");
traversalSuccessorContainer.push_back("p_sign");
traversalSuccessorContainer.push_back("p_asynchronous");
return traversalSuccessorContainer;
}
size_t
SgOpenStatement::get_numberOfTraversalSuccessors() const {
return 18;
}
SgNode *
SgOpenStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
case 5: ROSE_ASSERT(p_file == NULL || p_file != NULL); return p_file;
case 6: ROSE_ASSERT(p_status == NULL || p_status != NULL); return p_status;
case 7: ROSE_ASSERT(p_access == NULL || p_access != NULL); return p_access;
case 8: ROSE_ASSERT(p_form == NULL || p_form != NULL); return p_form;
case 9: ROSE_ASSERT(p_recl == NULL || p_recl != NULL); return p_recl;
case 10: ROSE_ASSERT(p_blank == NULL || p_blank != NULL); return p_blank;
case 11: ROSE_ASSERT(p_position == NULL || p_position != NULL); return p_position;
case 12: ROSE_ASSERT(p_action == NULL || p_action != NULL); return p_action;
case 13: ROSE_ASSERT(p_delim == NULL || p_delim != NULL); return p_delim;
case 14: ROSE_ASSERT(p_pad == NULL || p_pad != NULL); return p_pad;
case 15: ROSE_ASSERT(p_round == NULL || p_round != NULL); return p_round;
case 16: ROSE_ASSERT(p_sign == NULL || p_sign != NULL); return p_sign;
case 17: ROSE_ASSERT(p_asynchronous == NULL || p_asynchronous != NULL); return p_asynchronous;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOpenStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else if (child == p_file) return 5;
else if (child == p_status) return 6;
else if (child == p_access) return 7;
else if (child == p_form) return 8;
else if (child == p_recl) return 9;
else if (child == p_blank) return 10;
else if (child == p_position) return 11;
else if (child == p_action) return 12;
else if (child == p_delim) return 13;
else if (child == p_pad) return 14;
else if (child == p_round) return 15;
else if (child == p_sign) return 16;
else if (child == p_asynchronous) return 17;
else return (size_t) -1;
}
vector<SgNode*>
SgCloseStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(6);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
traversalSuccessorContainer.push_back(p_status);
return traversalSuccessorContainer;
}
vector<string>
SgCloseStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
traversalSuccessorContainer.push_back("p_status");
return traversalSuccessorContainer;
}
size_t
SgCloseStatement::get_numberOfTraversalSuccessors() const {
return 6;
}
SgNode *
SgCloseStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
case 5: ROSE_ASSERT(p_status == NULL || p_status != NULL); return p_status;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCloseStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else if (child == p_status) return 5;
else return (size_t) -1;
}
vector<SgNode*>
SgInquireStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
return traversalSuccessorContainer;
}
vector<string>
SgInquireStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
return traversalSuccessorContainer;
}
size_t
SgInquireStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgInquireStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgInquireStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgFlushStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
return traversalSuccessorContainer;
}
vector<string>
SgFlushStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
return traversalSuccessorContainer;
}
size_t
SgFlushStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgFlushStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFlushStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgBackspaceStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
return traversalSuccessorContainer;
}
vector<string>
SgBackspaceStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
return traversalSuccessorContainer;
}
size_t
SgBackspaceStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgBackspaceStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBackspaceStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgRewindStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
return traversalSuccessorContainer;
}
vector<string>
SgRewindStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
return traversalSuccessorContainer;
}
size_t
SgRewindStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgRewindStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRewindStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgEndfileStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
return traversalSuccessorContainer;
}
vector<string>
SgEndfileStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
return traversalSuccessorContainer;
}
size_t
SgEndfileStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgEndfileStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgEndfileStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgWaitStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(5);
traversalSuccessorContainer.push_back(p_io_stmt_list);
traversalSuccessorContainer.push_back(p_unit);
traversalSuccessorContainer.push_back(p_iostat);
traversalSuccessorContainer.push_back(p_err);
traversalSuccessorContainer.push_back(p_iomsg);
return traversalSuccessorContainer;
}
vector<string>
SgWaitStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_stmt_list");
traversalSuccessorContainer.push_back("p_unit");
traversalSuccessorContainer.push_back("p_iostat");
traversalSuccessorContainer.push_back("p_err");
traversalSuccessorContainer.push_back("p_iomsg");
return traversalSuccessorContainer;
}
size_t
SgWaitStatement::get_numberOfTraversalSuccessors() const {
return 5;
}
SgNode *
SgWaitStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_stmt_list == NULL || p_io_stmt_list != NULL); return p_io_stmt_list;
case 1: ROSE_ASSERT(p_unit == NULL || p_unit != NULL); return p_unit;
case 2: ROSE_ASSERT(p_iostat == NULL || p_iostat != NULL); return p_iostat;
case 3: ROSE_ASSERT(p_err == NULL || p_err != NULL); return p_err;
case 4: ROSE_ASSERT(p_iomsg == NULL || p_iomsg != NULL); return p_iomsg;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgWaitStatement::get_childIndex(SgNode *child) const {
if (child == p_io_stmt_list) return 0;
else if (child == p_unit) return 1;
else if (child == p_iostat) return 2;
else if (child == p_err) return 3;
else if (child == p_iomsg) return 4;
else return (size_t) -1;
}
vector<SgNode*>
SgFortranContinueStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFortranContinueStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFortranContinueStmt::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFortranContinueStmt::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFortranContinueStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFortranContinueStmt::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFortranContinueStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgWhereStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_condition);
traversalSuccessorContainer.push_back(p_body);
traversalSuccessorContainer.push_back(p_elsewhere);
return traversalSuccessorContainer;
}
vector<string>
SgWhereStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_condition");
traversalSuccessorContainer.push_back("p_body");
traversalSuccessorContainer.push_back("p_elsewhere");
return traversalSuccessorContainer;
}
size_t
SgWhereStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgWhereStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_condition == NULL || p_condition != NULL); return p_condition;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
case 2: ROSE_ASSERT(p_elsewhere == NULL || p_elsewhere != NULL); return p_elsewhere;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgWhereStatement::get_childIndex(SgNode *child) const {
if (child == p_condition) return 0;
else if (child == p_body) return 1;
else if (child == p_elsewhere) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgElseWhereStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_condition);
traversalSuccessorContainer.push_back(p_body);
traversalSuccessorContainer.push_back(p_elsewhere);
return traversalSuccessorContainer;
}
vector<string>
SgElseWhereStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_condition");
traversalSuccessorContainer.push_back("p_body");
traversalSuccessorContainer.push_back("p_elsewhere");
return traversalSuccessorContainer;
}
size_t
SgElseWhereStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgElseWhereStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_condition == NULL || p_condition != NULL); return p_condition;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
case 2: ROSE_ASSERT(p_elsewhere == NULL || p_elsewhere != NULL); return p_elsewhere;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgElseWhereStatement::get_childIndex(SgNode *child) const {
if (child == p_condition) return 0;
else if (child == p_body) return 1;
else if (child == p_elsewhere) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgNullifyStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_pointer_list);
return traversalSuccessorContainer;
}
vector<string>
SgNullifyStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_pointer_list");
return traversalSuccessorContainer;
}
size_t
SgNullifyStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgNullifyStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_pointer_list == NULL || p_pointer_list != NULL); return p_pointer_list;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNullifyStatement::get_childIndex(SgNode *child) const {
if (child == p_pointer_list) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgArithmeticIfStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_conditional);
return traversalSuccessorContainer;
}
vector<string>
SgArithmeticIfStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_conditional");
return traversalSuccessorContainer;
}
size_t
SgArithmeticIfStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgArithmeticIfStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_conditional == NULL || p_conditional != NULL); return p_conditional;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgArithmeticIfStatement::get_childIndex(SgNode *child) const {
if (child == p_conditional) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAssignStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_value);
return traversalSuccessorContainer;
}
vector<string>
SgAssignStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_value");
return traversalSuccessorContainer;
}
size_t
SgAssignStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAssignStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_value == NULL || p_value != NULL); return p_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAssignStatement::get_childIndex(SgNode *child) const {
if (child == p_value) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgComputedGotoStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_labelList);
traversalSuccessorContainer.push_back(p_label_index);
return traversalSuccessorContainer;
}
vector<string>
SgComputedGotoStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_labelList");
traversalSuccessorContainer.push_back("p_label_index");
return traversalSuccessorContainer;
}
size_t
SgComputedGotoStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgComputedGotoStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_labelList == NULL || p_labelList != NULL); return p_labelList;
case 1: ROSE_ASSERT(p_label_index == NULL || p_label_index != NULL); return p_label_index;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgComputedGotoStatement::get_childIndex(SgNode *child) const {
if (child == p_labelList) return 0;
else if (child == p_label_index) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAssignedGotoStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_targets);
return traversalSuccessorContainer;
}
vector<string>
SgAssignedGotoStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_targets");
return traversalSuccessorContainer;
}
size_t
SgAssignedGotoStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAssignedGotoStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_targets == NULL || p_targets != NULL); return p_targets;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAssignedGotoStatement::get_childIndex(SgNode *child) const {
if (child == p_targets) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAllocateStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_expr_list);
traversalSuccessorContainer.push_back(p_stat_expression);
traversalSuccessorContainer.push_back(p_errmsg_expression);
traversalSuccessorContainer.push_back(p_source_expression);
return traversalSuccessorContainer;
}
vector<string>
SgAllocateStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expr_list");
traversalSuccessorContainer.push_back("p_stat_expression");
traversalSuccessorContainer.push_back("p_errmsg_expression");
traversalSuccessorContainer.push_back("p_source_expression");
return traversalSuccessorContainer;
}
size_t
SgAllocateStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgAllocateStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expr_list == NULL || p_expr_list != NULL); return p_expr_list;
case 1: ROSE_ASSERT(p_stat_expression == NULL || p_stat_expression != NULL); return p_stat_expression;
case 2: ROSE_ASSERT(p_errmsg_expression == NULL || p_errmsg_expression != NULL); return p_errmsg_expression;
case 3: ROSE_ASSERT(p_source_expression == NULL || p_source_expression != NULL); return p_source_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAllocateStatement::get_childIndex(SgNode *child) const {
if (child == p_expr_list) return 0;
else if (child == p_stat_expression) return 1;
else if (child == p_errmsg_expression) return 2;
else if (child == p_source_expression) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgDeallocateStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_expr_list);
traversalSuccessorContainer.push_back(p_stat_expression);
traversalSuccessorContainer.push_back(p_errmsg_expression);
return traversalSuccessorContainer;
}
vector<string>
SgDeallocateStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expr_list");
traversalSuccessorContainer.push_back("p_stat_expression");
traversalSuccessorContainer.push_back("p_errmsg_expression");
return traversalSuccessorContainer;
}
size_t
SgDeallocateStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgDeallocateStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expr_list == NULL || p_expr_list != NULL); return p_expr_list;
case 1: ROSE_ASSERT(p_stat_expression == NULL || p_stat_expression != NULL); return p_stat_expression;
case 2: ROSE_ASSERT(p_errmsg_expression == NULL || p_errmsg_expression != NULL); return p_errmsg_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDeallocateStatement::get_childIndex(SgNode *child) const {
if (child == p_expr_list) return 0;
else if (child == p_stat_expression) return 1;
else if (child == p_errmsg_expression) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcNotifyStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_notify_expression);
return traversalSuccessorContainer;
}
vector<string>
SgUpcNotifyStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_notify_expression");
return traversalSuccessorContainer;
}
size_t
SgUpcNotifyStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUpcNotifyStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_notify_expression == NULL || p_notify_expression != NULL); return p_notify_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUpcNotifyStatement::get_childIndex(SgNode *child) const {
if (child == p_notify_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcWaitStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_wait_expression);
return traversalSuccessorContainer;
}
vector<string>
SgUpcWaitStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_wait_expression");
return traversalSuccessorContainer;
}
size_t
SgUpcWaitStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUpcWaitStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_wait_expression == NULL || p_wait_expression != NULL); return p_wait_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUpcWaitStatement::get_childIndex(SgNode *child) const {
if (child == p_wait_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcBarrierStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_barrier_expression);
return traversalSuccessorContainer;
}
vector<string>
SgUpcBarrierStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_barrier_expression");
return traversalSuccessorContainer;
}
size_t
SgUpcBarrierStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUpcBarrierStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_barrier_expression == NULL || p_barrier_expression != NULL); return p_barrier_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUpcBarrierStatement::get_childIndex(SgNode *child) const {
if (child == p_barrier_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcFenceStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUpcFenceStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUpcFenceStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUpcFenceStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUpcFenceStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUpcFenceStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUpcFenceStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpBarrierStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpBarrierStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpBarrierStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpBarrierStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpBarrierStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpBarrierStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpBarrierStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpTaskwaitStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgOmpTaskwaitStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgOmpTaskwaitStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgOmpTaskwaitStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgOmpTaskwaitStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgOmpTaskwaitStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgOmpTaskwaitStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgOmpFlushStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_variables.size() + 0);
   {
     SgVarRefExpPtrList::const_iterator iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpFlushStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgVarRefExpPtrList::const_iterator  iter;
     for (iter = p_variables.begin(); iter != p_variables.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpFlushStatement::get_numberOfTraversalSuccessors() const {
return p_variables.size() + 0;
}
SgNode *
SgOmpFlushStatement::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_variables.size());
return p_variables[idx];
}
size_t
SgOmpFlushStatement::get_childIndex(SgNode *child) const {
SgVarRefExpPtrList::const_iterator itr = find(p_variables.begin(), p_variables.end(), child);
if (itr != p_variables.end()) return itr - p_variables.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgOmpBodyStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgOmpBodyStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgOmpBodyStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpBodyStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgOmpBodyStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgOmpBodyStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgOmpMasterStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgOmpMasterStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgOmpMasterStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpMasterStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpMasterStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpOrderedStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgOmpOrderedStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgOmpOrderedStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpOrderedStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpOrderedStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpCriticalStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgOmpCriticalStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgOmpCriticalStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpCriticalStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpCriticalStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpSectionStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgOmpSectionStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgOmpSectionStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpSectionStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpSectionStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpWorkshareStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgOmpWorkshareStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgOmpWorkshareStatement::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgOmpWorkshareStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOmpWorkshareStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgOmpClauseBodyStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClauseBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgOmpClauseBodyStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClauseBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgOmpClauseBodyStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClauseBodyStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgOmpClauseBodyStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClauseBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgOmpClauseBodyStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgOmpClauseBodyStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgOmpParallelStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpParallelStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpParallelStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpParallelStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpParallelStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpSingleStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpSingleStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpSingleStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpSingleStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpSingleStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpAtomicStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpAtomicStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpAtomicStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpAtomicStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpAtomicStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpTaskStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpTaskStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpTaskStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpTaskStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpTaskStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpForStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpForStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpForStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpForStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpForStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpDoStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpDoStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpDoStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpDoStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpDoStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpSectionsStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpSectionsStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpSectionsStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpSectionsStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpSectionsStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpTargetStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpTargetStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpTargetStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpTargetStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpTargetStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpTargetDataStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpTargetDataStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpTargetDataStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpTargetDataStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpTargetDataStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpSimdStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpSimdStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpSimdStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpSimdStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpSimdStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgOmpForSimdStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_clauses.size() + 1);
traversalSuccessorContainer.push_back(p_body);
   {
     SgOmpClausePtrList::const_iterator iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgOmpForSimdStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 1;
traversalSuccessorContainer.push_back("p_body");
   {
     SgOmpClausePtrList::const_iterator  iter;
     for (iter = p_clauses.begin(); iter != p_clauses.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgOmpForSimdStatement::get_numberOfTraversalSuccessors() const {
return p_clauses.size() + 1;
}
SgNode *
SgOmpForSimdStatement::get_traversalSuccessorByIndex(size_t idx) const {
if (idx == 0) return p_body;
else return p_clauses[idx-1];
}
size_t
SgOmpForSimdStatement::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else {
SgOmpClausePtrList::const_iterator itr = find(p_clauses.begin(), p_clauses.end(), child);
if (itr != p_clauses.end()) return (itr - p_clauses.begin()) + 1;
else return (size_t) -1;
}
}
vector<SgNode*>
SgSequenceStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgSequenceStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgSequenceStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgSequenceStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgSequenceStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgSequenceStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgSequenceStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgWithStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgWithStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgWithStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgWithStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgWithStatement::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPythonPrintStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_destination);
traversalSuccessorContainer.push_back(p_values);
return traversalSuccessorContainer;
}
vector<string>
SgPythonPrintStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_destination");
traversalSuccessorContainer.push_back("p_values");
return traversalSuccessorContainer;
}
size_t
SgPythonPrintStmt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgPythonPrintStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_destination == NULL || p_destination != NULL); return p_destination;
case 1: ROSE_ASSERT(p_values == NULL || p_values != NULL); return p_values;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPythonPrintStmt::get_childIndex(SgNode *child) const {
if (child == p_destination) return 0;
else if (child == p_values) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPassStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgPassStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgPassStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgPassStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgPassStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgPassStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgPassStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAssertStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_test);
traversalSuccessorContainer.push_back(p_exception_argument);
return traversalSuccessorContainer;
}
vector<string>
SgAssertStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_test");
traversalSuccessorContainer.push_back("p_exception_argument");
return traversalSuccessorContainer;
}
size_t
SgAssertStmt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAssertStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_test == NULL || p_test != NULL); return p_test;
case 1: ROSE_ASSERT(p_exception_argument == NULL || p_exception_argument != NULL); return p_exception_argument;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAssertStmt::get_childIndex(SgNode *child) const {
if (child == p_test) return 0;
else if (child == p_exception_argument) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgExecStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_executable);
traversalSuccessorContainer.push_back(p_globals);
traversalSuccessorContainer.push_back(p_locals);
return traversalSuccessorContainer;
}
vector<string>
SgExecStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executable");
traversalSuccessorContainer.push_back("p_globals");
traversalSuccessorContainer.push_back("p_locals");
return traversalSuccessorContainer;
}
size_t
SgExecStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgExecStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executable == NULL || p_executable != NULL); return p_executable;
case 1: ROSE_ASSERT(p_globals == NULL || p_globals != NULL); return p_globals;
case 2: ROSE_ASSERT(p_locals == NULL || p_locals != NULL); return p_locals;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgExecStatement::get_childIndex(SgNode *child) const {
if (child == p_executable) return 0;
else if (child == p_globals) return 1;
else if (child == p_locals) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgPythonGlobalStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_names.size() + 0);
   {
     SgInitializedNamePtrList::const_iterator iter;
     for (iter = p_names.begin(); iter != p_names.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgPythonGlobalStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgInitializedNamePtrList::const_iterator  iter;
     for (iter = p_names.begin(); iter != p_names.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgPythonGlobalStmt::get_numberOfTraversalSuccessors() const {
return p_names.size() + 0;
}
SgNode *
SgPythonGlobalStmt::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_names.size());
return p_names[idx];
}
size_t
SgPythonGlobalStmt::get_childIndex(SgNode *child) const {
SgInitializedNamePtrList::const_iterator itr = find(p_names.begin(), p_names.end(), child);
if (itr != p_names.end()) return itr - p_names.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgJavaThrowStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJavaThrowStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJavaThrowStatement::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJavaThrowStatement::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJavaThrowStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJavaThrowStatement::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJavaThrowStatement" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaSynchronizedStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgJavaSynchronizedStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgJavaSynchronizedStatement::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJavaSynchronizedStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaSynchronizedStatement::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsyncStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsyncStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsyncStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsyncStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsyncStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgFinishStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgFinishStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgFinishStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgFinishStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFinishStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAtStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAtStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAtStmt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAtStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAtStmt::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAtomicStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAtomicStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAtomicStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAtomicStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAtomicStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgWhenStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgWhenStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgWhenStmt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgWhenStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgWhenStmt::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgImageControlStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgImageControlStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgImageControlStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgImageControlStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgImageControlStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgImageControlStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgImageControlStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgImageControlStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgImageControlStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgImageControlStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgSyncAllStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_stat);
traversalSuccessorContainer.push_back(p_err_msg);
traversalSuccessorContainer.push_back(p_acquired_lock);
return traversalSuccessorContainer;
}
vector<string>
SgSyncAllStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_stat");
traversalSuccessorContainer.push_back("p_err_msg");
traversalSuccessorContainer.push_back("p_acquired_lock");
return traversalSuccessorContainer;
}
size_t
SgSyncAllStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgSyncAllStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_stat == NULL || p_stat != NULL); return p_stat;
case 1: ROSE_ASSERT(p_err_msg == NULL || p_err_msg != NULL); return p_err_msg;
case 2: ROSE_ASSERT(p_acquired_lock == NULL || p_acquired_lock != NULL); return p_acquired_lock;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSyncAllStatement::get_childIndex(SgNode *child) const {
if (child == p_stat) return 0;
else if (child == p_err_msg) return 1;
else if (child == p_acquired_lock) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgSyncImagesStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_stat);
traversalSuccessorContainer.push_back(p_err_msg);
traversalSuccessorContainer.push_back(p_acquired_lock);
traversalSuccessorContainer.push_back(p_image_set);
return traversalSuccessorContainer;
}
vector<string>
SgSyncImagesStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_stat");
traversalSuccessorContainer.push_back("p_err_msg");
traversalSuccessorContainer.push_back("p_acquired_lock");
traversalSuccessorContainer.push_back("p_image_set");
return traversalSuccessorContainer;
}
size_t
SgSyncImagesStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgSyncImagesStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_stat == NULL || p_stat != NULL); return p_stat;
case 1: ROSE_ASSERT(p_err_msg == NULL || p_err_msg != NULL); return p_err_msg;
case 2: ROSE_ASSERT(p_acquired_lock == NULL || p_acquired_lock != NULL); return p_acquired_lock;
case 3: ROSE_ASSERT(p_image_set == NULL || p_image_set != NULL); return p_image_set;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSyncImagesStatement::get_childIndex(SgNode *child) const {
if (child == p_stat) return 0;
else if (child == p_err_msg) return 1;
else if (child == p_acquired_lock) return 2;
else if (child == p_image_set) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgSyncMemoryStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_stat);
traversalSuccessorContainer.push_back(p_err_msg);
traversalSuccessorContainer.push_back(p_acquired_lock);
return traversalSuccessorContainer;
}
vector<string>
SgSyncMemoryStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_stat");
traversalSuccessorContainer.push_back("p_err_msg");
traversalSuccessorContainer.push_back("p_acquired_lock");
return traversalSuccessorContainer;
}
size_t
SgSyncMemoryStatement::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgSyncMemoryStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_stat == NULL || p_stat != NULL); return p_stat;
case 1: ROSE_ASSERT(p_err_msg == NULL || p_err_msg != NULL); return p_err_msg;
case 2: ROSE_ASSERT(p_acquired_lock == NULL || p_acquired_lock != NULL); return p_acquired_lock;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSyncMemoryStatement::get_childIndex(SgNode *child) const {
if (child == p_stat) return 0;
else if (child == p_err_msg) return 1;
else if (child == p_acquired_lock) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgSyncTeamStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_stat);
traversalSuccessorContainer.push_back(p_err_msg);
traversalSuccessorContainer.push_back(p_acquired_lock);
traversalSuccessorContainer.push_back(p_team_value);
return traversalSuccessorContainer;
}
vector<string>
SgSyncTeamStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_stat");
traversalSuccessorContainer.push_back("p_err_msg");
traversalSuccessorContainer.push_back("p_acquired_lock");
traversalSuccessorContainer.push_back("p_team_value");
return traversalSuccessorContainer;
}
size_t
SgSyncTeamStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgSyncTeamStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_stat == NULL || p_stat != NULL); return p_stat;
case 1: ROSE_ASSERT(p_err_msg == NULL || p_err_msg != NULL); return p_err_msg;
case 2: ROSE_ASSERT(p_acquired_lock == NULL || p_acquired_lock != NULL); return p_acquired_lock;
case 3: ROSE_ASSERT(p_team_value == NULL || p_team_value != NULL); return p_team_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSyncTeamStatement::get_childIndex(SgNode *child) const {
if (child == p_stat) return 0;
else if (child == p_err_msg) return 1;
else if (child == p_acquired_lock) return 2;
else if (child == p_team_value) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgLockStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_stat);
traversalSuccessorContainer.push_back(p_err_msg);
traversalSuccessorContainer.push_back(p_acquired_lock);
traversalSuccessorContainer.push_back(p_lock_variable);
return traversalSuccessorContainer;
}
vector<string>
SgLockStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_stat");
traversalSuccessorContainer.push_back("p_err_msg");
traversalSuccessorContainer.push_back("p_acquired_lock");
traversalSuccessorContainer.push_back("p_lock_variable");
return traversalSuccessorContainer;
}
size_t
SgLockStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgLockStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_stat == NULL || p_stat != NULL); return p_stat;
case 1: ROSE_ASSERT(p_err_msg == NULL || p_err_msg != NULL); return p_err_msg;
case 2: ROSE_ASSERT(p_acquired_lock == NULL || p_acquired_lock != NULL); return p_acquired_lock;
case 3: ROSE_ASSERT(p_lock_variable == NULL || p_lock_variable != NULL); return p_lock_variable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLockStatement::get_childIndex(SgNode *child) const {
if (child == p_stat) return 0;
else if (child == p_err_msg) return 1;
else if (child == p_acquired_lock) return 2;
else if (child == p_lock_variable) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgUnlockStatement::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_stat);
traversalSuccessorContainer.push_back(p_err_msg);
traversalSuccessorContainer.push_back(p_acquired_lock);
traversalSuccessorContainer.push_back(p_lock_variable);
return traversalSuccessorContainer;
}
vector<string>
SgUnlockStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_stat");
traversalSuccessorContainer.push_back("p_err_msg");
traversalSuccessorContainer.push_back("p_acquired_lock");
traversalSuccessorContainer.push_back("p_lock_variable");
return traversalSuccessorContainer;
}
size_t
SgUnlockStatement::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgUnlockStatement::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_stat == NULL || p_stat != NULL); return p_stat;
case 1: ROSE_ASSERT(p_err_msg == NULL || p_err_msg != NULL); return p_err_msg;
case 2: ROSE_ASSERT(p_acquired_lock == NULL || p_acquired_lock != NULL); return p_acquired_lock;
case 3: ROSE_ASSERT(p_lock_variable == NULL || p_lock_variable != NULL); return p_lock_variable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUnlockStatement::get_childIndex(SgNode *child) const {
if (child == p_stat) return 0;
else if (child == p_err_msg) return 1;
else if (child == p_acquired_lock) return 2;
else if (child == p_lock_variable) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaExitStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_condition);
return traversalSuccessorContainer;
}
vector<string>
SgAdaExitStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_condition");
return traversalSuccessorContainer;
}
size_t
SgAdaExitStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaExitStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_condition == NULL || p_condition != NULL); return p_condition;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaExitStmt::get_childIndex(SgNode *child) const {
if (child == p_condition) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaDelayStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_time);
return traversalSuccessorContainer;
}
vector<string>
SgAdaDelayStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_time");
return traversalSuccessorContainer;
}
size_t
SgAdaDelayStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaDelayStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_time == NULL || p_time != NULL); return p_time;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaDelayStmt::get_childIndex(SgNode *child) const {
if (child == p_time) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaLoopStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAdaLoopStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAdaLoopStmt::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaLoopStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaLoopStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaSelectStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_select_path);
traversalSuccessorContainer.push_back(p_or_path);
traversalSuccessorContainer.push_back(p_else_path);
traversalSuccessorContainer.push_back(p_abort_path);
return traversalSuccessorContainer;
}
vector<string>
SgAdaSelectStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_select_path");
traversalSuccessorContainer.push_back("p_or_path");
traversalSuccessorContainer.push_back("p_else_path");
traversalSuccessorContainer.push_back("p_abort_path");
return traversalSuccessorContainer;
}
size_t
SgAdaSelectStmt::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgAdaSelectStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_select_path == NULL || p_select_path != NULL); return p_select_path;
case 1: ROSE_ASSERT(p_or_path == NULL || p_or_path != NULL); return p_or_path;
case 2: ROSE_ASSERT(p_else_path == NULL || p_else_path != NULL); return p_else_path;
case 3: ROSE_ASSERT(p_abort_path == NULL || p_abort_path != NULL); return p_abort_path;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaSelectStmt::get_childIndex(SgNode *child) const {
if (child == p_select_path) return 0;
else if (child == p_or_path) return 1;
else if (child == p_else_path) return 2;
else if (child == p_abort_path) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaSelectAlternativeStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_body);
traversalSuccessorContainer.push_back(p_guard);
traversalSuccessorContainer.push_back(p_next);
return traversalSuccessorContainer;
}
vector<string>
SgAdaSelectAlternativeStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
traversalSuccessorContainer.push_back("p_guard");
traversalSuccessorContainer.push_back("p_next");
return traversalSuccessorContainer;
}
size_t
SgAdaSelectAlternativeStmt::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAdaSelectAlternativeStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
case 1: ROSE_ASSERT(p_guard == NULL || p_guard != NULL); return p_guard;
case 2: ROSE_ASSERT(p_next == NULL || p_next != NULL); return p_next;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaSelectAlternativeStmt::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else if (child == p_guard) return 1;
else if (child == p_next) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTerminateStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaTerminateStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaTerminateStmt::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaTerminateStmt::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaTerminateStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaTerminateStmt::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaTerminateStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAdaUnscopedBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_statements.size() + 0);
   {
     SgStatementPtrList::const_iterator iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAdaUnscopedBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgStatementPtrList::const_iterator  iter;
     for (iter = p_statements.begin(); iter != p_statements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAdaUnscopedBlock::get_numberOfTraversalSuccessors() const {
return p_statements.size() + 0;
}
SgNode *
SgAdaUnscopedBlock::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_statements.size());
return p_statements[idx];
}
size_t
SgAdaUnscopedBlock::get_childIndex(SgNode *child) const {
SgStatementPtrList::const_iterator itr = find(p_statements.begin(), p_statements.end(), child);
if (itr != p_statements.end()) return itr - p_statements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAdaVariantWhenStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_choices);
traversalSuccessorContainer.push_back(p_components);
return traversalSuccessorContainer;
}
vector<string>
SgAdaVariantWhenStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_choices");
traversalSuccessorContainer.push_back("p_components");
return traversalSuccessorContainer;
}
size_t
SgAdaVariantWhenStmt::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaVariantWhenStmt::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_choices == NULL || p_choices != NULL); return p_choices;
case 1: ROSE_ASSERT(p_components == NULL || p_components != NULL); return p_components;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaVariantWhenStmt::get_childIndex(SgNode *child) const {
if (child == p_choices) return 0;
else if (child == p_components) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgExpression::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgExpression::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgExpression" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgExpression::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgExpression::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgUnaryOp::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgUnaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgUnaryOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgUnaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgUnaryOp::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgUnaryOp" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgUnaryOp::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgUnaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgUnaryOp::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgUnaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgExpressionRoot::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgExpressionRoot::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgExpressionRoot::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgExpressionRoot::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgExpressionRoot::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgMinusOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgMinusOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgMinusOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgMinusOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMinusOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUnaryAddOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgUnaryAddOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgUnaryAddOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUnaryAddOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUnaryAddOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgNotOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgNotOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgNotOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgNotOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNotOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgPointerDerefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgPointerDerefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgPointerDerefExp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgPointerDerefExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPointerDerefExp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAddressOfOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAddressOfOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAddressOfOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAddressOfOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAddressOfOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgMinusMinusOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgMinusMinusOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgMinusMinusOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgMinusMinusOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMinusMinusOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgPlusPlusOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgPlusPlusOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgPlusPlusOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgPlusPlusOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPlusPlusOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgBitComplementOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgBitComplementOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgBitComplementOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgBitComplementOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBitComplementOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgCastExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgCastExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgCastExp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgCastExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCastExp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgThrowOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgThrowOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgThrowOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgThrowOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgThrowOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgRealPartOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgRealPartOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgRealPartOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgRealPartOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRealPartOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgImagPartOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgImagPartOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgImagPartOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgImagPartOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgImagPartOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgConjugateOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgConjugateOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgConjugateOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgConjugateOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgConjugateOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUserDefinedUnaryOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgUserDefinedUnaryOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgUserDefinedUnaryOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUserDefinedUnaryOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUserDefinedUnaryOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgMatrixTransposeOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgMatrixTransposeOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgMatrixTransposeOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgMatrixTransposeOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMatrixTransposeOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAbsOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAbsOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAbsOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAbsOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAbsOp::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgBinaryOp::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBinaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgBinaryOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBinaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgBinaryOp::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBinaryOp" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgBinaryOp::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBinaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgBinaryOp::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgBinaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgArrowExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgArrowExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgArrowExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgArrowExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgArrowExp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDotExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgDotExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgDotExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDotExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDotExp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDotStarOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgDotStarOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgDotStarOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDotStarOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDotStarOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgArrowStarOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgArrowStarOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgArrowStarOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgArrowStarOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgArrowStarOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgEqualityOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgEqualityOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgEqualityOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgEqualityOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgEqualityOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgLessThanOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgLessThanOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgLessThanOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgLessThanOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLessThanOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgGreaterThanOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgGreaterThanOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgGreaterThanOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgGreaterThanOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgGreaterThanOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgNotEqualOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgNotEqualOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgNotEqualOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgNotEqualOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNotEqualOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgLessOrEqualOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgLessOrEqualOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgLessOrEqualOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgLessOrEqualOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLessOrEqualOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgGreaterOrEqualOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgGreaterOrEqualOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgGreaterOrEqualOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgGreaterOrEqualOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgGreaterOrEqualOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAddOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAddOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAddOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAddOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAddOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgSubtractOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgSubtractOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgSubtractOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgSubtractOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSubtractOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgMultiplyOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgMultiplyOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgMultiplyOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgMultiplyOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMultiplyOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDivideOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgDivideOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgDivideOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDivideOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDivideOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgIntegerDivideOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgIntegerDivideOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgIntegerDivideOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgIntegerDivideOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIntegerDivideOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgModOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgModOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgModOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgModOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgModOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAndOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAndOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAndOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAndOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAndOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgOrOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgOrOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgOrOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgOrOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgOrOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgBitXorOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgBitXorOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgBitXorOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgBitXorOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBitXorOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgBitAndOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgBitAndOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgBitAndOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgBitAndOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBitAndOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgBitOrOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgBitOrOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgBitOrOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgBitOrOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBitOrOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgBitEqvOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgBitEqvOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgBitEqvOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgBitEqvOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBitEqvOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgCommaOpExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgCommaOpExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgCommaOpExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgCommaOpExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCommaOpExp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgLshiftOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgLshiftOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgLshiftOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgLshiftOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLshiftOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgRshiftOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgRshiftOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgRshiftOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgRshiftOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRshiftOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPntrArrRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgPntrArrRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgPntrArrRefExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgPntrArrRefExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPntrArrRefExp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgScopeOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgScopeOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgScopeOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgScopeOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgScopeOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgExponentiationOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgExponentiationOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgExponentiationOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgExponentiationOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgExponentiationOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaUnsignedRshiftOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgJavaUnsignedRshiftOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgJavaUnsignedRshiftOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJavaUnsignedRshiftOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaUnsignedRshiftOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgConcatenationOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgConcatenationOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgConcatenationOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgConcatenationOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgConcatenationOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPointerAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgPointerAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgPointerAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgPointerAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPointerAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgUserDefinedBinaryOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgUserDefinedBinaryOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgUserDefinedBinaryOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgUserDefinedBinaryOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUserDefinedBinaryOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgCompoundAssignOp::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgCompoundAssignOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgCompoundAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgCompoundAssignOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgCompoundAssignOp::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgCompoundAssignOp" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgCompoundAssignOp::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgCompoundAssignOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgCompoundAssignOp::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgCompoundAssignOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgPlusAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgPlusAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgPlusAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgPlusAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPlusAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgMinusAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgMinusAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgMinusAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgMinusAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMinusAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAndAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAndAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAndAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAndAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAndAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgIorAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgIorAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgIorAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgIorAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIorAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgMultAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgMultAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgMultAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgMultAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMultAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDivAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgDivAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgDivAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDivAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDivAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgModAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgModAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgModAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgModAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgModAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgXorAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgXorAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgXorAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgXorAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgXorAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgLshiftAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgLshiftAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgLshiftAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgLshiftAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLshiftAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgRshiftAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgRshiftAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgRshiftAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgRshiftAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRshiftAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaUnsignedRshiftAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgJavaUnsignedRshiftAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgJavaUnsignedRshiftAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJavaUnsignedRshiftAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaUnsignedRshiftAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgIntegerDivideAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgIntegerDivideAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgIntegerDivideAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgIntegerDivideAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIntegerDivideAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgExponentiationAssignOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgExponentiationAssignOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgExponentiationAssignOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgExponentiationAssignOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgExponentiationAssignOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgMembershipOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgMembershipOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgMembershipOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgMembershipOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMembershipOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgSpaceshipOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgSpaceshipOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgSpaceshipOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgSpaceshipOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSpaceshipOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgNonMembershipOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgNonMembershipOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgNonMembershipOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgNonMembershipOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNonMembershipOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgIsOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgIsOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgIsOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgIsOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIsOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgIsNotOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgIsNotOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgIsNotOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgIsNotOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIsNotOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDotDotExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgDotDotExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgDotDotExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDotDotExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDotDotExp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgElementwiseOp::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgElementwiseOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgElementwiseOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgElementwiseOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgElementwiseOp::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgElementwiseOp" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgElementwiseOp::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgElementwiseOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgElementwiseOp::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgElementwiseOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgElementwiseMultiplyOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgElementwiseMultiplyOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgElementwiseMultiplyOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgElementwiseMultiplyOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgElementwiseMultiplyOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgElementwisePowerOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgElementwisePowerOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgElementwisePowerOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgElementwisePowerOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgElementwisePowerOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgElementwiseLeftDivideOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgElementwiseLeftDivideOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgElementwiseLeftDivideOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgElementwiseLeftDivideOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgElementwiseLeftDivideOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgElementwiseDivideOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgElementwiseDivideOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgElementwiseDivideOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgElementwiseDivideOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgElementwiseDivideOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgElementwiseAddOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgElementwiseAddOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgElementwiseAddOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgElementwiseAddOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgElementwiseAddOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgElementwiseSubtractOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgElementwiseSubtractOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgElementwiseSubtractOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgElementwiseSubtractOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgElementwiseSubtractOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPowerOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgPowerOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgPowerOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgPowerOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgPowerOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgLeftDivideOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgLeftDivideOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgLeftDivideOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgLeftDivideOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLeftDivideOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgRemOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgRemOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgRemOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgRemOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRemOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgReplicationOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgReplicationOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgReplicationOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgReplicationOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgReplicationOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAtOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand_i);
traversalSuccessorContainer.push_back(p_rhs_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAtOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand_i");
traversalSuccessorContainer.push_back("p_rhs_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAtOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAtOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand_i == NULL || p_lhs_operand_i != NULL); return p_lhs_operand_i;
case 1: ROSE_ASSERT(p_rhs_operand_i == NULL || p_rhs_operand_i != NULL); return p_rhs_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAtOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand_i) return 0;
else if (child == p_rhs_operand_i) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgExprListExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_expressions.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgExprListExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgExprListExp::get_numberOfTraversalSuccessors() const {
return p_expressions.size() + 0;
}
SgNode *
SgExprListExp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_expressions.size());
return p_expressions[idx];
}
size_t
SgExprListExp::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_expressions.begin(), p_expressions.end(), child);
if (itr != p_expressions.end()) return itr - p_expressions.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgListExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_expressions.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgListExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgListExp::get_numberOfTraversalSuccessors() const {
return p_expressions.size() + 0;
}
SgNode *
SgListExp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_expressions.size());
return p_expressions[idx];
}
size_t
SgListExp::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_expressions.begin(), p_expressions.end(), child);
if (itr != p_expressions.end()) return itr - p_expressions.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgTupleExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_expressions.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgTupleExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgTupleExp::get_numberOfTraversalSuccessors() const {
return p_expressions.size() + 0;
}
SgNode *
SgTupleExp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_expressions.size());
return p_expressions[idx];
}
size_t
SgTupleExp::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_expressions.begin(), p_expressions.end(), child);
if (itr != p_expressions.end()) return itr - p_expressions.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgMatrixExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_expressions.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgMatrixExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgMatrixExp::get_numberOfTraversalSuccessors() const {
return p_expressions.size() + 0;
}
SgNode *
SgMatrixExp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_expressions.size());
return p_expressions[idx];
}
size_t
SgMatrixExp::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_expressions.begin(), p_expressions.end(), child);
if (itr != p_expressions.end()) return itr - p_expressions.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgValueExp::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgValueExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgValueExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgValueExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgValueExp::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgValueExp" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgValueExp::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgValueExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgValueExp::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgValueExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgBoolValExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgBoolValExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgBoolValExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgBoolValExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgBoolValExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgBoolValExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgBoolValExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgStringVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgStringVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgStringVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgStringVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgStringVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgStringVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgStringVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgShortVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgShortVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgShortVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgShortVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgShortVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgShortVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgShortVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgCharVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgCharVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgCharVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgCharVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgCharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgCharVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgCharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUnsignedCharVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUnsignedCharVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUnsignedCharVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUnsignedCharVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUnsignedCharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUnsignedCharVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUnsignedCharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgWcharVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgWcharVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgWcharVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgWcharVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgWcharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgWcharVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgWcharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUnsignedShortVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUnsignedShortVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUnsignedShortVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUnsignedShortVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUnsignedShortVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUnsignedShortVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUnsignedShortVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgIntVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIntVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIntVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIntVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIntVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgEnumVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgEnumVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgEnumVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgEnumVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgEnumVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgEnumVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgEnumVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUnsignedIntVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUnsignedIntVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUnsignedIntVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUnsignedIntVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUnsignedIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUnsignedIntVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUnsignedIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLongIntVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgLongIntVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgLongIntVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgLongIntVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgLongIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgLongIntVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgLongIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLongLongIntVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgLongLongIntVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgLongLongIntVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgLongLongIntVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgLongLongIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgLongLongIntVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgLongLongIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUnsignedLongLongIntVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUnsignedLongLongIntVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUnsignedLongLongIntVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUnsignedLongLongIntVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUnsignedLongLongIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUnsignedLongLongIntVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUnsignedLongLongIntVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUnsignedLongVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUnsignedLongVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUnsignedLongVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUnsignedLongVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUnsignedLongVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUnsignedLongVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUnsignedLongVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFloatVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFloatVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFloatVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFloatVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFloatVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFloatVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFloatVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgDoubleVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDoubleVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDoubleVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDoubleVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDoubleVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDoubleVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDoubleVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLongDoubleVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgLongDoubleVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgLongDoubleVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgLongDoubleVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgLongDoubleVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgLongDoubleVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgLongDoubleVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgComplexVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_real_value);
traversalSuccessorContainer.push_back(p_imaginary_value);
return traversalSuccessorContainer;
}
vector<string>
SgComplexVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_real_value");
traversalSuccessorContainer.push_back("p_imaginary_value");
return traversalSuccessorContainer;
}
size_t
SgComplexVal::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgComplexVal::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_real_value == NULL || p_real_value != NULL); return p_real_value;
case 1: ROSE_ASSERT(p_imaginary_value == NULL || p_imaginary_value != NULL); return p_imaginary_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgComplexVal::get_childIndex(SgNode *child) const {
if (child == p_real_value) return 0;
else if (child == p_imaginary_value) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcThreads::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUpcThreads::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUpcThreads::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUpcThreads::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUpcThreads" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUpcThreads::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUpcThreads" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgUpcMythread::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgUpcMythread::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgUpcMythread::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgUpcMythread::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgUpcMythread" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgUpcMythread::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgUpcMythread" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateParameterVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTemplateParameterVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTemplateParameterVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTemplateParameterVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTemplateParameterVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTemplateParameterVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTemplateParameterVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgNullptrValExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNullptrValExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNullptrValExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNullptrValExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNullptrValExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNullptrValExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNullptrValExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgChar16Val::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgChar16Val::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgChar16Val::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgChar16Val::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgChar16Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgChar16Val::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgChar16Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgChar32Val::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgChar32Val::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgChar32Val::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgChar32Val::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgChar32Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgChar32Val::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgChar32Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFloat80Val::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFloat80Val::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFloat80Val::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFloat80Val::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFloat80Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFloat80Val::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFloat80Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFloat128Val::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFloat128Val::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFloat128Val::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFloat128Val::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFloat128Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFloat128Val::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFloat128Val" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgVoidVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgVoidVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgVoidVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgVoidVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgVoidVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgVoidVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgVoidVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAdaFloatVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaFloatVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaFloatVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaFloatVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaFloatVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaFloatVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaFloatVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgSignedCharVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgSignedCharVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgSignedCharVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgSignedCharVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgSignedCharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgSignedCharVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgSignedCharVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJovialBitVal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJovialBitVal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJovialBitVal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJovialBitVal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJovialBitVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJovialBitVal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJovialBitVal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgCallExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_function);
traversalSuccessorContainer.push_back(p_args);
return traversalSuccessorContainer;
}
vector<string>
SgCallExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_function");
traversalSuccessorContainer.push_back("p_args");
return traversalSuccessorContainer;
}
size_t
SgCallExpression::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgCallExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_function == NULL || p_function != NULL); return p_function;
case 1: ROSE_ASSERT(p_args == NULL || p_args != NULL); return p_args;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCallExpression::get_childIndex(SgNode *child) const {
if (child == p_function) return 0;
else if (child == p_args) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionCallExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_function);
traversalSuccessorContainer.push_back(p_args);
return traversalSuccessorContainer;
}
vector<string>
SgFunctionCallExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_function");
traversalSuccessorContainer.push_back("p_args");
return traversalSuccessorContainer;
}
size_t
SgFunctionCallExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgFunctionCallExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_function == NULL || p_function != NULL); return p_function;
case 1: ROSE_ASSERT(p_args == NULL || p_args != NULL); return p_args;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFunctionCallExp::get_childIndex(SgNode *child) const {
if (child == p_function) return 0;
else if (child == p_args) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgCudaKernelCallExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_function);
traversalSuccessorContainer.push_back(p_args);
traversalSuccessorContainer.push_back(p_exec_config);
return traversalSuccessorContainer;
}
vector<string>
SgCudaKernelCallExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_function");
traversalSuccessorContainer.push_back("p_args");
traversalSuccessorContainer.push_back("p_exec_config");
return traversalSuccessorContainer;
}
size_t
SgCudaKernelCallExp::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgCudaKernelCallExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_function == NULL || p_function != NULL); return p_function;
case 1: ROSE_ASSERT(p_args == NULL || p_args != NULL); return p_args;
case 2: ROSE_ASSERT(p_exec_config == NULL || p_exec_config != NULL); return p_exec_config;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCudaKernelCallExp::get_childIndex(SgNode *child) const {
if (child == p_function) return 0;
else if (child == p_args) return 1;
else if (child == p_exec_config) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcLocalsizeofExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgUpcLocalsizeofExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgUpcLocalsizeofExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUpcLocalsizeofExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUpcLocalsizeofExpression::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcBlocksizeofExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgUpcBlocksizeofExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgUpcBlocksizeofExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUpcBlocksizeofExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUpcBlocksizeofExpression::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgUpcElemsizeofExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgUpcElemsizeofExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgUpcElemsizeofExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgUpcElemsizeofExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUpcElemsizeofExpression::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaInstanceOfOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgJavaInstanceOfOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgJavaInstanceOfOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJavaInstanceOfOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaInstanceOfOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgSuperExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgSuperExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgSuperExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgSuperExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgSuperExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgSuperExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgSuperExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTypeIdOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgTypeIdOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgTypeIdOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTypeIdOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypeIdOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgConditionalExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_conditional_exp);
traversalSuccessorContainer.push_back(p_true_exp);
traversalSuccessorContainer.push_back(p_false_exp);
return traversalSuccessorContainer;
}
vector<string>
SgConditionalExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_conditional_exp");
traversalSuccessorContainer.push_back("p_true_exp");
traversalSuccessorContainer.push_back("p_false_exp");
return traversalSuccessorContainer;
}
size_t
SgConditionalExp::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgConditionalExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_conditional_exp == NULL || p_conditional_exp != NULL); return p_conditional_exp;
case 1: ROSE_ASSERT(p_true_exp == NULL || p_true_exp != NULL); return p_true_exp;
case 2: ROSE_ASSERT(p_false_exp == NULL || p_false_exp != NULL); return p_false_exp;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgConditionalExp::get_childIndex(SgNode *child) const {
if (child == p_conditional_exp) return 0;
else if (child == p_true_exp) return 1;
else if (child == p_false_exp) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgNewExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_placement_args);
traversalSuccessorContainer.push_back(p_constructor_args);
traversalSuccessorContainer.push_back(p_builtin_args);
return traversalSuccessorContainer;
}
vector<string>
SgNewExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_placement_args");
traversalSuccessorContainer.push_back("p_constructor_args");
traversalSuccessorContainer.push_back("p_builtin_args");
return traversalSuccessorContainer;
}
size_t
SgNewExp::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgNewExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_placement_args == NULL || p_placement_args != NULL); return p_placement_args;
case 1: ROSE_ASSERT(p_constructor_args == NULL || p_constructor_args != NULL); return p_constructor_args;
case 2: ROSE_ASSERT(p_builtin_args == NULL || p_builtin_args != NULL); return p_builtin_args;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNewExp::get_childIndex(SgNode *child) const {
if (child == p_placement_args) return 0;
else if (child == p_constructor_args) return 1;
else if (child == p_builtin_args) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgDeleteExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_variable);
return traversalSuccessorContainer;
}
vector<string>
SgDeleteExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_variable");
return traversalSuccessorContainer;
}
size_t
SgDeleteExp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgDeleteExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_variable == NULL || p_variable != NULL); return p_variable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDeleteExp::get_childIndex(SgNode *child) const {
if (child == p_variable) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgThisExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgThisExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgThisExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgThisExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgThisExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgThisExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgThisExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgInitializer::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgInitializer" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgInitializer" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgInitializer::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgInitializer" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgInitializer::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgInitializer" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgInitializer::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgInitializer" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAggregateInitializer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_initializers);
return traversalSuccessorContainer;
}
vector<string>
SgAggregateInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_initializers");
return traversalSuccessorContainer;
}
size_t
SgAggregateInitializer::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAggregateInitializer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_initializers == NULL || p_initializers != NULL); return p_initializers;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAggregateInitializer::get_childIndex(SgNode *child) const {
if (child == p_initializers) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgCompoundInitializer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_initializers);
return traversalSuccessorContainer;
}
vector<string>
SgCompoundInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_initializers");
return traversalSuccessorContainer;
}
size_t
SgCompoundInitializer::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgCompoundInitializer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_initializers == NULL || p_initializers != NULL); return p_initializers;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCompoundInitializer::get_childIndex(SgNode *child) const {
if (child == p_initializers) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgConstructorInitializer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_args);
return traversalSuccessorContainer;
}
vector<string>
SgConstructorInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_args");
return traversalSuccessorContainer;
}
size_t
SgConstructorInitializer::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgConstructorInitializer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_args == NULL || p_args != NULL); return p_args;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgConstructorInitializer::get_childIndex(SgNode *child) const {
if (child == p_args) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAssignInitializer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_i);
return traversalSuccessorContainer;
}
vector<string>
SgAssignInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_i");
return traversalSuccessorContainer;
}
size_t
SgAssignInitializer::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAssignInitializer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_i == NULL || p_operand_i != NULL); return p_operand_i;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAssignInitializer::get_childIndex(SgNode *child) const {
if (child == p_operand_i) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgDesignatedInitializer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_designatorList);
traversalSuccessorContainer.push_back(p_memberInit);
return traversalSuccessorContainer;
}
vector<string>
SgDesignatedInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_designatorList");
traversalSuccessorContainer.push_back("p_memberInit");
return traversalSuccessorContainer;
}
size_t
SgDesignatedInitializer::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDesignatedInitializer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_designatorList == NULL || p_designatorList != NULL); return p_designatorList;
case 1: ROSE_ASSERT(p_memberInit == NULL || p_memberInit != NULL); return p_memberInit;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDesignatedInitializer::get_childIndex(SgNode *child) const {
if (child == p_designatorList) return 0;
else if (child == p_memberInit) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgBracedInitializer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_initializers);
return traversalSuccessorContainer;
}
vector<string>
SgBracedInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_initializers");
return traversalSuccessorContainer;
}
size_t
SgBracedInitializer::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgBracedInitializer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_initializers == NULL || p_initializers != NULL); return p_initializers;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgBracedInitializer::get_childIndex(SgNode *child) const {
if (child == p_initializers) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaAncestorInitializer::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_ancestor);
return traversalSuccessorContainer;
}
vector<string>
SgAdaAncestorInitializer::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_ancestor");
return traversalSuccessorContainer;
}
size_t
SgAdaAncestorInitializer::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaAncestorInitializer::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_ancestor == NULL || p_ancestor != NULL); return p_ancestor;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaAncestorInitializer::get_childIndex(SgNode *child) const {
if (child == p_ancestor) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgVarArgStartOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand);
traversalSuccessorContainer.push_back(p_rhs_operand);
return traversalSuccessorContainer;
}
vector<string>
SgVarArgStartOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand");
traversalSuccessorContainer.push_back("p_rhs_operand");
return traversalSuccessorContainer;
}
size_t
SgVarArgStartOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgVarArgStartOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand == NULL || p_lhs_operand != NULL); return p_lhs_operand;
case 1: ROSE_ASSERT(p_rhs_operand == NULL || p_rhs_operand != NULL); return p_rhs_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgVarArgStartOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand) return 0;
else if (child == p_rhs_operand) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgVarArgOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgVarArgOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgVarArgOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgVarArgOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgVarArgOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgVarArgEndOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgVarArgEndOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgVarArgEndOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgVarArgEndOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgVarArgEndOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgVarArgCopyOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs_operand);
traversalSuccessorContainer.push_back(p_rhs_operand);
return traversalSuccessorContainer;
}
vector<string>
SgVarArgCopyOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs_operand");
traversalSuccessorContainer.push_back("p_rhs_operand");
return traversalSuccessorContainer;
}
size_t
SgVarArgCopyOp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgVarArgCopyOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs_operand == NULL || p_lhs_operand != NULL); return p_lhs_operand;
case 1: ROSE_ASSERT(p_rhs_operand == NULL || p_rhs_operand != NULL); return p_rhs_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgVarArgCopyOp::get_childIndex(SgNode *child) const {
if (child == p_lhs_operand) return 0;
else if (child == p_rhs_operand) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgVarArgStartOneOperandOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgVarArgStartOneOperandOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgVarArgStartOneOperandOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgVarArgStartOneOperandOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgVarArgStartOneOperandOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgNullExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNullExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNullExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNullExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNullExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNullExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNullExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgVariantExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgVariantExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgVariantExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgVariantExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgVariantExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgVariantExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgVariantExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgSubscriptExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_lowerBound);
traversalSuccessorContainer.push_back(p_upperBound);
traversalSuccessorContainer.push_back(p_stride);
return traversalSuccessorContainer;
}
vector<string>
SgSubscriptExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lowerBound");
traversalSuccessorContainer.push_back("p_upperBound");
traversalSuccessorContainer.push_back("p_stride");
return traversalSuccessorContainer;
}
size_t
SgSubscriptExpression::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgSubscriptExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lowerBound == NULL || p_lowerBound != NULL); return p_lowerBound;
case 1: ROSE_ASSERT(p_upperBound == NULL || p_upperBound != NULL); return p_upperBound;
case 2: ROSE_ASSERT(p_stride == NULL || p_stride != NULL); return p_stride;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSubscriptExpression::get_childIndex(SgNode *child) const {
if (child == p_lowerBound) return 0;
else if (child == p_upperBound) return 1;
else if (child == p_stride) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgColonShapeExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgColonShapeExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgColonShapeExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgColonShapeExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgColonShapeExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgColonShapeExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgColonShapeExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsteriskShapeExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsteriskShapeExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsteriskShapeExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsteriskShapeExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsteriskShapeExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsteriskShapeExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsteriskShapeExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgImpliedDo::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_do_var_initialization);
traversalSuccessorContainer.push_back(p_last_val);
traversalSuccessorContainer.push_back(p_increment);
traversalSuccessorContainer.push_back(p_object_list);
return traversalSuccessorContainer;
}
vector<string>
SgImpliedDo::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_do_var_initialization");
traversalSuccessorContainer.push_back("p_last_val");
traversalSuccessorContainer.push_back("p_increment");
traversalSuccessorContainer.push_back("p_object_list");
return traversalSuccessorContainer;
}
size_t
SgImpliedDo::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgImpliedDo::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_do_var_initialization == NULL || p_do_var_initialization != NULL); return p_do_var_initialization;
case 1: ROSE_ASSERT(p_last_val == NULL || p_last_val != NULL); return p_last_val;
case 2: ROSE_ASSERT(p_increment == NULL || p_increment != NULL); return p_increment;
case 3: ROSE_ASSERT(p_object_list == NULL || p_object_list != NULL); return p_object_list;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgImpliedDo::get_childIndex(SgNode *child) const {
if (child == p_do_var_initialization) return 0;
else if (child == p_last_val) return 1;
else if (child == p_increment) return 2;
else if (child == p_object_list) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgIOItemExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_io_item);
return traversalSuccessorContainer;
}
vector<string>
SgIOItemExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_io_item");
return traversalSuccessorContainer;
}
size_t
SgIOItemExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgIOItemExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_io_item == NULL || p_io_item != NULL); return p_io_item;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgIOItemExpression::get_childIndex(SgNode *child) const {
if (child == p_io_item) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgActualArgumentExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgActualArgumentExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgActualArgumentExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgActualArgumentExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgActualArgumentExpression::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgStatementExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_statement);
return traversalSuccessorContainer;
}
vector<string>
SgStatementExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_statement");
return traversalSuccessorContainer;
}
size_t
SgStatementExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgStatementExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_statement == NULL || p_statement != NULL); return p_statement;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgStatementExpression::get_childIndex(SgNode *child) const {
if (child == p_statement) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgAsmOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgAsmOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmOp::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgCudaKernelExecConfig::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_grid);
traversalSuccessorContainer.push_back(p_blocks);
traversalSuccessorContainer.push_back(p_shared);
traversalSuccessorContainer.push_back(p_stream);
return traversalSuccessorContainer;
}
vector<string>
SgCudaKernelExecConfig::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_grid");
traversalSuccessorContainer.push_back("p_blocks");
traversalSuccessorContainer.push_back("p_shared");
traversalSuccessorContainer.push_back("p_stream");
return traversalSuccessorContainer;
}
size_t
SgCudaKernelExecConfig::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgCudaKernelExecConfig::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_grid == NULL || p_grid != NULL); return p_grid;
case 1: ROSE_ASSERT(p_blocks == NULL || p_blocks != NULL); return p_blocks;
case 2: ROSE_ASSERT(p_shared == NULL || p_shared != NULL); return p_shared;
case 3: ROSE_ASSERT(p_stream == NULL || p_stream != NULL); return p_stream;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCudaKernelExecConfig::get_childIndex(SgNode *child) const {
if (child == p_grid) return 0;
else if (child == p_blocks) return 1;
else if (child == p_shared) return 2;
else if (child == p_stream) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgUnknownArrayOrFunctionReference::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_named_reference);
traversalSuccessorContainer.push_back(p_expression_list);
return traversalSuccessorContainer;
}
vector<string>
SgUnknownArrayOrFunctionReference::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_named_reference");
traversalSuccessorContainer.push_back("p_expression_list");
return traversalSuccessorContainer;
}
size_t
SgUnknownArrayOrFunctionReference::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgUnknownArrayOrFunctionReference::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_named_reference == NULL || p_named_reference != NULL); return p_named_reference;
case 1: ROSE_ASSERT(p_expression_list == NULL || p_expression_list != NULL); return p_expression_list;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgUnknownArrayOrFunctionReference::get_childIndex(SgNode *child) const {
if (child == p_named_reference) return 0;
else if (child == p_expression_list) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgPseudoDestructorRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgPseudoDestructorRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgPseudoDestructorRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgPseudoDestructorRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgPseudoDestructorRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgPseudoDestructorRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgPseudoDestructorRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgCAFCoExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_referData);
return traversalSuccessorContainer;
}
vector<string>
SgCAFCoExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_referData");
return traversalSuccessorContainer;
}
size_t
SgCAFCoExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgCAFCoExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_referData == NULL || p_referData != NULL); return p_referData;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgCAFCoExpression::get_childIndex(SgNode *child) const {
if (child == p_referData) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgSizeOfOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgSizeOfOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgSizeOfOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgSizeOfOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSizeOfOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgLambdaRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_functionDeclaration);
return traversalSuccessorContainer;
}
vector<string>
SgLambdaRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_functionDeclaration");
return traversalSuccessorContainer;
}
size_t
SgLambdaRefExp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgLambdaRefExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_functionDeclaration == NULL || p_functionDeclaration != NULL); return p_functionDeclaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLambdaRefExp::get_childIndex(SgNode *child) const {
if (child == p_functionDeclaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgDictionaryExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_key_datum_pairs.size() + 0);
   {
     SgKeyDatumPairPtrList::const_iterator iter;
     for (iter = p_key_datum_pairs.begin(); iter != p_key_datum_pairs.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgDictionaryExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgKeyDatumPairPtrList::const_iterator  iter;
     for (iter = p_key_datum_pairs.begin(); iter != p_key_datum_pairs.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgDictionaryExp::get_numberOfTraversalSuccessors() const {
return p_key_datum_pairs.size() + 0;
}
SgNode *
SgDictionaryExp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_key_datum_pairs.size());
return p_key_datum_pairs[idx];
}
size_t
SgDictionaryExp::get_childIndex(SgNode *child) const {
SgKeyDatumPairPtrList::const_iterator itr = find(p_key_datum_pairs.begin(), p_key_datum_pairs.end(), child);
if (itr != p_key_datum_pairs.end()) return itr - p_key_datum_pairs.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgKeyDatumPair::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_key);
traversalSuccessorContainer.push_back(p_datum);
return traversalSuccessorContainer;
}
vector<string>
SgKeyDatumPair::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_key");
traversalSuccessorContainer.push_back("p_datum");
return traversalSuccessorContainer;
}
size_t
SgKeyDatumPair::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgKeyDatumPair::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_key == NULL || p_key != NULL); return p_key;
case 1: ROSE_ASSERT(p_datum == NULL || p_datum != NULL); return p_datum;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgKeyDatumPair::get_childIndex(SgNode *child) const {
if (child == p_key) return 0;
else if (child == p_datum) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgReferenceExp::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgReferenceExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgReferenceExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgReferenceExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgReferenceExp::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgReferenceExp" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgReferenceExp::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgReferenceExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgReferenceExp::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgReferenceExp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgVarRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgVarRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgVarRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgVarRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgVarRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgVarRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgVarRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgLabelRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgLabelRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgLabelRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgLabelRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgLabelRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgLabelRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgLabelRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgClassNameRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgClassNameRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgClassNameRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgClassNameRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgClassNameRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgClassNameRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgClassNameRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgNonrealRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgNonrealRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgNonrealRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgNonrealRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgNonrealRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgNonrealRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgNonrealRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgScopedRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgScopedRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgScopedRefExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgScopedRefExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgScopedRefExp::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgTypeRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTypeRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTypeRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTypeRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTypeRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTypeRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTypeRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFunctionRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFunctionRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFunctionRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFunctionRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFunctionRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgMemberFunctionRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgMemberFunctionRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgMemberFunctionRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgMemberFunctionRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgMemberFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgMemberFunctionRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgMemberFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateFunctionRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTemplateFunctionRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTemplateFunctionRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTemplateFunctionRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTemplateFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTemplateFunctionRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTemplateFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateMemberFunctionRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTemplateMemberFunctionRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTemplateMemberFunctionRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTemplateMemberFunctionRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTemplateMemberFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTemplateMemberFunctionRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTemplateMemberFunctionRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgComprehension::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_target);
traversalSuccessorContainer.push_back(p_iter);
traversalSuccessorContainer.push_back(p_filters);
return traversalSuccessorContainer;
}
vector<string>
SgComprehension::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_target");
traversalSuccessorContainer.push_back("p_iter");
traversalSuccessorContainer.push_back("p_filters");
return traversalSuccessorContainer;
}
size_t
SgComprehension::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgComprehension::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_target == NULL || p_target != NULL); return p_target;
case 1: ROSE_ASSERT(p_iter == NULL || p_iter != NULL); return p_iter;
case 2: ROSE_ASSERT(p_filters == NULL || p_filters != NULL); return p_filters;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgComprehension::get_childIndex(SgNode *child) const {
if (child == p_target) return 0;
else if (child == p_iter) return 1;
else if (child == p_filters) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgListComprehension::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_element);
traversalSuccessorContainer.push_back(p_generators);
return traversalSuccessorContainer;
}
vector<string>
SgListComprehension::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_element");
traversalSuccessorContainer.push_back("p_generators");
return traversalSuccessorContainer;
}
size_t
SgListComprehension::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgListComprehension::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_element == NULL || p_element != NULL); return p_element;
case 1: ROSE_ASSERT(p_generators == NULL || p_generators != NULL); return p_generators;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgListComprehension::get_childIndex(SgNode *child) const {
if (child == p_element) return 0;
else if (child == p_generators) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgSetComprehension::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_element);
traversalSuccessorContainer.push_back(p_generators);
return traversalSuccessorContainer;
}
vector<string>
SgSetComprehension::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_element");
traversalSuccessorContainer.push_back("p_generators");
return traversalSuccessorContainer;
}
size_t
SgSetComprehension::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgSetComprehension::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_element == NULL || p_element != NULL); return p_element;
case 1: ROSE_ASSERT(p_generators == NULL || p_generators != NULL); return p_generators;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgSetComprehension::get_childIndex(SgNode *child) const {
if (child == p_element) return 0;
else if (child == p_generators) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgDictionaryComprehension::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_element);
traversalSuccessorContainer.push_back(p_generators);
return traversalSuccessorContainer;
}
vector<string>
SgDictionaryComprehension::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_element");
traversalSuccessorContainer.push_back("p_generators");
return traversalSuccessorContainer;
}
size_t
SgDictionaryComprehension::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgDictionaryComprehension::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_element == NULL || p_element != NULL); return p_element;
case 1: ROSE_ASSERT(p_generators == NULL || p_generators != NULL); return p_generators;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgDictionaryComprehension::get_childIndex(SgNode *child) const {
if (child == p_element) return 0;
else if (child == p_generators) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgNaryOp::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgNaryOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgNaryOp::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNaryOp" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgNaryOp::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgNaryOp::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgNaryOp" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgNaryBooleanOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_operands.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgNaryBooleanOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgNaryBooleanOp::get_numberOfTraversalSuccessors() const {
return p_operands.size() + 0;
}
SgNode *
SgNaryBooleanOp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_operands.size());
return p_operands[idx];
}
size_t
SgNaryBooleanOp::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_operands.begin(), p_operands.end(), child);
if (itr != p_operands.end()) return itr - p_operands.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgNaryComparisonOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_operands.size() + 0);
   {
     SgExpressionPtrList::const_iterator iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgNaryComparisonOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgExpressionPtrList::const_iterator  iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgNaryComparisonOp::get_numberOfTraversalSuccessors() const {
return p_operands.size() + 0;
}
SgNode *
SgNaryComparisonOp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_operands.size());
return p_operands[idx];
}
size_t
SgNaryComparisonOp::get_childIndex(SgNode *child) const {
SgExpressionPtrList::const_iterator itr = find(p_operands.begin(), p_operands.end(), child);
if (itr != p_operands.end()) return itr - p_operands.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgStringConversion::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgStringConversion::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgStringConversion::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgStringConversion::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgStringConversion::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgYieldExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_value);
return traversalSuccessorContainer;
}
vector<string>
SgYieldExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_value");
return traversalSuccessorContainer;
}
size_t
SgYieldExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgYieldExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_value == NULL || p_value != NULL); return p_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgYieldExpression::get_childIndex(SgNode *child) const {
if (child == p_value) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAlignOfOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgAlignOfOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgAlignOfOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAlignOfOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAlignOfOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgRangeExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_start);
traversalSuccessorContainer.push_back(p_end);
traversalSuccessorContainer.push_back(p_stride);
return traversalSuccessorContainer;
}
vector<string>
SgRangeExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_start");
traversalSuccessorContainer.push_back("p_end");
traversalSuccessorContainer.push_back("p_stride");
return traversalSuccessorContainer;
}
size_t
SgRangeExp::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgRangeExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_start == NULL || p_start != NULL); return p_start;
case 1: ROSE_ASSERT(p_end == NULL || p_end != NULL); return p_end;
case 2: ROSE_ASSERT(p_stride == NULL || p_stride != NULL); return p_stride;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRangeExp::get_childIndex(SgNode *child) const {
if (child == p_start) return 0;
else if (child == p_end) return 1;
else if (child == p_stride) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgMagicColonExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgMagicColonExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgMagicColonExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgMagicColonExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgMagicColonExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgMagicColonExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgMagicColonExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTypeTraitBuiltinOperator::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTypeTraitBuiltinOperator::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTypeTraitBuiltinOperator::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTypeTraitBuiltinOperator::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTypeTraitBuiltinOperator" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTypeTraitBuiltinOperator::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTypeTraitBuiltinOperator" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgCompoundLiteralExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgCompoundLiteralExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgCompoundLiteralExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgCompoundLiteralExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgCompoundLiteralExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgCompoundLiteralExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgCompoundLiteralExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaAnnotation::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgJavaAnnotation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgJavaAnnotation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgJavaAnnotation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgJavaAnnotation::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgJavaAnnotation" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgJavaAnnotation::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgJavaAnnotation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgJavaAnnotation::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgJavaAnnotation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgJavaMarkerAnnotation::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJavaMarkerAnnotation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJavaMarkerAnnotation::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJavaMarkerAnnotation::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJavaMarkerAnnotation" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJavaMarkerAnnotation::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJavaMarkerAnnotation" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaSingleMemberAnnotation::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_value);
return traversalSuccessorContainer;
}
vector<string>
SgJavaSingleMemberAnnotation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_value");
return traversalSuccessorContainer;
}
size_t
SgJavaSingleMemberAnnotation::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJavaSingleMemberAnnotation::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_value == NULL || p_value != NULL); return p_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaSingleMemberAnnotation::get_childIndex(SgNode *child) const {
if (child == p_value) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgJavaNormalAnnotation::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_value_pair_list.size() + 0);
   {
     SgJavaMemberValuePairPtrList::const_iterator iter;
     for (iter = p_value_pair_list.begin(); iter != p_value_pair_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgJavaNormalAnnotation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgJavaMemberValuePairPtrList::const_iterator  iter;
     for (iter = p_value_pair_list.begin(); iter != p_value_pair_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgJavaNormalAnnotation::get_numberOfTraversalSuccessors() const {
return p_value_pair_list.size() + 0;
}
SgNode *
SgJavaNormalAnnotation::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_value_pair_list.size());
return p_value_pair_list[idx];
}
size_t
SgJavaNormalAnnotation::get_childIndex(SgNode *child) const {
SgJavaMemberValuePairPtrList::const_iterator itr = find(p_value_pair_list.begin(), p_value_pair_list.end(), child);
if (itr != p_value_pair_list.end()) return itr - p_value_pair_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgJavaTypeExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgJavaTypeExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgJavaTypeExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgJavaTypeExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgJavaTypeExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgJavaTypeExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgJavaTypeExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTypeExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTypeExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTypeExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTypeExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTypeExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTypeExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTypeExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgClassExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgClassExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgClassExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgClassExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgClassExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgClassExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgClassExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFunctionParameterRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_parameter_expression);
return traversalSuccessorContainer;
}
vector<string>
SgFunctionParameterRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_parameter_expression");
return traversalSuccessorContainer;
}
size_t
SgFunctionParameterRefExp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgFunctionParameterRefExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_parameter_expression == NULL || p_parameter_expression != NULL); return p_parameter_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFunctionParameterRefExp::get_childIndex(SgNode *child) const {
if (child == p_parameter_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgLambdaExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_lambda_capture_list);
traversalSuccessorContainer.push_back(p_lambda_closure_class);
traversalSuccessorContainer.push_back(p_lambda_function);
return traversalSuccessorContainer;
}
vector<string>
SgLambdaExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lambda_capture_list");
traversalSuccessorContainer.push_back("p_lambda_closure_class");
traversalSuccessorContainer.push_back("p_lambda_function");
return traversalSuccessorContainer;
}
size_t
SgLambdaExp::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgLambdaExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lambda_capture_list == NULL || p_lambda_capture_list != NULL); return p_lambda_capture_list;
case 1: ROSE_ASSERT(p_lambda_closure_class == NULL || p_lambda_closure_class != NULL); return p_lambda_closure_class;
case 2: ROSE_ASSERT(p_lambda_function == NULL || p_lambda_function != NULL); return p_lambda_function;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLambdaExp::get_childIndex(SgNode *child) const {
if (child == p_lambda_capture_list) return 0;
else if (child == p_lambda_closure_class) return 1;
else if (child == p_lambda_function) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgHereExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_expression);
return traversalSuccessorContainer;
}
vector<string>
SgHereExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
return traversalSuccessorContainer;
}
size_t
SgHereExp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgHereExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgHereExp::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAtExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAtExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAtExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAtExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAtExp::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgFinishExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_expression);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgFinishExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_expression");
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgFinishExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgFinishExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_expression == NULL || p_expression != NULL); return p_expression;
case 1: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFinishExp::get_childIndex(SgNode *child) const {
if (child == p_expression) return 0;
else if (child == p_body) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgNoexceptOp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand_expr);
return traversalSuccessorContainer;
}
vector<string>
SgNoexceptOp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand_expr");
return traversalSuccessorContainer;
}
size_t
SgNoexceptOp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgNoexceptOp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand_expr == NULL || p_operand_expr != NULL); return p_operand_expr;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNoexceptOp::get_childIndex(SgNode *child) const {
if (child == p_operand_expr) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaTaskRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaTaskRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaTaskRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaTaskRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaTaskRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAdaProtectedRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaProtectedRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaProtectedRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaProtectedRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaProtectedRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgFoldExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operands);
return traversalSuccessorContainer;
}
vector<string>
SgFoldExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operands");
return traversalSuccessorContainer;
}
size_t
SgFoldExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgFoldExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operands == NULL || p_operands != NULL); return p_operands;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFoldExpression::get_childIndex(SgNode *child) const {
if (child == p_operands) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAwaitExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_value);
return traversalSuccessorContainer;
}
vector<string>
SgAwaitExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_value");
return traversalSuccessorContainer;
}
size_t
SgAwaitExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAwaitExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_value == NULL || p_value != NULL); return p_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAwaitExpression::get_childIndex(SgNode *child) const {
if (child == p_value) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgChooseExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_value);
return traversalSuccessorContainer;
}
vector<string>
SgChooseExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_value");
return traversalSuccessorContainer;
}
size_t
SgChooseExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgChooseExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_value == NULL || p_value != NULL); return p_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgChooseExpression::get_childIndex(SgNode *child) const {
if (child == p_value) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaAttributeExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_object);
traversalSuccessorContainer.push_back(p_args);
return traversalSuccessorContainer;
}
vector<string>
SgAdaAttributeExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_object");
traversalSuccessorContainer.push_back("p_args");
return traversalSuccessorContainer;
}
size_t
SgAdaAttributeExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAdaAttributeExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_object == NULL || p_object != NULL); return p_object;
case 1: ROSE_ASSERT(p_args == NULL || p_args != NULL); return p_args;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaAttributeExp::get_childIndex(SgNode *child) const {
if (child == p_object) return 0;
else if (child == p_args) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgJovialTablePresetExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_preset_list);
return traversalSuccessorContainer;
}
vector<string>
SgJovialTablePresetExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_preset_list");
return traversalSuccessorContainer;
}
size_t
SgJovialTablePresetExp::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJovialTablePresetExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_preset_list == NULL || p_preset_list != NULL); return p_preset_list;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJovialTablePresetExp::get_childIndex(SgNode *child) const {
if (child == p_preset_list) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgJovialPresetPositionExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_indices);
traversalSuccessorContainer.push_back(p_value);
return traversalSuccessorContainer;
}
vector<string>
SgJovialPresetPositionExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_indices");
traversalSuccessorContainer.push_back("p_value");
return traversalSuccessorContainer;
}
size_t
SgJovialPresetPositionExp::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgJovialPresetPositionExp::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_indices == NULL || p_indices != NULL); return p_indices;
case 1: ROSE_ASSERT(p_value == NULL || p_value != NULL); return p_value;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJovialPresetPositionExp::get_childIndex(SgNode *child) const {
if (child == p_indices) return 0;
else if (child == p_value) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaOthersExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaOthersExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaOthersExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaOthersExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaOthersExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaOthersExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaOthersExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAdaRenamingRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaRenamingRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaRenamingRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaRenamingRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaRenamingRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaRenamingRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaRenamingRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAdaUnitRefExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAdaUnitRefExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAdaUnitRefExp::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAdaUnitRefExp::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAdaUnitRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAdaUnitRefExp::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAdaUnitRefExp" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgSymbol::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgSymbol::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSymbol" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgSymbol::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgSymbol::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgVariableSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgVariableSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgVariableSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgVariableSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgVariableSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgVariableSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgVariableSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateVariableSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTemplateVariableSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTemplateVariableSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTemplateVariableSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTemplateVariableSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTemplateVariableSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTemplateVariableSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgNonrealSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgNonrealSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgNonrealSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgNonrealSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNonrealSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgFunctionSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgFunctionSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgFunctionSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgFunctionSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgMemberFunctionSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgMemberFunctionSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgMemberFunctionSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgMemberFunctionSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgMemberFunctionSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateMemberFunctionSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateMemberFunctionSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateMemberFunctionSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateMemberFunctionSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateMemberFunctionSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateFunctionSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateFunctionSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateFunctionSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateFunctionSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateFunctionSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgRenameSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_declaration);
traversalSuccessorContainer.push_back(p_original_symbol);
return traversalSuccessorContainer;
}
vector<string>
SgRenameSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
traversalSuccessorContainer.push_back("p_original_symbol");
return traversalSuccessorContainer;
}
size_t
SgRenameSymbol::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgRenameSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
case 1: ROSE_ASSERT(p_original_symbol == NULL || p_original_symbol != NULL); return p_original_symbol;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgRenameSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else if (child == p_original_symbol) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaInheritedFunctionSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaInheritedFunctionSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaInheritedFunctionSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaInheritedFunctionSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaInheritedFunctionSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgFunctionTypeSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgFunctionTypeSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgFunctionTypeSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgFunctionTypeSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgFunctionTypeSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgFunctionTypeSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgFunctionTypeSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTemplateSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgEnumFieldSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgEnumFieldSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgEnumFieldSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgEnumFieldSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgEnumFieldSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgEnumFieldSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgEnumFieldSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgTypeSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgTypeSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgTypeSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgTypeSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgTypeSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgTypeSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgTypeSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgClassSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgClassSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgClassSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgClassSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgClassSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateClassSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateClassSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateClassSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateClassSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateClassSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTypedefSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTypedefSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTypedefSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTypedefSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTypedefSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgTemplateTypedefSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgTemplateTypedefSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgTemplateTypedefSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgTemplateTypedefSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgTemplateTypedefSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgEnumSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgEnumSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgEnumSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgEnumSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgEnumSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgLabelSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgLabelSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgLabelSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgLabelSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgLabelSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgDefaultSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgDefaultSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgDefaultSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgDefaultSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgDefaultSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgDefaultSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgDefaultSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgNamespaceSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_declaration);
traversalSuccessorContainer.push_back(p_aliasDeclaration);
return traversalSuccessorContainer;
}
vector<string>
SgNamespaceSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
traversalSuccessorContainer.push_back("p_aliasDeclaration");
return traversalSuccessorContainer;
}
size_t
SgNamespaceSymbol::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgNamespaceSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
case 1: ROSE_ASSERT(p_aliasDeclaration == NULL || p_aliasDeclaration != NULL); return p_aliasDeclaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgNamespaceSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else if (child == p_aliasDeclaration) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgIntrinsicSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgIntrinsicSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgIntrinsicSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgIntrinsicSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgIntrinsicSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgIntrinsicSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgIntrinsicSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgModuleSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgModuleSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgModuleSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgModuleSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgModuleSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgInterfaceSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgInterfaceSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgInterfaceSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgInterfaceSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgInterfaceSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgInterfaceSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgInterfaceSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgCommonSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgCommonSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgCommonSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgCommonSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgCommonSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgCommonSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgCommonSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAliasSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_alias);
return traversalSuccessorContainer;
}
vector<string>
SgAliasSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_alias");
return traversalSuccessorContainer;
}
size_t
SgAliasSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAliasSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_alias == NULL || p_alias != NULL); return p_alias;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAliasSymbol::get_childIndex(SgNode *child) const {
if (child == p_alias) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryAddressSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryAddressSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryAddressSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmBinaryAddressSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmBinaryAddressSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmBinaryAddressSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmBinaryAddressSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmBinaryDataSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryDataSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryDataSymbol::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmBinaryDataSymbol::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmBinaryDataSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmBinaryDataSymbol::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmBinaryDataSymbol" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgJavaLabelSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgJavaLabelSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgJavaLabelSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgJavaLabelSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgJavaLabelSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaPackageSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaPackageSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaPackageSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaPackageSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaPackageSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaTaskSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaTaskSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaTaskSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaTaskSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaTaskSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaProtectedSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaProtectedSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaProtectedSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaProtectedSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaProtectedSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaRenamingSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaRenamingSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaRenamingSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaRenamingSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaRenamingSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaGenericSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaGenericSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaGenericSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaGenericSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaGenericSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaGenericInstanceSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaGenericInstanceSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaGenericInstanceSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaGenericInstanceSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaGenericInstanceSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAdaFormalPackageSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_declaration);
return traversalSuccessorContainer;
}
vector<string>
SgAdaFormalPackageSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_declaration");
return traversalSuccessorContainer;
}
size_t
SgAdaFormalPackageSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAdaFormalPackageSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_declaration == NULL || p_declaration != NULL); return p_declaration;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAdaFormalPackageSymbol::get_childIndex(SgNode *child) const {
if (child == p_declaration) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmNode::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmNode::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmNode::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmNode" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmNode::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmNode::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmCilNode::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmCilNode::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmCilNode::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilNode" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmCilNode::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmCilNode::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmCilDataStream::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilDataStream" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmCilDataStream::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilDataStream" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmCilDataStream::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilDataStream" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmCilDataStream::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilDataStream" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmCilDataStream::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilDataStream" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmCilErrorHeap::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilErrorHeap::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilErrorHeap::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilErrorHeap::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilErrorHeap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilErrorHeap::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilErrorHeap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilMetadataHeap::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(38);
traversalSuccessorContainer.push_back(p_AssemblyTable);
traversalSuccessorContainer.push_back(p_AssemblyOSTable);
traversalSuccessorContainer.push_back(p_AssemblyProcessorTable);
traversalSuccessorContainer.push_back(p_AssemblyRefTable);
traversalSuccessorContainer.push_back(p_AssemblyRefOSTable);
traversalSuccessorContainer.push_back(p_AssemblyRefProcessorTable);
traversalSuccessorContainer.push_back(p_ClassLayoutTable);
traversalSuccessorContainer.push_back(p_ConstantTable);
traversalSuccessorContainer.push_back(p_CustomAttributeTable);
traversalSuccessorContainer.push_back(p_DeclSecurityTable);
traversalSuccessorContainer.push_back(p_EventTable);
traversalSuccessorContainer.push_back(p_EventMapTable);
traversalSuccessorContainer.push_back(p_ExportedTypeTable);
traversalSuccessorContainer.push_back(p_FieldTable);
traversalSuccessorContainer.push_back(p_FieldLayoutTable);
traversalSuccessorContainer.push_back(p_FieldMarshalTable);
traversalSuccessorContainer.push_back(p_FieldRVATable);
traversalSuccessorContainer.push_back(p_FileTable);
traversalSuccessorContainer.push_back(p_GenericParamTable);
traversalSuccessorContainer.push_back(p_GenericParamConstraintTable);
traversalSuccessorContainer.push_back(p_ImplMapTable);
traversalSuccessorContainer.push_back(p_InterfaceImplTable);
traversalSuccessorContainer.push_back(p_ManifestResourceTable);
traversalSuccessorContainer.push_back(p_MemberRefTable);
traversalSuccessorContainer.push_back(p_MethodDefTable);
traversalSuccessorContainer.push_back(p_MethodImplTable);
traversalSuccessorContainer.push_back(p_MethodSemanticsTable);
traversalSuccessorContainer.push_back(p_MethodSpecTable);
traversalSuccessorContainer.push_back(p_ModuleTable);
traversalSuccessorContainer.push_back(p_ModuleRefTable);
traversalSuccessorContainer.push_back(p_NestedClassTable);
traversalSuccessorContainer.push_back(p_ParamTable);
traversalSuccessorContainer.push_back(p_PropertyTable);
traversalSuccessorContainer.push_back(p_PropertyMapTable);
traversalSuccessorContainer.push_back(p_StandAloneSigTable);
traversalSuccessorContainer.push_back(p_TypeDefTable);
traversalSuccessorContainer.push_back(p_TypeRefTable);
traversalSuccessorContainer.push_back(p_TypeSpecTable);
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMetadataHeap::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_AssemblyTable");
traversalSuccessorContainer.push_back("p_AssemblyOSTable");
traversalSuccessorContainer.push_back("p_AssemblyProcessorTable");
traversalSuccessorContainer.push_back("p_AssemblyRefTable");
traversalSuccessorContainer.push_back("p_AssemblyRefOSTable");
traversalSuccessorContainer.push_back("p_AssemblyRefProcessorTable");
traversalSuccessorContainer.push_back("p_ClassLayoutTable");
traversalSuccessorContainer.push_back("p_ConstantTable");
traversalSuccessorContainer.push_back("p_CustomAttributeTable");
traversalSuccessorContainer.push_back("p_DeclSecurityTable");
traversalSuccessorContainer.push_back("p_EventTable");
traversalSuccessorContainer.push_back("p_EventMapTable");
traversalSuccessorContainer.push_back("p_ExportedTypeTable");
traversalSuccessorContainer.push_back("p_FieldTable");
traversalSuccessorContainer.push_back("p_FieldLayoutTable");
traversalSuccessorContainer.push_back("p_FieldMarshalTable");
traversalSuccessorContainer.push_back("p_FieldRVATable");
traversalSuccessorContainer.push_back("p_FileTable");
traversalSuccessorContainer.push_back("p_GenericParamTable");
traversalSuccessorContainer.push_back("p_GenericParamConstraintTable");
traversalSuccessorContainer.push_back("p_ImplMapTable");
traversalSuccessorContainer.push_back("p_InterfaceImplTable");
traversalSuccessorContainer.push_back("p_ManifestResourceTable");
traversalSuccessorContainer.push_back("p_MemberRefTable");
traversalSuccessorContainer.push_back("p_MethodDefTable");
traversalSuccessorContainer.push_back("p_MethodImplTable");
traversalSuccessorContainer.push_back("p_MethodSemanticsTable");
traversalSuccessorContainer.push_back("p_MethodSpecTable");
traversalSuccessorContainer.push_back("p_ModuleTable");
traversalSuccessorContainer.push_back("p_ModuleRefTable");
traversalSuccessorContainer.push_back("p_NestedClassTable");
traversalSuccessorContainer.push_back("p_ParamTable");
traversalSuccessorContainer.push_back("p_PropertyTable");
traversalSuccessorContainer.push_back("p_PropertyMapTable");
traversalSuccessorContainer.push_back("p_StandAloneSigTable");
traversalSuccessorContainer.push_back("p_TypeDefTable");
traversalSuccessorContainer.push_back("p_TypeRefTable");
traversalSuccessorContainer.push_back("p_TypeSpecTable");
return traversalSuccessorContainer;
}
size_t
SgAsmCilMetadataHeap::get_numberOfTraversalSuccessors() const {
return 38;
}
SgNode *
SgAsmCilMetadataHeap::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_AssemblyTable == NULL || p_AssemblyTable != NULL); return p_AssemblyTable;
case 1: ROSE_ASSERT(p_AssemblyOSTable == NULL || p_AssemblyOSTable != NULL); return p_AssemblyOSTable;
case 2: ROSE_ASSERT(p_AssemblyProcessorTable == NULL || p_AssemblyProcessorTable != NULL); return p_AssemblyProcessorTable;
case 3: ROSE_ASSERT(p_AssemblyRefTable == NULL || p_AssemblyRefTable != NULL); return p_AssemblyRefTable;
case 4: ROSE_ASSERT(p_AssemblyRefOSTable == NULL || p_AssemblyRefOSTable != NULL); return p_AssemblyRefOSTable;
case 5: ROSE_ASSERT(p_AssemblyRefProcessorTable == NULL || p_AssemblyRefProcessorTable != NULL); return p_AssemblyRefProcessorTable;
case 6: ROSE_ASSERT(p_ClassLayoutTable == NULL || p_ClassLayoutTable != NULL); return p_ClassLayoutTable;
case 7: ROSE_ASSERT(p_ConstantTable == NULL || p_ConstantTable != NULL); return p_ConstantTable;
case 8: ROSE_ASSERT(p_CustomAttributeTable == NULL || p_CustomAttributeTable != NULL); return p_CustomAttributeTable;
case 9: ROSE_ASSERT(p_DeclSecurityTable == NULL || p_DeclSecurityTable != NULL); return p_DeclSecurityTable;
case 10: ROSE_ASSERT(p_EventTable == NULL || p_EventTable != NULL); return p_EventTable;
case 11: ROSE_ASSERT(p_EventMapTable == NULL || p_EventMapTable != NULL); return p_EventMapTable;
case 12: ROSE_ASSERT(p_ExportedTypeTable == NULL || p_ExportedTypeTable != NULL); return p_ExportedTypeTable;
case 13: ROSE_ASSERT(p_FieldTable == NULL || p_FieldTable != NULL); return p_FieldTable;
case 14: ROSE_ASSERT(p_FieldLayoutTable == NULL || p_FieldLayoutTable != NULL); return p_FieldLayoutTable;
case 15: ROSE_ASSERT(p_FieldMarshalTable == NULL || p_FieldMarshalTable != NULL); return p_FieldMarshalTable;
case 16: ROSE_ASSERT(p_FieldRVATable == NULL || p_FieldRVATable != NULL); return p_FieldRVATable;
case 17: ROSE_ASSERT(p_FileTable == NULL || p_FileTable != NULL); return p_FileTable;
case 18: ROSE_ASSERT(p_GenericParamTable == NULL || p_GenericParamTable != NULL); return p_GenericParamTable;
case 19: ROSE_ASSERT(p_GenericParamConstraintTable == NULL || p_GenericParamConstraintTable != NULL); return p_GenericParamConstraintTable;
case 20: ROSE_ASSERT(p_ImplMapTable == NULL || p_ImplMapTable != NULL); return p_ImplMapTable;
case 21: ROSE_ASSERT(p_InterfaceImplTable == NULL || p_InterfaceImplTable != NULL); return p_InterfaceImplTable;
case 22: ROSE_ASSERT(p_ManifestResourceTable == NULL || p_ManifestResourceTable != NULL); return p_ManifestResourceTable;
case 23: ROSE_ASSERT(p_MemberRefTable == NULL || p_MemberRefTable != NULL); return p_MemberRefTable;
case 24: ROSE_ASSERT(p_MethodDefTable == NULL || p_MethodDefTable != NULL); return p_MethodDefTable;
case 25: ROSE_ASSERT(p_MethodImplTable == NULL || p_MethodImplTable != NULL); return p_MethodImplTable;
case 26: ROSE_ASSERT(p_MethodSemanticsTable == NULL || p_MethodSemanticsTable != NULL); return p_MethodSemanticsTable;
case 27: ROSE_ASSERT(p_MethodSpecTable == NULL || p_MethodSpecTable != NULL); return p_MethodSpecTable;
case 28: ROSE_ASSERT(p_ModuleTable == NULL || p_ModuleTable != NULL); return p_ModuleTable;
case 29: ROSE_ASSERT(p_ModuleRefTable == NULL || p_ModuleRefTable != NULL); return p_ModuleRefTable;
case 30: ROSE_ASSERT(p_NestedClassTable == NULL || p_NestedClassTable != NULL); return p_NestedClassTable;
case 31: ROSE_ASSERT(p_ParamTable == NULL || p_ParamTable != NULL); return p_ParamTable;
case 32: ROSE_ASSERT(p_PropertyTable == NULL || p_PropertyTable != NULL); return p_PropertyTable;
case 33: ROSE_ASSERT(p_PropertyMapTable == NULL || p_PropertyMapTable != NULL); return p_PropertyMapTable;
case 34: ROSE_ASSERT(p_StandAloneSigTable == NULL || p_StandAloneSigTable != NULL); return p_StandAloneSigTable;
case 35: ROSE_ASSERT(p_TypeDefTable == NULL || p_TypeDefTable != NULL); return p_TypeDefTable;
case 36: ROSE_ASSERT(p_TypeRefTable == NULL || p_TypeRefTable != NULL); return p_TypeRefTable;
case 37: ROSE_ASSERT(p_TypeSpecTable == NULL || p_TypeSpecTable != NULL); return p_TypeSpecTable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmCilMetadataHeap::get_childIndex(SgNode *child) const {
if (child == p_AssemblyTable) return 0;
else if (child == p_AssemblyOSTable) return 1;
else if (child == p_AssemblyProcessorTable) return 2;
else if (child == p_AssemblyRefTable) return 3;
else if (child == p_AssemblyRefOSTable) return 4;
else if (child == p_AssemblyRefProcessorTable) return 5;
else if (child == p_ClassLayoutTable) return 6;
else if (child == p_ConstantTable) return 7;
else if (child == p_CustomAttributeTable) return 8;
else if (child == p_DeclSecurityTable) return 9;
else if (child == p_EventTable) return 10;
else if (child == p_EventMapTable) return 11;
else if (child == p_ExportedTypeTable) return 12;
else if (child == p_FieldTable) return 13;
else if (child == p_FieldLayoutTable) return 14;
else if (child == p_FieldMarshalTable) return 15;
else if (child == p_FieldRVATable) return 16;
else if (child == p_FileTable) return 17;
else if (child == p_GenericParamTable) return 18;
else if (child == p_GenericParamConstraintTable) return 19;
else if (child == p_ImplMapTable) return 20;
else if (child == p_InterfaceImplTable) return 21;
else if (child == p_ManifestResourceTable) return 22;
else if (child == p_MemberRefTable) return 23;
else if (child == p_MethodDefTable) return 24;
else if (child == p_MethodImplTable) return 25;
else if (child == p_MethodSemanticsTable) return 26;
else if (child == p_MethodSpecTable) return 27;
else if (child == p_ModuleTable) return 28;
else if (child == p_ModuleRefTable) return 29;
else if (child == p_NestedClassTable) return 30;
else if (child == p_ParamTable) return 31;
else if (child == p_PropertyTable) return 32;
else if (child == p_PropertyMapTable) return 33;
else if (child == p_StandAloneSigTable) return 34;
else if (child == p_TypeDefTable) return 35;
else if (child == p_TypeRefTable) return 36;
else if (child == p_TypeSpecTable) return 37;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilUint32Heap::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilUint32Heap::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilUint32Heap::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilUint32Heap::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilUint32Heap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilUint32Heap::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilUint32Heap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilUint8Heap::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilUint8Heap::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilUint8Heap::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilUint8Heap::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilUint8Heap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilUint8Heap::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilUint8Heap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilExceptionData::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilExceptionData::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilExceptionData::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilExceptionData::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilExceptionData" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilExceptionData::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilExceptionData" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilMetadata::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilMetadata" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmCilMetadata::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilMetadata" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmCilMetadata::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilMetadata" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmCilMetadata::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilMetadata" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmCilMetadata::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmCilMetadata" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmCilAssembly::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssembly::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssembly::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilAssembly::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilAssembly" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilAssembly::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilAssembly" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilAssemblyOS::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyOS::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyOS::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilAssemblyOS::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilAssemblyOS" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilAssemblyOS::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilAssemblyOS" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilAssemblyOSTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilAssemblyOS*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyOSTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilAssemblyOS*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyOSTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilAssemblyOSTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilAssemblyOSTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilAssemblyOS*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilAssemblyProcessor::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyProcessor::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyProcessor::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilAssemblyProcessor::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilAssemblyProcessor" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilAssemblyProcessor::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilAssemblyProcessor" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilAssemblyProcessorTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilAssemblyProcessor*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyProcessorTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilAssemblyProcessor*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyProcessorTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilAssemblyProcessorTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilAssemblyProcessorTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilAssemblyProcessor*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilAssemblyRef::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyRef::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyRef::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilAssemblyRef::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilAssemblyRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilAssemblyRef::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilAssemblyRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilAssemblyRefOS::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyRefOS::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyRefOS::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilAssemblyRefOS::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilAssemblyRefOS" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilAssemblyRefOS::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilAssemblyRefOS" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilAssemblyRefOSTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilAssemblyRefOS*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyRefOSTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilAssemblyRefOS*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyRefOSTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilAssemblyRefOSTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilAssemblyRefOSTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilAssemblyRefOS*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilAssemblyRefProcessor::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyRefProcessor::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyRefProcessor::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilAssemblyRefProcessor::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilAssemblyRefProcessor" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilAssemblyRefProcessor::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilAssemblyRefProcessor" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilAssemblyRefProcessorTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilAssemblyRefProcessor*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyRefProcessorTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilAssemblyRefProcessor*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyRefProcessorTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilAssemblyRefProcessorTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilAssemblyRefProcessorTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilAssemblyRefProcessor*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilAssemblyRefTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilAssemblyRef*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyRefTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilAssemblyRef*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyRefTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilAssemblyRefTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilAssemblyRefTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilAssemblyRef*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilAssemblyTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilAssembly*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilAssemblyTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilAssembly*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilAssemblyTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilAssemblyTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilAssemblyTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilAssembly*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilClassLayout::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilClassLayout::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilClassLayout::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilClassLayout::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilClassLayout" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilClassLayout::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilClassLayout" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilClassLayoutTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilClassLayout*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilClassLayoutTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilClassLayout*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilClassLayoutTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilClassLayoutTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilClassLayoutTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilClassLayout*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilConstant::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilConstant::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilConstant::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilConstant::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilConstant" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilConstant::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilConstant" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilConstantTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilConstant*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilConstantTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilConstant*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilConstantTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilConstantTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilConstantTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilConstant*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilCustomAttribute::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilCustomAttribute::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilCustomAttribute::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilCustomAttribute::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilCustomAttribute" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilCustomAttribute::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilCustomAttribute" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilCustomAttributeTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilCustomAttribute*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilCustomAttributeTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilCustomAttribute*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilCustomAttributeTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilCustomAttributeTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilCustomAttributeTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilCustomAttribute*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilDeclSecurity::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilDeclSecurity::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilDeclSecurity::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilDeclSecurity::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilDeclSecurity" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilDeclSecurity::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilDeclSecurity" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilDeclSecurityTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilDeclSecurity*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilDeclSecurityTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilDeclSecurity*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilDeclSecurityTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilDeclSecurityTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilDeclSecurityTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilDeclSecurity*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilEvent::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilEvent::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilEvent::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilEvent::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilEvent" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilEvent::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilEvent" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilEventMap::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilEventMap::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilEventMap::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilEventMap::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilEventMap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilEventMap::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilEventMap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilEventMapTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilEventMap*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilEventMapTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilEventMap*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilEventMapTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilEventMapTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilEventMapTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilEventMap*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilEventTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilEvent*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilEventTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilEvent*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilEventTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilEventTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilEventTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilEvent*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilExportedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilExportedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilExportedType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilExportedType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilExportedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilExportedType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilExportedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilExportedTypeTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilExportedType*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilExportedTypeTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilExportedType*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilExportedTypeTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilExportedTypeTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilExportedTypeTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilExportedType*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilField::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilField::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilField::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilField::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilField" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilField::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilField" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilFieldLayout::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFieldLayout::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilFieldLayout::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilFieldLayout::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilFieldLayout" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilFieldLayout::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilFieldLayout" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilFieldLayoutTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilFieldLayout*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFieldLayoutTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilFieldLayout*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilFieldLayoutTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilFieldLayoutTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilFieldLayoutTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilFieldLayout*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilFieldMarshal::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFieldMarshal::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilFieldMarshal::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilFieldMarshal::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilFieldMarshal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilFieldMarshal::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilFieldMarshal" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilFieldMarshalTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilFieldMarshal*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFieldMarshalTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilFieldMarshal*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilFieldMarshalTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilFieldMarshalTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilFieldMarshalTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilFieldMarshal*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilFieldRVA::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFieldRVA::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilFieldRVA::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilFieldRVA::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilFieldRVA" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilFieldRVA::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilFieldRVA" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilFieldRVATable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilFieldRVA*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFieldRVATable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilFieldRVA*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilFieldRVATable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilFieldRVATable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilFieldRVATable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilFieldRVA*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilFieldTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilField*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFieldTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilField*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilFieldTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilFieldTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilFieldTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilField*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilFile::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFile::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilFile::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilFile::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilFile" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilFile::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilFile" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilFileTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilFile*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilFileTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilFile*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilFileTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilFileTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilFileTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilFile*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilGenericParamConstraint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilGenericParamConstraint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilGenericParamConstraint::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilGenericParamConstraint::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilGenericParamConstraint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilGenericParamConstraint::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilGenericParamConstraint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilGenericParamConstraintTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilGenericParamConstraint*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilGenericParamConstraintTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilGenericParamConstraint*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilGenericParamConstraintTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilGenericParamConstraintTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilGenericParamConstraintTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilGenericParamConstraint*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilGenericParam::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilGenericParam::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilGenericParam::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilGenericParam::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilGenericParam" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilGenericParam::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilGenericParam" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilGenericParamTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilGenericParam*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilGenericParamTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilGenericParam*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilGenericParamTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilGenericParamTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilGenericParamTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilGenericParam*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilImplMap::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilImplMap::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilImplMap::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilImplMap::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilImplMap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilImplMap::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilImplMap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilImplMapTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilImplMap*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilImplMapTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilImplMap*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilImplMapTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilImplMapTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilImplMapTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilImplMap*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilInterfaceImpl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilInterfaceImpl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilInterfaceImpl::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilInterfaceImpl::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilInterfaceImpl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilInterfaceImpl::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilInterfaceImpl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilInterfaceImplTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilInterfaceImpl*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilInterfaceImplTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilInterfaceImpl*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilInterfaceImplTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilInterfaceImplTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilInterfaceImplTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilInterfaceImpl*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilManifestResource::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilManifestResource::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilManifestResource::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilManifestResource::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilManifestResource" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilManifestResource::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilManifestResource" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilManifestResourceTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilManifestResource*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilManifestResourceTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilManifestResource*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilManifestResourceTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilManifestResourceTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilManifestResourceTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilManifestResource*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilMemberRef::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMemberRef::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilMemberRef::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilMemberRef::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilMemberRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilMemberRef::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilMemberRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilMemberRefTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilMemberRef*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMemberRefTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilMemberRef*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilMemberRefTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilMemberRefTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilMemberRefTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilMemberRef*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilMethodDef::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodDef::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodDef::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilMethodDef::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilMethodDef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilMethodDef::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilMethodDef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilMethodDefTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilMethodDef*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodDefTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilMethodDef*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodDefTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilMethodDefTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilMethodDefTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilMethodDef*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilMethodImpl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodImpl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodImpl::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilMethodImpl::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilMethodImpl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilMethodImpl::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilMethodImpl" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilMethodImplTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilMethodImpl*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodImplTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilMethodImpl*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodImplTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilMethodImplTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilMethodImplTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilMethodImpl*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilMethodSemantics::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodSemantics::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodSemantics::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilMethodSemantics::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilMethodSemantics" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilMethodSemantics::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilMethodSemantics" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilMethodSemanticsTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilMethodSemantics*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodSemanticsTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilMethodSemantics*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodSemanticsTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilMethodSemanticsTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilMethodSemanticsTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilMethodSemantics*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilMethodSpec::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodSpec::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodSpec::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilMethodSpec::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilMethodSpec" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilMethodSpec::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilMethodSpec" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilMethodSpecTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilMethodSpec*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodSpecTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilMethodSpec*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodSpecTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilMethodSpecTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilMethodSpecTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilMethodSpec*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilModule::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilModule::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilModule::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilModule::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilModule" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilModule::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilModule" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilModuleRef::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilModuleRef::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilModuleRef::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilModuleRef::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilModuleRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilModuleRef::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilModuleRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilModuleRefTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilModuleRef*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilModuleRefTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilModuleRef*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilModuleRefTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilModuleRefTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilModuleRefTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilModuleRef*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilModuleTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilModule*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilModuleTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilModule*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilModuleTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilModuleTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilModuleTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilModule*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilNestedClass::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilNestedClass::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilNestedClass::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilNestedClass::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilNestedClass" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilNestedClass::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilNestedClass" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilNestedClassTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilNestedClass*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilNestedClassTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilNestedClass*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilNestedClassTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilNestedClassTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilNestedClassTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilNestedClass*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilParam::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilParam::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilParam::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilParam::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilParam" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilParam::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilParam" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilParamTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilParam*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilParamTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilParam*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilParamTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilParamTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilParamTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilParam*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilProperty::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilProperty::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilProperty::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilProperty::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilProperty" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilProperty::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilProperty" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilPropertyMap::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilPropertyMap::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilPropertyMap::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilPropertyMap::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilPropertyMap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilPropertyMap::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilPropertyMap" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilPropertyMapTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilPropertyMap*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilPropertyMapTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilPropertyMap*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilPropertyMapTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilPropertyMapTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilPropertyMapTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilPropertyMap*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilPropertyTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilProperty*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilPropertyTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilProperty*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilPropertyTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilPropertyTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilPropertyTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilProperty*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilStandAloneSig::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilStandAloneSig::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilStandAloneSig::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilStandAloneSig::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilStandAloneSig" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilStandAloneSig::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilStandAloneSig" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilStandAloneSigTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilStandAloneSig*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilStandAloneSigTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilStandAloneSig*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilStandAloneSigTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilStandAloneSigTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilStandAloneSigTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilStandAloneSig*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilTypeDef::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilTypeDef::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilTypeDef::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilTypeDef::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilTypeDef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilTypeDef::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilTypeDef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilTypeDefTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilTypeDef*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilTypeDefTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilTypeDef*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilTypeDefTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilTypeDefTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilTypeDefTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilTypeDef*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilTypeRef::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilTypeRef::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilTypeRef::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilTypeRef::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilTypeRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilTypeRef::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilTypeRef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilTypeRefTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilTypeRef*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilTypeRefTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilTypeRef*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilTypeRefTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilTypeRefTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilTypeRefTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilTypeRef*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilTypeSpec::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilTypeSpec::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilTypeSpec::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilTypeSpec::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilTypeSpec" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilTypeSpec::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilTypeSpec" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCilTypeSpecTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_elements.size() + 0);
   {
     std::vector<SgAsmCilTypeSpec*>::const_iterator iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilTypeSpecTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilTypeSpec*>::const_iterator  iter;
     for (iter = p_elements.begin(); iter != p_elements.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilTypeSpecTable::get_numberOfTraversalSuccessors() const {
return p_elements.size() + 0;
}
SgNode *
SgAsmCilTypeSpecTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_elements.size());
return p_elements[idx];
}
size_t
SgAsmCilTypeSpecTable::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilTypeSpec*>::const_iterator itr = find(p_elements.begin(), p_elements.end(), child);
if (itr != p_elements.end()) return itr - p_elements.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilMetadataRoot::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_Streams.size() + 0);
   {
     std::vector<SgAsmCilDataStream*>::const_iterator iter;
     for (iter = p_Streams.begin(); iter != p_Streams.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMetadataRoot::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     std::vector<SgAsmCilDataStream*>::const_iterator  iter;
     for (iter = p_Streams.begin(); iter != p_Streams.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCilMetadataRoot::get_numberOfTraversalSuccessors() const {
return p_Streams.size() + 0;
}
SgNode *
SgAsmCilMetadataRoot::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_Streams.size());
return p_Streams[idx];
}
size_t
SgAsmCilMetadataRoot::get_childIndex(SgNode *child) const {
std::vector<SgAsmCilDataStream*>::const_iterator itr = find(p_Streams.begin(), p_Streams.end(), child);
if (itr != p_Streams.end()) return itr - p_Streams.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilMethodData::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilMethodData::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCilMethodData::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCilMethodData::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCilMethodData" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCilMethodData::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCilMethodData" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmExecutableFileFormat::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExecutableFileFormat" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmExecutableFileFormat::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExecutableFileFormat" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmExecutableFileFormat::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExecutableFileFormat" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmExecutableFileFormat::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExecutableFileFormat" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmExecutableFileFormat::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExecutableFileFormat" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmCoffSymbolList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_symbols.size() + 0);
   {
     SgAsmCoffSymbolPtrList::const_iterator iter;
     for (iter = p_symbols.begin(); iter != p_symbols.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmCoffSymbolList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmCoffSymbolPtrList::const_iterator  iter;
     for (iter = p_symbols.begin(); iter != p_symbols.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmCoffSymbolList::get_numberOfTraversalSuccessors() const {
return p_symbols.size() + 0;
}
SgNode *
SgAsmCoffSymbolList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_symbols.size());
return p_symbols[idx];
}
size_t
SgAsmCoffSymbolList::get_childIndex(SgNode *child) const {
SgAsmCoffSymbolPtrList::const_iterator itr = find(p_symbols.begin(), p_symbols.end(), child);
if (itr != p_symbols.end()) return itr - p_symbols.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfInformation::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfInformation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmDwarfInformation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfInformation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmDwarfInformation::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfInformation" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmDwarfInformation::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfInformation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmDwarfInformation::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfInformation" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmDwarfCompilationUnitList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_cu_list.size() + 0);
   {
     SgAsmDwarfCompilationUnitPtrList::const_iterator iter;
     for (iter = p_cu_list.begin(); iter != p_cu_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfCompilationUnitList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmDwarfCompilationUnitPtrList::const_iterator  iter;
     for (iter = p_cu_list.begin(); iter != p_cu_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfCompilationUnitList::get_numberOfTraversalSuccessors() const {
return p_cu_list.size() + 0;
}
SgNode *
SgAsmDwarfCompilationUnitList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_cu_list.size());
return p_cu_list[idx];
}
size_t
SgAsmDwarfCompilationUnitList::get_childIndex(SgNode *child) const {
SgAsmDwarfCompilationUnitPtrList::const_iterator itr = find(p_cu_list.begin(), p_cu_list.end(), child);
if (itr != p_cu_list.end()) return itr - p_cu_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfConstruct::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfConstruct" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmDwarfConstruct::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfConstruct" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmDwarfConstruct::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfConstruct" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmDwarfConstruct::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfConstruct" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmDwarfConstruct::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmDwarfConstruct" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmDwarfAccessDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfAccessDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfAccessDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfAccessDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfAccessDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfAccessDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfAccessDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfArrayType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfArrayType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfArrayType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfArrayType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfArrayType::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfBaseType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfBaseType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfBaseType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfBaseType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfBaseType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfBaseType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfBaseType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfCatchBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfCatchBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfCatchBlock::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfCatchBlock::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfCatchBlock" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfCatchBlock::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfCatchBlock" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfClassTemplate::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfClassTemplate::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfClassTemplate::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfClassTemplate::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfClassTemplate" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfClassTemplate::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfClassTemplate" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfClassType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfClassType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfClassType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfClassType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfClassType::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfCommonBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfCommonBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfCommonBlock::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfCommonBlock::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfCommonBlock::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfCommonInclusion::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfCommonInclusion::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfCommonInclusion::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfCommonInclusion::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfCommonInclusion" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfCommonInclusion::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfCommonInclusion" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfCompilationUnit::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_line_info);
traversalSuccessorContainer.push_back(p_language_constructs);
traversalSuccessorContainer.push_back(p_macro_info);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfCompilationUnit::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_line_info");
traversalSuccessorContainer.push_back("p_language_constructs");
traversalSuccessorContainer.push_back("p_macro_info");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfCompilationUnit::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmDwarfCompilationUnit::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_line_info == NULL || p_line_info != NULL); return p_line_info;
case 1: ROSE_ASSERT(p_language_constructs == NULL || p_language_constructs != NULL); return p_language_constructs;
case 2: ROSE_ASSERT(p_macro_info == NULL || p_macro_info != NULL); return p_macro_info;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfCompilationUnit::get_childIndex(SgNode *child) const {
if (child == p_line_info) return 0;
else if (child == p_language_constructs) return 1;
else if (child == p_macro_info) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfCondition::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfCondition::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfCondition::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfCondition::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfCondition" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfCondition::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfCondition" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfConstant::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfConstant::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfConstant::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfConstant::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfConstant" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfConstant::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfConstant" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfConstType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfConstType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfConstType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfConstType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfConstType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfConstType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfConstType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfDwarfProcedure::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfDwarfProcedure::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfDwarfProcedure::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfDwarfProcedure::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfDwarfProcedure" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfDwarfProcedure::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfDwarfProcedure" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfEntryPoint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfEntryPoint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfEntryPoint::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfEntryPoint::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfEntryPoint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfEntryPoint::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfEntryPoint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfEnumerationType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfEnumerationType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfEnumerationType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfEnumerationType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfEnumerationType::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfEnumerator::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfEnumerator::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfEnumerator::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfEnumerator::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfEnumerator" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfEnumerator::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfEnumerator" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfFileType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfFileType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfFileType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfFileType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfFileType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfFileType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfFileType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfFormalParameter::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfFormalParameter::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfFormalParameter::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfFormalParameter::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfFormalParameter" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfFormalParameter::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfFormalParameter" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfFormatLabel::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfFormatLabel::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfFormatLabel::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfFormatLabel::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfFormatLabel" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfFormatLabel::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfFormatLabel" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfFriend::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfFriend::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfFriend::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfFriend::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfFriend" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfFriend::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfFriend" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfFunctionTemplate::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfFunctionTemplate::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfFunctionTemplate::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfFunctionTemplate::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfFunctionTemplate" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfFunctionTemplate::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfFunctionTemplate" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfImportedDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfImportedDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfImportedDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfImportedDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfImportedDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfImportedDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfImportedDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfImportedModule::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfImportedModule::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfImportedModule::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfImportedModule::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfImportedModule" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfImportedModule::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfImportedModule" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfImportedUnit::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfImportedUnit::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfImportedUnit::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfImportedUnit::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfImportedUnit" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfImportedUnit::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfImportedUnit" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfInheritance::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfInheritance::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfInheritance::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfInheritance::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfInheritance" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfInheritance::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfInheritance" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfInlinedSubroutine::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfInlinedSubroutine::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfInlinedSubroutine::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfInlinedSubroutine::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfInlinedSubroutine::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfInterfaceType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfInterfaceType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfInterfaceType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfInterfaceType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfInterfaceType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfInterfaceType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfInterfaceType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfLabel::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfLabel::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfLabel::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfLabel::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfLabel" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfLabel::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfLabel" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfLexicalBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfLexicalBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfLexicalBlock::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfLexicalBlock::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfLexicalBlock::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfMember::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfMember::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfMember::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfMember::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfMember" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfMember::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfMember" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfModule::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfModule::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfModule::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfModule::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfModule" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfModule::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfModule" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfMutableType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfMutableType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfMutableType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfMutableType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfMutableType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfMutableType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfMutableType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfNamelist::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfNamelist::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfNamelist::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfNamelist::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfNamelist" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfNamelist::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfNamelist" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfNamelistItem::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfNamelistItem::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfNamelistItem::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfNamelistItem::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfNamelistItem" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfNamelistItem::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfNamelistItem" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfNamespace::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfNamespace::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfNamespace::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfNamespace::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfNamespace::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfPackedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfPackedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfPackedType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfPackedType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfPackedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfPackedType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfPackedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfPartialUnit::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfPartialUnit::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfPartialUnit::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfPartialUnit::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfPartialUnit" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfPartialUnit::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfPartialUnit" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfPointerType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfPointerType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfPointerType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfPointerType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfPointerType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfPointerType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfPointerType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfPtrToMemberType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfPtrToMemberType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfPtrToMemberType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfPtrToMemberType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfPtrToMemberType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfPtrToMemberType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfPtrToMemberType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfReferenceType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfReferenceType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfReferenceType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfReferenceType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfReferenceType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfReferenceType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfReferenceType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfRestrictType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfRestrictType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfRestrictType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfRestrictType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfRestrictType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfRestrictType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfRestrictType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfSetType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfSetType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfSetType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfSetType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfSetType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfSetType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfSetType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfSharedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfSharedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfSharedType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfSharedType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfSharedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfSharedType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfSharedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfStringType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfStringType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfStringType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfStringType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfStringType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfStringType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfStringType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfStructureType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfStructureType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfStructureType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfStructureType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfStructureType::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfSubprogram::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfSubprogram::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfSubprogram::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfSubprogram::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfSubprogram::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfSubrangeType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfSubrangeType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfSubrangeType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfSubrangeType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfSubrangeType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfSubrangeType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfSubrangeType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfSubroutineType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfSubroutineType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfSubroutineType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfSubroutineType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfSubroutineType::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfTemplateTypeParameter::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfTemplateTypeParameter::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfTemplateTypeParameter::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfTemplateTypeParameter::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfTemplateTypeParameter" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfTemplateTypeParameter::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfTemplateTypeParameter" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfTemplateValueParameter::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfTemplateValueParameter::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfTemplateValueParameter::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfTemplateValueParameter::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfTemplateValueParameter" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfTemplateValueParameter::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfTemplateValueParameter" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfThrownType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfThrownType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfThrownType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfThrownType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfThrownType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfThrownType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfThrownType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfTryBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfTryBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfTryBlock::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfTryBlock::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfTryBlock" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfTryBlock::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfTryBlock" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfTypedef::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfTypedef::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfTypedef::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfTypedef::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfTypedef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfTypedef::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfTypedef" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfUnionType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_body);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfUnionType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_body");
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfUnionType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmDwarfUnionType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_body == NULL || p_body != NULL); return p_body;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDwarfUnionType::get_childIndex(SgNode *child) const {
if (child == p_body) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfUnknownConstruct::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfUnknownConstruct::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfUnknownConstruct::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfUnknownConstruct::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfUnknownConstruct" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfUnknownConstruct::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfUnknownConstruct" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfUnspecifiedParameters::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfUnspecifiedParameters::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfUnspecifiedParameters::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfUnspecifiedParameters::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfUnspecifiedParameters" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfUnspecifiedParameters::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfUnspecifiedParameters" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfUnspecifiedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfUnspecifiedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfUnspecifiedType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfUnspecifiedType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfUnspecifiedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfUnspecifiedType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfUnspecifiedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfUpcRelaxedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfUpcRelaxedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfUpcRelaxedType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfUpcRelaxedType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfUpcRelaxedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfUpcRelaxedType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfUpcRelaxedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfUpcSharedType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfUpcSharedType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfUpcSharedType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfUpcSharedType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfUpcSharedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfUpcSharedType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfUpcSharedType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfUpcStrictType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfUpcStrictType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfUpcStrictType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfUpcStrictType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfUpcStrictType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfUpcStrictType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfUpcStrictType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfVariable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfVariable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfVariable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfVariable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfVariable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfVariable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfVariable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfVariant::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfVariant::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfVariant::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfVariant::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfVariant" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfVariant::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfVariant" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfVariantPart::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfVariantPart::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfVariantPart::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfVariantPart::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfVariantPart" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfVariantPart::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfVariantPart" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfVolatileType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfVolatileType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfVolatileType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfVolatileType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfVolatileType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfVolatileType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfVolatileType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfWithStmt::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfWithStmt::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfWithStmt::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfWithStmt::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfWithStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfWithStmt::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfWithStmt" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfConstructList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_list.size() + 0);
   {
     SgAsmDwarfConstructPtrList::const_iterator iter;
     for (iter = p_list.begin(); iter != p_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfConstructList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmDwarfConstructPtrList::const_iterator  iter;
     for (iter = p_list.begin(); iter != p_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfConstructList::get_numberOfTraversalSuccessors() const {
return p_list.size() + 0;
}
SgNode *
SgAsmDwarfConstructList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_list.size());
return p_list[idx];
}
size_t
SgAsmDwarfConstructList::get_childIndex(SgNode *child) const {
SgAsmDwarfConstructPtrList::const_iterator itr = find(p_list.begin(), p_list.end(), child);
if (itr != p_list.end()) return itr - p_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfLine::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfLine::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfLine::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfLine::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfLine" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfLine::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfLine" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfLineList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_line_list.size() + 0);
   {
     SgAsmDwarfLinePtrList::const_iterator iter;
     for (iter = p_line_list.begin(); iter != p_line_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfLineList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmDwarfLinePtrList::const_iterator  iter;
     for (iter = p_line_list.begin(); iter != p_line_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfLineList::get_numberOfTraversalSuccessors() const {
return p_line_list.size() + 0;
}
SgNode *
SgAsmDwarfLineList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_line_list.size());
return p_line_list[idx];
}
size_t
SgAsmDwarfLineList::get_childIndex(SgNode *child) const {
SgAsmDwarfLinePtrList::const_iterator itr = find(p_line_list.begin(), p_line_list.end(), child);
if (itr != p_line_list.end()) return itr - p_line_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDwarfMacro::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfMacro::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfMacro::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDwarfMacro::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDwarfMacro" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDwarfMacro::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDwarfMacro" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmDwarfMacroList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_macro_list.size() + 0);
   {
     SgAsmDwarfMacroPtrList::const_iterator iter;
     for (iter = p_macro_list.begin(); iter != p_macro_list.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmDwarfMacroList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmDwarfMacroPtrList::const_iterator  iter;
     for (iter = p_macro_list.begin(); iter != p_macro_list.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmDwarfMacroList::get_numberOfTraversalSuccessors() const {
return p_macro_list.size() + 0;
}
SgNode *
SgAsmDwarfMacroList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_macro_list.size());
return p_macro_list[idx];
}
size_t
SgAsmDwarfMacroList::get_childIndex(SgNode *child) const {
SgAsmDwarfMacroPtrList::const_iterator itr = find(p_macro_list.begin(), p_macro_list.end(), child);
if (itr != p_macro_list.end()) return itr - p_macro_list.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfDynamicEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfDynamicEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmElfDynamicEntry::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmElfDynamicEntry::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfDynamicEntry::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfDynamicEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfDynamicEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfDynamicEntryList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfDynamicEntryList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfDynamicEntryList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfDynamicEntryList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfDynamicEntryList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfEHFrameEntryCI::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_fd_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfEHFrameEntryCI::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_fd_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfEHFrameEntryCI::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmElfEHFrameEntryCI::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_fd_entries == NULL || p_fd_entries != NULL); return p_fd_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfEHFrameEntryCI::get_childIndex(SgNode *child) const {
if (child == p_fd_entries) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfEHFrameEntryCIList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfEHFrameEntryCIList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfEHFrameEntryCIList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfEHFrameEntryCIList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfEHFrameEntryCIList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfEHFrameEntryCIList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfEHFrameEntryCIList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfEHFrameEntryFD::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfEHFrameEntryFD::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfEHFrameEntryFD::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfEHFrameEntryFD::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfEHFrameEntryFD" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfEHFrameEntryFD::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfEHFrameEntryFD" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfEHFrameEntryFDList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfEHFrameEntryFDList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfEHFrameEntryFDList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfEHFrameEntryFDList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfEHFrameEntryFDList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfEHFrameEntryFDList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfEHFrameEntryFDList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfNoteEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfNoteEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmElfNoteEntry::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmElfNoteEntry::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfNoteEntry::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfNoteEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfNoteEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfNoteEntryList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfNoteEntryList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfNoteEntryList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfNoteEntryList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfNoteEntryList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfRelocEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfRelocEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfRelocEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfRelocEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfRelocEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfRelocEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfRelocEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfRelocEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmElfRelocEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfRelocEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfRelocEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfRelocEntryList::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmElfRelocEntryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmElfRelocEntryList::get_childIndex(SgNode *child) const {
SgAsmElfRelocEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSectionTableEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSectionTableEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfSectionTableEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfSectionTableEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfSectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfSectionTableEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfSectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfSegmentTableEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSegmentTableEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfSegmentTableEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfSegmentTableEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfSegmentTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfSegmentTableEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfSegmentTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfSegmentTableEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmElfSegmentTableEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSegmentTableEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfSegmentTableEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfSegmentTableEntryList::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmElfSegmentTableEntryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmElfSegmentTableEntryList::get_childIndex(SgNode *child) const {
SgAsmElfSegmentTableEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymbolList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_symbols.size() + 0);
   {
     SgAsmElfSymbolPtrList::const_iterator iter;
     for (iter = p_symbols.begin(); iter != p_symbols.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymbolList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfSymbolPtrList::const_iterator  iter;
     for (iter = p_symbols.begin(); iter != p_symbols.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymbolList::get_numberOfTraversalSuccessors() const {
return p_symbols.size() + 0;
}
SgNode *
SgAsmElfSymbolList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_symbols.size());
return p_symbols[idx];
}
size_t
SgAsmElfSymbolList::get_childIndex(SgNode *child) const {
SgAsmElfSymbolPtrList::const_iterator itr = find(p_symbols.begin(), p_symbols.end(), child);
if (itr != p_symbols.end()) return itr - p_symbols.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverDefinedAux::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverDefinedAux::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverDefinedAux::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmElfSymverDefinedAux::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymverDefinedAux::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverDefinedAuxList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmElfSymverDefinedAuxPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverDefinedAuxList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfSymverDefinedAuxPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverDefinedAuxList::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmElfSymverDefinedAuxList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmElfSymverDefinedAuxList::get_childIndex(SgNode *child) const {
SgAsmElfSymverDefinedAuxPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverDefinedEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverDefinedEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverDefinedEntry::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmElfSymverDefinedEntry::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymverDefinedEntry::get_childIndex(SgNode *child) const {
if (child == p_entries) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverDefinedEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmElfSymverDefinedEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverDefinedEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfSymverDefinedEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverDefinedEntryList::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmElfSymverDefinedEntryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmElfSymverDefinedEntryList::get_childIndex(SgNode *child) const {
SgAsmElfSymverDefinedEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfSymverEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfSymverEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfSymverEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfSymverEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfSymverEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmElfSymverEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfSymverEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverEntryList::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmElfSymverEntryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmElfSymverEntryList::get_childIndex(SgNode *child) const {
SgAsmElfSymverEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverNeededAux::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverNeededAux::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverNeededAux::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmElfSymverNeededAux::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymverNeededAux::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverNeededAuxList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmElfSymverNeededAuxPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverNeededAuxList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfSymverNeededAuxPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverNeededAuxList::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmElfSymverNeededAuxList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmElfSymverNeededAuxList::get_childIndex(SgNode *child) const {
SgAsmElfSymverNeededAuxPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverNeededEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_fileName);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverNeededEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_fileName");
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverNeededEntry::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmElfSymverNeededEntry::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_fileName == NULL || p_fileName != NULL); return p_fileName;
case 1: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymverNeededEntry::get_childIndex(SgNode *child) const {
if (child == p_fileName) return 0;
else if (child == p_entries) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverNeededEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmElfSymverNeededEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverNeededEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmElfSymverNeededEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverNeededEntryList::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmElfSymverNeededEntryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmElfSymverNeededEntryList::get_childIndex(SgNode *child) const {
SgAsmElfSymverNeededEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmGenericDLL::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericDLL::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmGenericDLL::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmGenericDLL::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmGenericDLL::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmGenericDLLList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericDLLList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmGenericDLLList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmGenericDLLList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmGenericDLLList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmGenericDLLList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmGenericDLLList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmGenericFile::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_dwarfInfo);
traversalSuccessorContainer.push_back(p_headers);
traversalSuccessorContainer.push_back(p_holes);
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericFile::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_dwarfInfo");
traversalSuccessorContainer.push_back("p_headers");
traversalSuccessorContainer.push_back("p_holes");
return traversalSuccessorContainer;
}
size_t
SgAsmGenericFile::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmGenericFile::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_dwarfInfo == NULL || p_dwarfInfo != NULL); return p_dwarfInfo;
case 1: ROSE_ASSERT(p_headers == NULL || p_headers != NULL); return p_headers;
case 2: ROSE_ASSERT(p_holes == NULL || p_holes != NULL); return p_holes;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmGenericFile::get_childIndex(SgNode *child) const {
if (child == p_dwarfInfo) return 0;
else if (child == p_headers) return 1;
else if (child == p_holes) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmGenericFormat::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericFormat::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmGenericFormat::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmGenericFormat::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmGenericFormat" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmGenericFormat::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmGenericFormat" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmGenericHeaderList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_headers.size() + 0);
   {
     SgAsmGenericHeaderPtrList::const_iterator iter;
     for (iter = p_headers.begin(); iter != p_headers.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericHeaderList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmGenericHeaderPtrList::const_iterator  iter;
     for (iter = p_headers.begin(); iter != p_headers.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmGenericHeaderList::get_numberOfTraversalSuccessors() const {
return p_headers.size() + 0;
}
SgNode *
SgAsmGenericHeaderList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_headers.size());
return p_headers[idx];
}
size_t
SgAsmGenericHeaderList::get_childIndex(SgNode *child) const {
SgAsmGenericHeaderPtrList::const_iterator itr = find(p_headers.begin(), p_headers.end(), child);
if (itr != p_headers.end()) return itr - p_headers.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmGenericSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmGenericSection::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmGenericSection::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmGenericSection" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmGenericSection::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmGenericSection" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCliHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_metadataRoot);
return traversalSuccessorContainer;
}
vector<string>
SgAsmCliHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_metadataRoot");
return traversalSuccessorContainer;
}
size_t
SgAsmCliHeader::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmCliHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_metadataRoot == NULL || p_metadataRoot != NULL); return p_metadataRoot;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmCliHeader::get_childIndex(SgNode *child) const {
if (child == p_metadataRoot) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCoffSymbolTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_symbols);
return traversalSuccessorContainer;
}
vector<string>
SgAsmCoffSymbolTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_symbols");
return traversalSuccessorContainer;
}
size_t
SgAsmCoffSymbolTable::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmCoffSymbolTable::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_symbols == NULL || p_symbols != NULL); return p_symbols;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmCoffSymbolTable::get_childIndex(SgNode *child) const {
if (child == p_symbols) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDOSExtendedHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDOSExtendedHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDOSExtendedHeader::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDOSExtendedHeader::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDOSExtendedHeader" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDOSExtendedHeader::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDOSExtendedHeader" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSection::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmElfSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfDynamicSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfDynamicSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfDynamicSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfDynamicSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfDynamicSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_entries) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfEHFrameSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_ci_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfEHFrameSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_ci_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfEHFrameSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfEHFrameSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_ci_entries == NULL || p_ci_entries != NULL); return p_ci_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfEHFrameSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_ci_entries) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfNoteSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfNoteSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfNoteSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfNoteSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfNoteSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_entries) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfRelocSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfRelocSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfRelocSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfRelocSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfRelocSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_entries) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfStringSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfStringSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
return traversalSuccessorContainer;
}
size_t
SgAsmElfStringSection::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmElfStringSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfStringSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymbolSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_symbols);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymbolSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_symbols");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymbolSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfSymbolSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_symbols == NULL || p_symbols != NULL); return p_symbols;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymbolSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_symbols) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverDefinedSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverDefinedSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverDefinedSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfSymverDefinedSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymverDefinedSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_entries) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverNeededSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverNeededSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverNeededSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfSymverNeededSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymverNeededSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_entries) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymverSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_sectionEntry);
traversalSuccessorContainer.push_back(p_segmentEntry);
traversalSuccessorContainer.push_back(p_entries);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymverSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionEntry");
traversalSuccessorContainer.push_back("p_segmentEntry");
traversalSuccessorContainer.push_back("p_entries");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymverSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfSymverSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionEntry == NULL || p_sectionEntry != NULL); return p_sectionEntry;
case 1: ROSE_ASSERT(p_segmentEntry == NULL || p_segmentEntry != NULL); return p_segmentEntry;
case 2: ROSE_ASSERT(p_entries == NULL || p_entries != NULL); return p_entries;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymverSection::get_childIndex(SgNode *child) const {
if (child == p_sectionEntry) return 0;
else if (child == p_segmentEntry) return 1;
else if (child == p_entries) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSectionTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSectionTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfSectionTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfSectionTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfSectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfSectionTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfSectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfSegmentTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSegmentTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfSegmentTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfSegmentTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfSegmentTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfSegmentTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfSegmentTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmGenericHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_executableFormat);
traversalSuccessorContainer.push_back(p_dlls);
traversalSuccessorContainer.push_back(p_sections);
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executableFormat");
traversalSuccessorContainer.push_back("p_dlls");
traversalSuccessorContainer.push_back("p_sections");
return traversalSuccessorContainer;
}
size_t
SgAsmGenericHeader::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmGenericHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executableFormat == NULL || p_executableFormat != NULL); return p_executableFormat;
case 1: ROSE_ASSERT(p_dlls == NULL || p_dlls != NULL); return p_dlls;
case 2: ROSE_ASSERT(p_sections == NULL || p_sections != NULL); return p_sections;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmGenericHeader::get_childIndex(SgNode *child) const {
if (child == p_executableFormat) return 0;
else if (child == p_dlls) return 1;
else if (child == p_sections) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmDOSFileHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_executableFormat);
traversalSuccessorContainer.push_back(p_dlls);
traversalSuccessorContainer.push_back(p_sections);
return traversalSuccessorContainer;
}
vector<string>
SgAsmDOSFileHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executableFormat");
traversalSuccessorContainer.push_back("p_dlls");
traversalSuccessorContainer.push_back("p_sections");
return traversalSuccessorContainer;
}
size_t
SgAsmDOSFileHeader::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmDOSFileHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executableFormat == NULL || p_executableFormat != NULL); return p_executableFormat;
case 1: ROSE_ASSERT(p_dlls == NULL || p_dlls != NULL); return p_dlls;
case 2: ROSE_ASSERT(p_sections == NULL || p_sections != NULL); return p_sections;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmDOSFileHeader::get_childIndex(SgNode *child) const {
if (child == p_executableFormat) return 0;
else if (child == p_dlls) return 1;
else if (child == p_sections) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfFileHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_executableFormat);
traversalSuccessorContainer.push_back(p_dlls);
traversalSuccessorContainer.push_back(p_sections);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfFileHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executableFormat");
traversalSuccessorContainer.push_back("p_dlls");
traversalSuccessorContainer.push_back("p_sections");
return traversalSuccessorContainer;
}
size_t
SgAsmElfFileHeader::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmElfFileHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executableFormat == NULL || p_executableFormat != NULL); return p_executableFormat;
case 1: ROSE_ASSERT(p_dlls == NULL || p_dlls != NULL); return p_dlls;
case 2: ROSE_ASSERT(p_sections == NULL || p_sections != NULL); return p_sections;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfFileHeader::get_childIndex(SgNode *child) const {
if (child == p_executableFormat) return 0;
else if (child == p_dlls) return 1;
else if (child == p_sections) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmFileHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_executableFormat);
traversalSuccessorContainer.push_back(p_dlls);
traversalSuccessorContainer.push_back(p_sections);
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmFileHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executableFormat");
traversalSuccessorContainer.push_back("p_dlls");
traversalSuccessorContainer.push_back("p_sections");
return traversalSuccessorContainer;
}
size_t
SgAsmJvmFileHeader::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmJvmFileHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executableFormat == NULL || p_executableFormat != NULL); return p_executableFormat;
case 1: ROSE_ASSERT(p_dlls == NULL || p_dlls != NULL); return p_dlls;
case 2: ROSE_ASSERT(p_sections == NULL || p_sections != NULL); return p_sections;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmJvmFileHeader::get_childIndex(SgNode *child) const {
if (child == p_executableFormat) return 0;
else if (child == p_dlls) return 1;
else if (child == p_sections) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmLEFileHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(9);
traversalSuccessorContainer.push_back(p_executableFormat);
traversalSuccessorContainer.push_back(p_dlls);
traversalSuccessorContainer.push_back(p_sections);
traversalSuccessorContainer.push_back(p_dos2Header);
traversalSuccessorContainer.push_back(p_pageTable);
traversalSuccessorContainer.push_back(p_residentNameTable);
traversalSuccessorContainer.push_back(p_nonresidentNameTable);
traversalSuccessorContainer.push_back(p_entryTable);
traversalSuccessorContainer.push_back(p_relocationTable);
return traversalSuccessorContainer;
}
vector<string>
SgAsmLEFileHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executableFormat");
traversalSuccessorContainer.push_back("p_dlls");
traversalSuccessorContainer.push_back("p_sections");
traversalSuccessorContainer.push_back("p_dos2Header");
traversalSuccessorContainer.push_back("p_pageTable");
traversalSuccessorContainer.push_back("p_residentNameTable");
traversalSuccessorContainer.push_back("p_nonresidentNameTable");
traversalSuccessorContainer.push_back("p_entryTable");
traversalSuccessorContainer.push_back("p_relocationTable");
return traversalSuccessorContainer;
}
size_t
SgAsmLEFileHeader::get_numberOfTraversalSuccessors() const {
return 9;
}
SgNode *
SgAsmLEFileHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executableFormat == NULL || p_executableFormat != NULL); return p_executableFormat;
case 1: ROSE_ASSERT(p_dlls == NULL || p_dlls != NULL); return p_dlls;
case 2: ROSE_ASSERT(p_sections == NULL || p_sections != NULL); return p_sections;
case 3: ROSE_ASSERT(p_dos2Header == NULL || p_dos2Header != NULL); return p_dos2Header;
case 4: ROSE_ASSERT(p_pageTable == NULL || p_pageTable != NULL); return p_pageTable;
case 5: ROSE_ASSERT(p_residentNameTable == NULL || p_residentNameTable != NULL); return p_residentNameTable;
case 6: ROSE_ASSERT(p_nonresidentNameTable == NULL || p_nonresidentNameTable != NULL); return p_nonresidentNameTable;
case 7: ROSE_ASSERT(p_entryTable == NULL || p_entryTable != NULL); return p_entryTable;
case 8: ROSE_ASSERT(p_relocationTable == NULL || p_relocationTable != NULL); return p_relocationTable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmLEFileHeader::get_childIndex(SgNode *child) const {
if (child == p_executableFormat) return 0;
else if (child == p_dlls) return 1;
else if (child == p_sections) return 2;
else if (child == p_dos2Header) return 3;
else if (child == p_pageTable) return 4;
else if (child == p_residentNameTable) return 5;
else if (child == p_nonresidentNameTable) return 6;
else if (child == p_entryTable) return 7;
else if (child == p_relocationTable) return 8;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmNEFileHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(8);
traversalSuccessorContainer.push_back(p_executableFormat);
traversalSuccessorContainer.push_back(p_dlls);
traversalSuccessorContainer.push_back(p_sections);
traversalSuccessorContainer.push_back(p_dos2Header);
traversalSuccessorContainer.push_back(p_residentNameTable);
traversalSuccessorContainer.push_back(p_nonresidentNameTable);
traversalSuccessorContainer.push_back(p_moduleTable);
traversalSuccessorContainer.push_back(p_entryTable);
return traversalSuccessorContainer;
}
vector<string>
SgAsmNEFileHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executableFormat");
traversalSuccessorContainer.push_back("p_dlls");
traversalSuccessorContainer.push_back("p_sections");
traversalSuccessorContainer.push_back("p_dos2Header");
traversalSuccessorContainer.push_back("p_residentNameTable");
traversalSuccessorContainer.push_back("p_nonresidentNameTable");
traversalSuccessorContainer.push_back("p_moduleTable");
traversalSuccessorContainer.push_back("p_entryTable");
return traversalSuccessorContainer;
}
size_t
SgAsmNEFileHeader::get_numberOfTraversalSuccessors() const {
return 8;
}
SgNode *
SgAsmNEFileHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executableFormat == NULL || p_executableFormat != NULL); return p_executableFormat;
case 1: ROSE_ASSERT(p_dlls == NULL || p_dlls != NULL); return p_dlls;
case 2: ROSE_ASSERT(p_sections == NULL || p_sections != NULL); return p_sections;
case 3: ROSE_ASSERT(p_dos2Header == NULL || p_dos2Header != NULL); return p_dos2Header;
case 4: ROSE_ASSERT(p_residentNameTable == NULL || p_residentNameTable != NULL); return p_residentNameTable;
case 5: ROSE_ASSERT(p_nonresidentNameTable == NULL || p_nonresidentNameTable != NULL); return p_nonresidentNameTable;
case 6: ROSE_ASSERT(p_moduleTable == NULL || p_moduleTable != NULL); return p_moduleTable;
case 7: ROSE_ASSERT(p_entryTable == NULL || p_entryTable != NULL); return p_entryTable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmNEFileHeader::get_childIndex(SgNode *child) const {
if (child == p_executableFormat) return 0;
else if (child == p_dlls) return 1;
else if (child == p_sections) return 2;
else if (child == p_dos2Header) return 3;
else if (child == p_residentNameTable) return 4;
else if (child == p_nonresidentNameTable) return 5;
else if (child == p_moduleTable) return 6;
else if (child == p_entryTable) return 7;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEFileHeader::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(4);
traversalSuccessorContainer.push_back(p_executableFormat);
traversalSuccessorContainer.push_back(p_dlls);
traversalSuccessorContainer.push_back(p_sections);
traversalSuccessorContainer.push_back(p_rvaSizePairs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEFileHeader::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_executableFormat");
traversalSuccessorContainer.push_back("p_dlls");
traversalSuccessorContainer.push_back("p_sections");
traversalSuccessorContainer.push_back("p_rvaSizePairs");
return traversalSuccessorContainer;
}
size_t
SgAsmPEFileHeader::get_numberOfTraversalSuccessors() const {
return 4;
}
SgNode *
SgAsmPEFileHeader::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_executableFormat == NULL || p_executableFormat != NULL); return p_executableFormat;
case 1: ROSE_ASSERT(p_dlls == NULL || p_dlls != NULL); return p_dlls;
case 2: ROSE_ASSERT(p_sections == NULL || p_sections != NULL); return p_sections;
case 3: ROSE_ASSERT(p_rvaSizePairs == NULL || p_rvaSizePairs != NULL); return p_rvaSizePairs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEFileHeader::get_childIndex(SgNode *child) const {
if (child == p_executableFormat) return 0;
else if (child == p_dlls) return 1;
else if (child == p_sections) return 2;
else if (child == p_rvaSizePairs) return 3;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmAttributeTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_attributes.size() + 0);
   {
     SgAsmJvmAttributePtrList::const_iterator iter;
     for (iter = p_attributes.begin(); iter != p_attributes.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmAttributeTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmJvmAttributePtrList::const_iterator  iter;
     for (iter = p_attributes.begin(); iter != p_attributes.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmJvmAttributeTable::get_numberOfTraversalSuccessors() const {
return p_attributes.size() + 0;
}
SgNode *
SgAsmJvmAttributeTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_attributes.size());
return p_attributes[idx];
}
size_t
SgAsmJvmAttributeTable::get_childIndex(SgNode *child) const {
SgAsmJvmAttributePtrList::const_iterator itr = find(p_attributes.begin(), p_attributes.end(), child);
if (itr != p_attributes.end()) return itr - p_attributes.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmConstantPool::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmConstantPool::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmConstantPool::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmConstantPool::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmConstantPool" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmConstantPool::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmConstantPool" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmFieldTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_fields.size() + 0);
   {
     SgAsmJvmFieldPtrList::const_iterator iter;
     for (iter = p_fields.begin(); iter != p_fields.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmFieldTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmJvmFieldPtrList::const_iterator  iter;
     for (iter = p_fields.begin(); iter != p_fields.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmJvmFieldTable::get_numberOfTraversalSuccessors() const {
return p_fields.size() + 0;
}
SgNode *
SgAsmJvmFieldTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_fields.size());
return p_fields[idx];
}
size_t
SgAsmJvmFieldTable::get_childIndex(SgNode *child) const {
SgAsmJvmFieldPtrList::const_iterator itr = find(p_fields.begin(), p_fields.end(), child);
if (itr != p_fields.end()) return itr - p_fields.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmMethodTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_methods.size() + 0);
   {
     SgAsmJvmMethodPtrList::const_iterator iter;
     for (iter = p_methods.begin(); iter != p_methods.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmMethodTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmJvmMethodPtrList::const_iterator  iter;
     for (iter = p_methods.begin(); iter != p_methods.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmJvmMethodTable::get_numberOfTraversalSuccessors() const {
return p_methods.size() + 0;
}
SgNode *
SgAsmJvmMethodTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_methods.size());
return p_methods[idx];
}
size_t
SgAsmJvmMethodTable::get_childIndex(SgNode *child) const {
SgAsmJvmMethodPtrList::const_iterator itr = find(p_methods.begin(), p_methods.end(), child);
if (itr != p_methods.end()) return itr - p_methods.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmLEEntryTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmLEEntryPointPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmLEEntryTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmLEEntryPointPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmLEEntryTable::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmLEEntryTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmLEEntryTable::get_childIndex(SgNode *child) const {
SgAsmLEEntryPointPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmLENameTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmLENameTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmLENameTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmLENameTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmLENameTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmLENameTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmLENameTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmLEPageTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmLEPageTableEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmLEPageTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmLEPageTableEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmLEPageTable::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmLEPageTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmLEPageTable::get_childIndex(SgNode *child) const {
SgAsmLEPageTableEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmLERelocTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmLERelocEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmLERelocTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmLERelocEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmLERelocTable::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmLERelocTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmLERelocTable::get_childIndex(SgNode *child) const {
SgAsmLERelocEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmLESection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_sectionTableEntry);
return traversalSuccessorContainer;
}
vector<string>
SgAsmLESection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionTableEntry");
return traversalSuccessorContainer;
}
size_t
SgAsmLESection::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmLESection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionTableEntry == NULL || p_sectionTableEntry != NULL); return p_sectionTableEntry;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmLESection::get_childIndex(SgNode *child) const {
if (child == p_sectionTableEntry) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmLESectionTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmLESectionTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmLESectionTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmLESectionTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmLESectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmLESectionTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmLESectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmNEEntryTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmNEEntryPointPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmNEEntryTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmNEEntryPointPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmNEEntryTable::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmNEEntryTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmNEEntryTable::get_childIndex(SgNode *child) const {
SgAsmNEEntryPointPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmNEModuleTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_strtab);
return traversalSuccessorContainer;
}
vector<string>
SgAsmNEModuleTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_strtab");
return traversalSuccessorContainer;
}
size_t
SgAsmNEModuleTable::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmNEModuleTable::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_strtab == NULL || p_strtab != NULL); return p_strtab;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmNEModuleTable::get_childIndex(SgNode *child) const {
if (child == p_strtab) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmNENameTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmNENameTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmNENameTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmNENameTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmNENameTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmNENameTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmNENameTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmNERelocTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmNERelocEntryPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmNERelocTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmNERelocEntryPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmNERelocTable::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmNERelocTable::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmNERelocTable::get_childIndex(SgNode *child) const {
SgAsmNERelocEntryPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmNESection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_sectionTableEntry);
traversalSuccessorContainer.push_back(p_relocationTable);
return traversalSuccessorContainer;
}
vector<string>
SgAsmNESection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_sectionTableEntry");
traversalSuccessorContainer.push_back("p_relocationTable");
return traversalSuccessorContainer;
}
size_t
SgAsmNESection::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmNESection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_sectionTableEntry == NULL || p_sectionTableEntry != NULL); return p_sectionTableEntry;
case 1: ROSE_ASSERT(p_relocationTable == NULL || p_relocationTable != NULL); return p_relocationTable;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmNESection::get_childIndex(SgNode *child) const {
if (child == p_sectionTableEntry) return 0;
else if (child == p_relocationTable) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmNESectionTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmNESectionTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmNESectionTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmNESectionTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmNESectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmNESectionTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmNESectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmNEStringTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmNEStringTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmNEStringTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmNEStringTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmNEStringTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmNEStringTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmNEStringTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmPESection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_section_entry);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPESection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_section_entry");
return traversalSuccessorContainer;
}
size_t
SgAsmPESection::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmPESection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_section_entry == NULL || p_section_entry != NULL); return p_section_entry;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPESection::get_childIndex(SgNode *child) const {
if (child == p_section_entry) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEExportSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(3);
traversalSuccessorContainer.push_back(p_section_entry);
traversalSuccessorContainer.push_back(p_exportDirectory);
traversalSuccessorContainer.push_back(p_exports);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEExportSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_section_entry");
traversalSuccessorContainer.push_back("p_exportDirectory");
traversalSuccessorContainer.push_back("p_exports");
return traversalSuccessorContainer;
}
size_t
SgAsmPEExportSection::get_numberOfTraversalSuccessors() const {
return 3;
}
SgNode *
SgAsmPEExportSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_section_entry == NULL || p_section_entry != NULL); return p_section_entry;
case 1: ROSE_ASSERT(p_exportDirectory == NULL || p_exportDirectory != NULL); return p_exportDirectory;
case 2: ROSE_ASSERT(p_exports == NULL || p_exports != NULL); return p_exports;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEExportSection::get_childIndex(SgNode *child) const {
if (child == p_section_entry) return 0;
else if (child == p_exportDirectory) return 1;
else if (child == p_exports) return 2;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEImportSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_section_entry);
traversalSuccessorContainer.push_back(p_importDirectories);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEImportSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_section_entry");
traversalSuccessorContainer.push_back("p_importDirectories");
return traversalSuccessorContainer;
}
size_t
SgAsmPEImportSection::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmPEImportSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_section_entry == NULL || p_section_entry != NULL); return p_section_entry;
case 1: ROSE_ASSERT(p_importDirectories == NULL || p_importDirectories != NULL); return p_importDirectories;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEImportSection::get_childIndex(SgNode *child) const {
if (child == p_section_entry) return 0;
else if (child == p_importDirectories) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEStringSection::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_section_entry);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEStringSection::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_section_entry");
return traversalSuccessorContainer;
}
size_t
SgAsmPEStringSection::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmPEStringSection::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_section_entry == NULL || p_section_entry != NULL); return p_section_entry;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEStringSection::get_childIndex(SgNode *child) const {
if (child == p_section_entry) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPESectionTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmPESectionTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmPESectionTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmPESectionTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmPESectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmPESectionTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmPESectionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmGenericSectionList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_sections.size() + 0);
   {
     SgAsmGenericSectionPtrList::const_iterator iter;
     for (iter = p_sections.begin(); iter != p_sections.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericSectionList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmGenericSectionPtrList::const_iterator  iter;
     for (iter = p_sections.begin(); iter != p_sections.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmGenericSectionList::get_numberOfTraversalSuccessors() const {
return p_sections.size() + 0;
}
SgNode *
SgAsmGenericSectionList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_sections.size());
return p_sections[idx];
}
size_t
SgAsmGenericSectionList::get_childIndex(SgNode *child) const {
SgAsmGenericSectionPtrList::const_iterator itr = find(p_sections.begin(), p_sections.end(), child);
if (itr != p_sections.end()) return itr - p_sections.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmGenericString::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericString" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmGenericString::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericString" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmGenericString::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericString" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmGenericString::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericString" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmGenericString::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericString" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmBasicString::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmBasicString::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmBasicString::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmBasicString::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmBasicString" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmBasicString::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmBasicString" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmStoredString::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmStoredString::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmStoredString::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmStoredString::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmStoredString" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmStoredString::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmStoredString" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmGenericStrtab::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericStrtab" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmGenericStrtab::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericStrtab" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmGenericStrtab::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericStrtab" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmGenericStrtab::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericStrtab" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmGenericStrtab::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericStrtab" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmCoffStrtab::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmCoffStrtab::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmCoffStrtab::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmCoffStrtab::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmCoffStrtab" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmCoffStrtab::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmCoffStrtab" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmElfStrtab::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfStrtab::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmElfStrtab::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmElfStrtab::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmElfStrtab" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmElfStrtab::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmElfStrtab" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmGenericSymbol::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmGenericSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmGenericSymbol::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericSymbol" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmGenericSymbol::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmGenericSymbol::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmGenericSymbol" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmCoffSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmCoffSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmCoffSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmCoffSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmCoffSymbol::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmElfSymbol::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmElfSymbol::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmElfSymbol::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmElfSymbol::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmElfSymbol::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmGenericSymbolList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericSymbolList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmGenericSymbolList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmGenericSymbolList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmGenericSymbolList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmGenericSymbolList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmGenericSymbolList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmLEEntryPoint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_entries.size() + 0);
   {
     SgAsmLEEntryPointPtrList::const_iterator iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmLEEntryPoint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmLEEntryPointPtrList::const_iterator  iter;
     for (iter = p_entries.begin(); iter != p_entries.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmLEEntryPoint::get_numberOfTraversalSuccessors() const {
return p_entries.size() + 0;
}
SgNode *
SgAsmLEEntryPoint::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_entries.size());
return p_entries[idx];
}
size_t
SgAsmLEEntryPoint::get_childIndex(SgNode *child) const {
SgAsmLEEntryPointPtrList::const_iterator itr = find(p_entries.begin(), p_entries.end(), child);
if (itr != p_entries.end()) return itr - p_entries.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmLEPageTableEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmLEPageTableEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmLEPageTableEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmLEPageTableEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmLEPageTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmLEPageTableEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmLEPageTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmLESectionTableEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmLESectionTableEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmLESectionTableEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmLESectionTableEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmLESectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmLESectionTableEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmLESectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmNEEntryPoint::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmNEEntryPoint::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmNEEntryPoint::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmNEEntryPoint::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmNEEntryPoint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmNEEntryPoint::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmNEEntryPoint" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmNERelocEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmNERelocEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmNERelocEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmNERelocEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmNERelocEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmNERelocEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmNERelocEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmNESectionTableEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmNESectionTableEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmNESectionTableEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmNESectionTableEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmNESectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmNESectionTableEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmNESectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmPEExportDirectory::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEExportDirectory::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmPEExportDirectory::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmPEExportDirectory::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEExportDirectory::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEExportEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_name);
traversalSuccessorContainer.push_back(p_forwarder);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEExportEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
traversalSuccessorContainer.push_back("p_forwarder");
return traversalSuccessorContainer;
}
size_t
SgAsmPEExportEntry::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmPEExportEntry::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
case 1: ROSE_ASSERT(p_forwarder == NULL || p_forwarder != NULL); return p_forwarder;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEExportEntry::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else if (child == p_forwarder) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEExportEntryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_exports.size() + 0);
   {
     SgAsmPEExportEntryPtrList::const_iterator iter;
     for (iter = p_exports.begin(); iter != p_exports.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEExportEntryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmPEExportEntryPtrList::const_iterator  iter;
     for (iter = p_exports.begin(); iter != p_exports.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmPEExportEntryList::get_numberOfTraversalSuccessors() const {
return p_exports.size() + 0;
}
SgNode *
SgAsmPEExportEntryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_exports.size());
return p_exports[idx];
}
size_t
SgAsmPEExportEntryList::get_childIndex(SgNode *child) const {
SgAsmPEExportEntryPtrList::const_iterator itr = find(p_exports.begin(), p_exports.end(), child);
if (itr != p_exports.end()) return itr - p_exports.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEImportDirectory::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_dllName);
traversalSuccessorContainer.push_back(p_imports);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEImportDirectory::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_dllName");
traversalSuccessorContainer.push_back("p_imports");
return traversalSuccessorContainer;
}
size_t
SgAsmPEImportDirectory::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmPEImportDirectory::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_dllName == NULL || p_dllName != NULL); return p_dllName;
case 1: ROSE_ASSERT(p_imports == NULL || p_imports != NULL); return p_imports;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEImportDirectory::get_childIndex(SgNode *child) const {
if (child == p_dllName) return 0;
else if (child == p_imports) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEImportDirectoryList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_vector.size() + 0);
   {
     SgAsmPEImportDirectoryPtrList::const_iterator iter;
     for (iter = p_vector.begin(); iter != p_vector.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEImportDirectoryList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmPEImportDirectoryPtrList::const_iterator  iter;
     for (iter = p_vector.begin(); iter != p_vector.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmPEImportDirectoryList::get_numberOfTraversalSuccessors() const {
return p_vector.size() + 0;
}
SgNode *
SgAsmPEImportDirectoryList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_vector.size());
return p_vector[idx];
}
size_t
SgAsmPEImportDirectoryList::get_childIndex(SgNode *child) const {
SgAsmPEImportDirectoryPtrList::const_iterator itr = find(p_vector.begin(), p_vector.end(), child);
if (itr != p_vector.end()) return itr - p_vector.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEImportItem::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_name);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEImportItem::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_name");
return traversalSuccessorContainer;
}
size_t
SgAsmPEImportItem::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmPEImportItem::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_name == NULL || p_name != NULL); return p_name;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPEImportItem::get_childIndex(SgNode *child) const {
if (child == p_name) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPEImportItemList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_vector.size() + 0);
   {
     SgAsmPEImportItemPtrList::const_iterator iter;
     for (iter = p_vector.begin(); iter != p_vector.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmPEImportItemList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmPEImportItemPtrList::const_iterator  iter;
     for (iter = p_vector.begin(); iter != p_vector.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmPEImportItemList::get_numberOfTraversalSuccessors() const {
return p_vector.size() + 0;
}
SgNode *
SgAsmPEImportItemList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_vector.size());
return p_vector[idx];
}
size_t
SgAsmPEImportItemList::get_childIndex(SgNode *child) const {
SgAsmPEImportItemPtrList::const_iterator itr = find(p_vector.begin(), p_vector.end(), child);
if (itr != p_vector.end()) return itr - p_vector.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPERVASizePair::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmPERVASizePair::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmPERVASizePair::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmPERVASizePair::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmPERVASizePair" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmPERVASizePair::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmPERVASizePair" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmPERVASizePairList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_pairs.size() + 0);
   {
     SgAsmPERVASizePairPtrList::const_iterator iter;
     for (iter = p_pairs.begin(); iter != p_pairs.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmPERVASizePairList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmPERVASizePairPtrList::const_iterator  iter;
     for (iter = p_pairs.begin(); iter != p_pairs.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmPERVASizePairList::get_numberOfTraversalSuccessors() const {
return p_pairs.size() + 0;
}
SgNode *
SgAsmPERVASizePairList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_pairs.size());
return p_pairs[idx];
}
size_t
SgAsmPERVASizePairList::get_childIndex(SgNode *child) const {
SgAsmPERVASizePairPtrList::const_iterator itr = find(p_pairs.begin(), p_pairs.end(), child);
if (itr != p_pairs.end()) return itr - p_pairs.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPESectionTableEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmPESectionTableEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmPESectionTableEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmPESectionTableEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmPESectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmPESectionTableEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmPESectionTableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmStringStorage::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmStringStorage::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmStringStorage::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmStringStorage::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmStringStorage" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmStringStorage::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmStringStorage" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmExpression::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmExpression::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExpression" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmExpression::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmExpression::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmAarch32Coprocessor::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmAarch32Coprocessor::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmAarch32Coprocessor::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmAarch32Coprocessor::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmAarch32Coprocessor" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmAarch32Coprocessor::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmAarch32Coprocessor" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmBinaryExpression::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmBinaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmBinaryExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmBinaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmBinaryExpression::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmBinaryExpression" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmBinaryExpression::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmBinaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmBinaryExpression::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmBinaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmBinaryAdd::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryAdd::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryAdd::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryAdd::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryAdd::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryAsr::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryAsr::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryAsr::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryAsr::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryAsr::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryConcat::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryConcat::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryConcat::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryConcat::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryConcat::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryDivide::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryDivide::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryDivide::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryDivide::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryDivide::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryLsl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryLsl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryLsl::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryLsl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryLsl::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryLsr::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryLsr::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryLsr::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryLsr::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryLsr::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryMod::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryMod::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryMod::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryMod::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryMod::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryMsl::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryMsl::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryMsl::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryMsl::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryMsl::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryMultiply::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryMultiply::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryMultiply::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryMultiply::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryMultiply::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryPostupdate::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryPostupdate::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryPostupdate::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryPostupdate::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryPostupdate::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryPreupdate::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryPreupdate::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryPreupdate::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryPreupdate::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryPreupdate::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinaryRor::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinaryRor::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinaryRor::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinaryRor::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinaryRor::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmBinarySubtract::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_lhs);
traversalSuccessorContainer.push_back(p_rhs);
return traversalSuccessorContainer;
}
vector<string>
SgAsmBinarySubtract::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_lhs");
traversalSuccessorContainer.push_back("p_rhs");
return traversalSuccessorContainer;
}
size_t
SgAsmBinarySubtract::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmBinarySubtract::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_lhs == NULL || p_lhs != NULL); return p_lhs;
case 1: ROSE_ASSERT(p_rhs == NULL || p_rhs != NULL); return p_rhs;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmBinarySubtract::get_childIndex(SgNode *child) const {
if (child == p_lhs) return 0;
else if (child == p_rhs) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmByteOrder::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmByteOrder::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmByteOrder::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmByteOrder::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmByteOrder" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmByteOrder::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmByteOrder" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmCommonSubExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_subexpression);
return traversalSuccessorContainer;
}
vector<string>
SgAsmCommonSubExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_subexpression");
return traversalSuccessorContainer;
}
size_t
SgAsmCommonSubExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmCommonSubExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_subexpression == NULL || p_subexpression != NULL); return p_subexpression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmCommonSubExpression::get_childIndex(SgNode *child) const {
if (child == p_subexpression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmControlFlagsExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmControlFlagsExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmControlFlagsExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmControlFlagsExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmControlFlagsExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmControlFlagsExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmControlFlagsExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmExprListExp::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_expressions.size() + 0);
   {
     SgAsmExpressionPtrList::const_iterator iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmExprListExp::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmExpressionPtrList::const_iterator  iter;
     for (iter = p_expressions.begin(); iter != p_expressions.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmExprListExp::get_numberOfTraversalSuccessors() const {
return p_expressions.size() + 0;
}
SgNode *
SgAsmExprListExp::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_expressions.size());
return p_expressions[idx];
}
size_t
SgAsmExprListExp::get_childIndex(SgNode *child) const {
SgAsmExpressionPtrList::const_iterator itr = find(p_expressions.begin(), p_expressions.end(), child);
if (itr != p_expressions.end()) return itr - p_expressions.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmMemoryReferenceExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_address);
traversalSuccessorContainer.push_back(p_segment);
return traversalSuccessorContainer;
}
vector<string>
SgAsmMemoryReferenceExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_address");
traversalSuccessorContainer.push_back("p_segment");
return traversalSuccessorContainer;
}
size_t
SgAsmMemoryReferenceExpression::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmMemoryReferenceExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_address == NULL || p_address != NULL); return p_address;
case 1: ROSE_ASSERT(p_segment == NULL || p_segment != NULL); return p_segment;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmMemoryReferenceExpression::get_childIndex(SgNode *child) const {
if (child == p_address) return 0;
else if (child == p_segment) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmRegisterNames::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_registers.size() + 0);
   {
     SgAsmRegisterReferenceExpressionPtrList::const_iterator iter;
     for (iter = p_registers.begin(); iter != p_registers.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmRegisterNames::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmRegisterReferenceExpressionPtrList::const_iterator  iter;
     for (iter = p_registers.begin(); iter != p_registers.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmRegisterNames::get_numberOfTraversalSuccessors() const {
return p_registers.size() + 0;
}
SgNode *
SgAsmRegisterNames::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_registers.size());
return p_registers[idx];
}
size_t
SgAsmRegisterNames::get_childIndex(SgNode *child) const {
SgAsmRegisterReferenceExpressionPtrList::const_iterator itr = find(p_registers.begin(), p_registers.end(), child);
if (itr != p_registers.end()) return itr - p_registers.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmRegisterReferenceExpression::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmRegisterReferenceExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmRegisterReferenceExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmRegisterReferenceExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmRegisterReferenceExpression::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmRegisterReferenceExpression" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmRegisterReferenceExpression::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmRegisterReferenceExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmRegisterReferenceExpression::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmRegisterReferenceExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmDirectRegisterExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmDirectRegisterExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmDirectRegisterExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmDirectRegisterExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmDirectRegisterExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmDirectRegisterExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmDirectRegisterExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmIndirectRegisterExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmIndirectRegisterExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmIndirectRegisterExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmIndirectRegisterExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmIndirectRegisterExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmIndirectRegisterExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmIndirectRegisterExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmRiscOperation::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operands);
return traversalSuccessorContainer;
}
vector<string>
SgAsmRiscOperation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operands");
return traversalSuccessorContainer;
}
size_t
SgAsmRiscOperation::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmRiscOperation::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operands == NULL || p_operands != NULL); return p_operands;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmRiscOperation::get_childIndex(SgNode *child) const {
if (child == p_operands) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmStackExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmStackExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmStackExpression::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmStackExpression::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmStackExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmStackExpression::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmStackExpression" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmUnaryExpression::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmUnaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmUnaryExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmUnaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmUnaryExpression::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmUnaryExpression" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmUnaryExpression::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmUnaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmUnaryExpression::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmUnaryExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmUnaryMinus::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand);
return traversalSuccessorContainer;
}
vector<string>
SgAsmUnaryMinus::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand");
return traversalSuccessorContainer;
}
size_t
SgAsmUnaryMinus::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmUnaryMinus::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand == NULL || p_operand != NULL); return p_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmUnaryMinus::get_childIndex(SgNode *child) const {
if (child == p_operand) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmUnaryPlus::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand);
return traversalSuccessorContainer;
}
vector<string>
SgAsmUnaryPlus::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand");
return traversalSuccessorContainer;
}
size_t
SgAsmUnaryPlus::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmUnaryPlus::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand == NULL || p_operand != NULL); return p_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmUnaryPlus::get_childIndex(SgNode *child) const {
if (child == p_operand) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmUnaryRrx::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand);
return traversalSuccessorContainer;
}
vector<string>
SgAsmUnaryRrx::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand");
return traversalSuccessorContainer;
}
size_t
SgAsmUnaryRrx::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmUnaryRrx::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand == NULL || p_operand != NULL); return p_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmUnaryRrx::get_childIndex(SgNode *child) const {
if (child == p_operand) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmUnarySignedExtend::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand);
return traversalSuccessorContainer;
}
vector<string>
SgAsmUnarySignedExtend::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand");
return traversalSuccessorContainer;
}
size_t
SgAsmUnarySignedExtend::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmUnarySignedExtend::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand == NULL || p_operand != NULL); return p_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmUnarySignedExtend::get_childIndex(SgNode *child) const {
if (child == p_operand) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmUnaryTruncate::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand);
return traversalSuccessorContainer;
}
vector<string>
SgAsmUnaryTruncate::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand");
return traversalSuccessorContainer;
}
size_t
SgAsmUnaryTruncate::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmUnaryTruncate::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand == NULL || p_operand != NULL); return p_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmUnaryTruncate::get_childIndex(SgNode *child) const {
if (child == p_operand) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmUnaryUnsignedExtend::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_operand);
return traversalSuccessorContainer;
}
vector<string>
SgAsmUnaryUnsignedExtend::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operand");
return traversalSuccessorContainer;
}
size_t
SgAsmUnaryUnsignedExtend::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmUnaryUnsignedExtend::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operand == NULL || p_operand != NULL); return p_operand;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmUnaryUnsignedExtend::get_childIndex(SgNode *child) const {
if (child == p_operand) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmValueExpression::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmValueExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmValueExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmValueExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmValueExpression::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmValueExpression" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmValueExpression::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmValueExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmValueExpression::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmValueExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmConstantExpression::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmConstantExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmConstantExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmConstantExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmConstantExpression::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmConstantExpression" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmConstantExpression::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmConstantExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmConstantExpression::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmConstantExpression" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmFloatValueExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_unfoldedExpression);
return traversalSuccessorContainer;
}
vector<string>
SgAsmFloatValueExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_unfoldedExpression");
return traversalSuccessorContainer;
}
size_t
SgAsmFloatValueExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmFloatValueExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_unfoldedExpression == NULL || p_unfoldedExpression != NULL); return p_unfoldedExpression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmFloatValueExpression::get_childIndex(SgNode *child) const {
if (child == p_unfoldedExpression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmIntegerValueExpression::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_unfoldedExpression);
return traversalSuccessorContainer;
}
vector<string>
SgAsmIntegerValueExpression::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_unfoldedExpression");
return traversalSuccessorContainer;
}
size_t
SgAsmIntegerValueExpression::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmIntegerValueExpression::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_unfoldedExpression == NULL || p_unfoldedExpression != NULL); return p_unfoldedExpression;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmIntegerValueExpression::get_childIndex(SgNode *child) const {
if (child == p_unfoldedExpression) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmGenericFileList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_files.size() + 0);
   {
     SgAsmGenericFilePtrList::const_iterator iter;
     for (iter = p_files.begin(); iter != p_files.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmGenericFileList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmGenericFilePtrList::const_iterator  iter;
     for (iter = p_files.begin(); iter != p_files.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmGenericFileList::get_numberOfTraversalSuccessors() const {
return p_files.size() + 0;
}
SgNode *
SgAsmGenericFileList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_files.size());
return p_files[idx];
}
size_t
SgAsmGenericFileList::get_childIndex(SgNode *child) const {
SgAsmGenericFilePtrList::const_iterator itr = find(p_files.begin(), p_files.end(), child);
if (itr != p_files.end()) return itr - p_files.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmInstructionList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmInstructionList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmInstructionList::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmInstructionList::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmInstructionList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmInstructionList::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmInstructionList" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmInterpretation::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_globalBlock);
return traversalSuccessorContainer;
}
vector<string>
SgAsmInterpretation::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_globalBlock");
return traversalSuccessorContainer;
}
size_t
SgAsmInterpretation::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmInterpretation::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_globalBlock == NULL || p_globalBlock != NULL); return p_globalBlock;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmInterpretation::get_childIndex(SgNode *child) const {
if (child == p_globalBlock) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmInterpretationList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_interpretations.size() + 0);
   {
     SgAsmInterpretationPtrList::const_iterator iter;
     for (iter = p_interpretations.begin(); iter != p_interpretations.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmInterpretationList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmInterpretationPtrList::const_iterator  iter;
     for (iter = p_interpretations.begin(); iter != p_interpretations.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmInterpretationList::get_numberOfTraversalSuccessors() const {
return p_interpretations.size() + 0;
}
SgNode *
SgAsmInterpretationList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_interpretations.size());
return p_interpretations[idx];
}
size_t
SgAsmInterpretationList::get_childIndex(SgNode *child) const {
SgAsmInterpretationPtrList::const_iterator itr = find(p_interpretations.begin(), p_interpretations.end(), child);
if (itr != p_interpretations.end()) return itr - p_interpretations.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmNode::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmJvmNode::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmJvmNode::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmNode" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmJvmNode::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmJvmNode::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmNode" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmJvmAttribute::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmJvmAttribute::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmJvmAttribute::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmAttribute" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmJvmAttribute::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmJvmAttribute::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmJvmAttribute" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmJvmBootstrapMethods::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmBootstrapMethods::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmBootstrapMethods::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmBootstrapMethods::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmBootstrapMethods" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmBootstrapMethods::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmBootstrapMethods" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmCodeAttribute::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmCodeAttribute::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmCodeAttribute::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmCodeAttribute::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmCodeAttribute" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmCodeAttribute::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmCodeAttribute" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmConstantValue::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmConstantValue::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmConstantValue::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmConstantValue::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmConstantValue" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmConstantValue::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmConstantValue" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmDeprecated::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmDeprecated::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmDeprecated::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmDeprecated::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmDeprecated" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmDeprecated::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmDeprecated" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmEnclosingMethod::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmEnclosingMethod::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmEnclosingMethod::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmEnclosingMethod::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmEnclosingMethod" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmEnclosingMethod::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmEnclosingMethod" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmExceptions::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmExceptions::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmExceptions::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmExceptions::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmExceptions" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmExceptions::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmExceptions" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmInnerClasses::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmInnerClasses::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmInnerClasses::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmInnerClasses::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmInnerClasses" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmInnerClasses::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmInnerClasses" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmLineNumberTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmLineNumberTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmLineNumberTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmLineNumberTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmLineNumberTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmLineNumberTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmLineNumberTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmLocalVariableTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmLocalVariableTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmLocalVariableTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmLocalVariableTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmLocalVariableTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmLocalVariableTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmLocalVariableTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmLocalVariableTypeTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmLocalVariableTypeTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmLocalVariableTypeTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmLocalVariableTypeTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmLocalVariableTypeTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmLocalVariableTypeTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmLocalVariableTypeTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmMethodParameters::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmMethodParameters::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmMethodParameters::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmMethodParameters::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmMethodParameters" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmMethodParameters::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmMethodParameters" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmModuleMainClass::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmModuleMainClass::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmModuleMainClass::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmModuleMainClass::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmModuleMainClass" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmModuleMainClass::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmModuleMainClass" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmNestHost::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmNestHost::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmNestHost::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmNestHost::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmNestHost" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmNestHost::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmNestHost" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmNestMembers::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmNestMembers::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmNestMembers::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmNestMembers::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmNestMembers" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmNestMembers::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmNestMembers" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmSignature::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmSignature::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmSignature::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmSignature::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmSignature" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmSignature::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmSignature" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmSourceFile::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmSourceFile::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmSourceFile::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmSourceFile::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmSourceFile" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmSourceFile::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmSourceFile" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmStackMapTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmStackMapTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmStackMapTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmStackMapTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmStackMapTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmStackMapTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmStackMapTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmSynthetic::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmSynthetic::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmSynthetic::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmSynthetic::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmSynthetic" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmSynthetic::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmSynthetic" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmBootstrapMethod::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmBootstrapMethod::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmBootstrapMethod::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmBootstrapMethod::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmBootstrapMethod" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmBootstrapMethod::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmBootstrapMethod" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmClass::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmClass::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmClass::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmClass::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmClass" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmClass::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmClass" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmConstantPoolEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmConstantPoolEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmConstantPoolEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmConstantPoolEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmConstantPoolEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmConstantPoolEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmConstantPoolEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmExceptionHandler::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmExceptionHandler::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmExceptionHandler::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmExceptionHandler::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmExceptionHandler" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmExceptionHandler::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmExceptionHandler" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmExceptionTable::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmExceptionTable::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmExceptionTable::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmExceptionTable::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmExceptionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmExceptionTable::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmExceptionTable" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmField::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_attribute_table);
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmField::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_attribute_table");
return traversalSuccessorContainer;
}
size_t
SgAsmJvmField::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmJvmField::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_attribute_table == NULL || p_attribute_table != NULL); return p_attribute_table;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmJvmField::get_childIndex(SgNode *child) const {
if (child == p_attribute_table) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmInnerClassesEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmInnerClassesEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmInnerClassesEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmInnerClassesEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmInnerClassesEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmInnerClassesEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmInnerClassesEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmLineNumberEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmLineNumberEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmLineNumberEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmLineNumberEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmLineNumberEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmLineNumberEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmLineNumberEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmLocalVariableEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmLocalVariableEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmLocalVariableEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmLocalVariableEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmLocalVariableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmLocalVariableEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmLocalVariableEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmLocalVariableTypeEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmLocalVariableTypeEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmLocalVariableTypeEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmLocalVariableTypeEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmLocalVariableTypeEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmLocalVariableTypeEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmLocalVariableTypeEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmMethod::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_attribute_table);
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmMethod::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_attribute_table");
return traversalSuccessorContainer;
}
size_t
SgAsmJvmMethod::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmJvmMethod::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_attribute_table == NULL || p_attribute_table != NULL); return p_attribute_table;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmJvmMethod::get_childIndex(SgNode *child) const {
if (child == p_attribute_table) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmMethodParametersEntry::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmMethodParametersEntry::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmMethodParametersEntry::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmMethodParametersEntry::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmMethodParametersEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmMethodParametersEntry::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmMethodParametersEntry" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmStackMapFrame::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmStackMapFrame::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmStackMapFrame::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmStackMapFrame::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmStackMapFrame" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmStackMapFrame::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmStackMapFrame" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmJvmStackMapVerificationType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmStackMapVerificationType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmJvmStackMapVerificationType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmJvmStackMapVerificationType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmJvmStackMapVerificationType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmJvmStackMapVerificationType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmJvmStackMapVerificationType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmOperandList::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_operands.size() + 0);
   {
     SgAsmExpressionPtrList::const_iterator iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmOperandList::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmExpressionPtrList::const_iterator  iter;
     for (iter = p_operands.begin(); iter != p_operands.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmOperandList::get_numberOfTraversalSuccessors() const {
return p_operands.size() + 0;
}
SgNode *
SgAsmOperandList::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_operands.size());
return p_operands[idx];
}
size_t
SgAsmOperandList::get_childIndex(SgNode *child) const {
SgAsmExpressionPtrList::const_iterator itr = find(p_operands.begin(), p_operands.end(), child);
if (itr != p_operands.end()) return itr - p_operands.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmStatement::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmStatement::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmStatement::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmStatement" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmStatement::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmStatement::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmStatement" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmBlock::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_statementList.size() + 0);
   {
     SgAsmStatementPtrList::const_iterator iter;
     for (iter = p_statementList.begin(); iter != p_statementList.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmBlock::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmStatementPtrList::const_iterator  iter;
     for (iter = p_statementList.begin(); iter != p_statementList.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmBlock::get_numberOfTraversalSuccessors() const {
return p_statementList.size() + 0;
}
SgNode *
SgAsmBlock::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_statementList.size());
return p_statementList[idx];
}
size_t
SgAsmBlock::get_childIndex(SgNode *child) const {
SgAsmStatementPtrList::const_iterator itr = find(p_statementList.begin(), p_statementList.end(), child);
if (itr != p_statementList.end()) return itr - p_statementList.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmCilInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmCilInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmCilInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmCilInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmCilInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmJvmInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmJvmInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmJvmInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmJvmInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmJvmInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmM68kInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmM68kInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmM68kInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmM68kInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmM68kInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmMipsInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmMipsInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmMipsInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmMipsInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmMipsInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmNullInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmNullInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmNullInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmNullInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmNullInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmPowerpcInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPowerpcInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmPowerpcInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmPowerpcInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPowerpcInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmUserInstruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmUserInstruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmUserInstruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmUserInstruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmUserInstruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmX86Instruction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(2);
traversalSuccessorContainer.push_back(p_operandList);
traversalSuccessorContainer.push_back(p_semantics);
return traversalSuccessorContainer;
}
vector<string>
SgAsmX86Instruction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_operandList");
traversalSuccessorContainer.push_back("p_semantics");
return traversalSuccessorContainer;
}
size_t
SgAsmX86Instruction::get_numberOfTraversalSuccessors() const {
return 2;
}
SgNode *
SgAsmX86Instruction::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_operandList == NULL || p_operandList != NULL); return p_operandList;
case 1: ROSE_ASSERT(p_semantics == NULL || p_semantics != NULL); return p_semantics;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmX86Instruction::get_childIndex(SgNode *child) const {
if (child == p_operandList) return 0;
else if (child == p_semantics) return 1;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmStaticData::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmStaticData::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmStaticData::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmStaticData::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmStaticData" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmStaticData::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmStaticData" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmSynthesizedDeclaration::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmSynthesizedDeclaration" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmSynthesizedDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmSynthesizedDeclaration" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmSynthesizedDeclaration::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmSynthesizedDeclaration" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmSynthesizedDeclaration::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmSynthesizedDeclaration" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmSynthesizedDeclaration::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmSynthesizedDeclaration" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmFunction::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(p_statementList.size() + 0);
   {
     SgAsmStatementPtrList::const_iterator iter;
     for (iter = p_statementList.begin(); iter != p_statementList.end(); iter++)
          traversalSuccessorContainer.push_back(*iter);
        }
return traversalSuccessorContainer;
}
vector<string>
SgAsmFunction::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
int i = 0;
   {
     SgAsmStatementPtrList::const_iterator  iter;
     for (iter = p_statementList.begin(); iter != p_statementList.end(); (iter++,i++)) {
char buf[20];
snprintf(buf,sizeof(buf),"*[%d]",i);
traversalSuccessorContainer.push_back(buf);
        }
   }
return traversalSuccessorContainer;
}
size_t
SgAsmFunction::get_numberOfTraversalSuccessors() const {
return p_statementList.size() + 0;
}
SgNode *
SgAsmFunction::get_traversalSuccessorByIndex(size_t idx) const {
ROSE_ASSERT(idx < p_statementList.size());
return p_statementList[idx];
}
size_t
SgAsmFunction::get_childIndex(SgNode *child) const {
SgAsmStatementPtrList::const_iterator itr = find(p_statementList.begin(), p_statementList.end(), child);
if (itr != p_statementList.end()) return itr - p_statementList.begin();
else return (size_t) -1;
}
vector<SgNode*>
SgAsmSynthesizedDataStructureDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmSynthesizedDataStructureDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmSynthesizedDataStructureDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmSynthesizedDataStructureDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmSynthesizedDataStructureDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmSynthesizedDataStructureDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmSynthesizedDataStructureDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmSynthesizedFieldDeclaration::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmSynthesizedFieldDeclaration::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmSynthesizedFieldDeclaration::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmSynthesizedFieldDeclaration::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmSynthesizedFieldDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmSynthesizedFieldDeclaration::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmSynthesizedFieldDeclaration" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmType::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmType::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmType" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmType::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmType::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmScalarType::get_traversalSuccessorContainer() const {
vector<SgNode*> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmScalarType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

vector<string>
SgAsmScalarType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmScalarType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return traversalSuccessorContainer;
 }

size_t
SgAsmScalarType::get_numberOfTraversalSuccessors() const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmScalarType" << endl << "dynamic:  this = " << this << " = " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

SgNode*
SgAsmScalarType::get_traversalSuccessorByIndex(size_t) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmScalarType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return NULL;
 }

size_t
SgAsmScalarType::get_childIndex(SgNode *) const {
   cerr << "Internal error(!): called tree traversal mechanism for illegal object: " << endl
<< "static: SgAsmScalarType" << endl << "dynamic:  " << this->sage_class_name() << endl;
cerr << "Aborting ..." << endl;
ROSE_ASSERT(false);
return 42;
 }

vector<SgNode*>
SgAsmFloatType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmFloatType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmFloatType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmFloatType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmFloatType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmFloatType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmFloatType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmIntegerType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmIntegerType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmIntegerType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmIntegerType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmIntegerType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmIntegerType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmIntegerType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmPointerType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
  traversalSuccessorContainer.reserve(1);
traversalSuccessorContainer.push_back(p_subtype);
return traversalSuccessorContainer;
}
vector<string>
SgAsmPointerType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
traversalSuccessorContainer.push_back("p_subtype");
return traversalSuccessorContainer;
}
size_t
SgAsmPointerType::get_numberOfTraversalSuccessors() const {
return 1;
}
SgNode *
SgAsmPointerType::get_traversalSuccessorByIndex(size_t idx) const {
switch (idx) {
case 0: ROSE_ASSERT(p_subtype == NULL || p_subtype != NULL); return p_subtype;
default: cout << "invalid index " << idx << " in get_traversalSuccessorByIndex()" << endl;
ROSE_ASSERT(false);
return NULL;
}
}
size_t
SgAsmPointerType::get_childIndex(SgNode *child) const {
if (child == p_subtype) return 0;
else return (size_t) -1;
}
vector<SgNode*>
SgAsmVectorType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmVectorType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmVectorType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmVectorType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmVectorType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmVectorType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmVectorType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}
vector<SgNode*>
SgAsmVoidType::get_traversalSuccessorContainer() const {
  vector<SgNode*> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
vector<string>
SgAsmVoidType::get_traversalSuccessorNamesContainer() const {
vector<string> traversalSuccessorContainer;
return traversalSuccessorContainer;
}
size_t
SgAsmVoidType::get_numberOfTraversalSuccessors() const {
return 0;
}
SgNode *
SgAsmVoidType::get_traversalSuccessorByIndex(size_t idx) const {
cout << "error: get_traversalSuccessorByIndex called on node of type " << "SgAsmVoidType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return NULL;
}
size_t
SgAsmVoidType::get_childIndex(SgNode *child) const {
cout << "error: get_childIndex called on node of type " << "SgAsmVoidType" << " that has no successors!" << endl;
ROSE_ASSERT(false);
return 0; 
}

